This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.grok/
  settings.json
config/
  corrected_mapping_table.json
  node_name_map.json
  run_state.json
  server-config.json
docx2json/
  .grok/
    settings.json
  .git
  250804_negative_revisions_content.json
  250818_summer_break_content.json
  README.md
  to_ncj.py
scripts/
  execute_seedless_validation.js
  run_weekly_poster.js
  setup.sh
  test_plugin_startup.js
  validate_seedless.js
src/
  cursor_mcp_plugin/
    code.js
    manifest.json
    setcharacters.js
    ui.html
  talk_to_figma_mcp/
    package.json
    server.ts
    tsconfig.json
  config-resolver.js
  content-generator.js
  figma-channel-manager.js
  smart-mapping-algorithm.js
  socket.ts
  static-server.js
  template-styles.js
  workflow_automation_enhanced.js
  workflow_automation.js
.gitignore
.gitmodules
AGENTS.md
Dockerfile
DRAGME.md
LICENSE
mcp-config.json
package.json
readme.md
smithery.yaml
tsconfig.json
tsup.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docx2json/.grok/settings.json">
{
  "model": "grok-4-latest"
}
</file>

<file path="docx2json/.git">
gitdir: ../.git/modules/docx2json
</file>

<file path="docx2json/250804_negative_revisions_content.json">
{
  "doc": {
    "title": "Negative Revisions",
    "date": "2025-08-04",
    "locale": "zh-CN",
    "version": "v1",
    "source_file": "250804 - Negative Revisions.docx"
  },
  "blocks": [
    {
      "type": "figure",
      "image": {
        "asset_id": "img_74740ea292f9"
      },
      "title": null,
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0001",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "涨多终将回调。在经历了一段「只涨不跌」的行情后，风险资产在全面低于预期的非农就业数据打击下走低。整体就业数据疲软（失业率由 4.117% 升至 4.248%），再次印证了就业市场放缓的趋势，此外，美国劳工统计局也发布了近年来（除疫情期间外）最大规模的两个月就业数据下修（-25.8 万）。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_ac79747eaa30"
      },
      "title": "近年来最大规模的两个月就业数据下修（除疫情期间外）令市场措手不及",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0002",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_8ec9cb9ae6e9"
      },
      "title": null,
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0002",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "雪上加霜的是，ISM 制造业就业指数跌至 2020 年第二季度以来的最低水平，而其他领先指标也预示著就业市场恐将进一步恶化。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_03a293910220"
      },
      "title": "多项领先指标显示就业市场仍有下行压力",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0003",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_d4ca6e3b06c4"
      },
      "title": null,
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0003",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "市场反应迅速且剧烈，美国股市收盘下跌 2% 至 3%，美元兑日圆下跌 2.2% 至 147，而对比前一日，利率市场定价所反映的年底前降息预期几乎增加了 25 个基点。"
    },
    {
      "type": "paragraph",
      "text": "收益率变化特别显著，2 年期收益率当日崩跌近 30 个基点，是近五年来最大单日跌幅之一。上周结束时，市场对今年降息预期升至约 60 个基点，而前一天仅为 35 个基点左右，这促使 Trump 总统猛烈抨击美联储主席 Powell 未能及时降息，并批评美国劳工统计局公布「不准确」的就业数据。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_b5faf10ceb72"
      },
      "title": "2 年期收益率遭遇近年来最大单日跌幅之一",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0004",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_b6a9fd5b0797"
      },
      "title": null,
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0004",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_916b04850d01"
      },
      "title": "利率市场定价反映年底前 60 个基点左右的降息预期",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0005",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_f8dc418031b4"
      },
      "title": null,
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0005",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "“ 我们需要准确的就业数据 …… 现在的数据是 Biden 政府任命的人做的。 ” “ 在我看来，现在的就业数据是被操纵过的，目的就是为了让共和党和我丢脸。 ” -- Trump 总统"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_308defa20ceb"
      },
      "title": null,
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0006",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_9531c10ca8b1"
      },
      "title": null,
      "credit": "Truth Social, WSJ, Bloomberg",
      "credit_tokens": [
        "Truth Social",
        "WSJ",
        "Bloomberg"
      ],
      "group_id": "grp_0006",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "上周五市场的剧烈反应也盖过了近期美联储偏鹰派的会议内容。会中 Powell 强调，美联储已在尽力透过维持利率不变以应对商品通胀。同时，随著美联储理事 Kugler 辞职，Trump 总统可能在短期内提名新的人选，对美联储的施压只会进一步升高。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_1e4a81f54c2d"
      },
      "title": "美联储在最新一次会议上承认商品通胀压力正在上升",
      "credit": "Fortune",
      "credit_tokens": [
        "Fortune"
      ],
      "group_id": "grp_0007",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "谈到政策影响，Trump 总统也再次延后实施新一轮关税，从原定的 8 月 1 日延后至 8 月 7 日，为本周的密集谈判铺路。谈判焦点将放在瑞士（关税高达 39%）、台湾、加拿大和巴西，同时市场也将持续关注俄乌局势升温，以及美国部署潜舰的后续发展。"
    },
    {
      "type": "paragraph",
      "text": "尽管外界对关税谈判存在各种意见和嘲讽，但美国 7 月份收入确实达到创纪录的 1500 亿美元，前一个月也实现了 270 亿美元的盈余，大幅扭转了一年前 710 亿美元的赤字。此外，随著美国例外论叙事回归，市场对美国资产的需求自 5 月以来大幅反弹，任何资本外流的担忧都已烟消云散。"
    },
    {
      "type": "paragraph",
      "text": "美元亦顺势反弹，美元指数从近期低点回升超过 3%，黄金等避险资产则开始转弱。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_ede3812c7482"
      },
      "title": "随著关税收入增加，美国财政收支在近几个月大幅改善",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0008",
      "group_seq": 1,
      "group_len": 2,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_aaea9d097d0b"
      },
      "title": null,
      "credit": "ABC News, CNBC",
      "credit_tokens": [
        "ABC News",
        "CNBC"
      ],
      "group_id": "grp_0008",
      "group_seq": 2,
      "group_len": 2,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_231d13bda64a"
      },
      "title": "资本大规模回流美国市场，美元大幅反弹",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0009",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_f061deb8628d"
      },
      "title": null,
      "credit": "Spectra Markets",
      "credit_tokens": [
        "Spectra Markets"
      ],
      "group_id": "grp_0009",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "股市方面，财报季迄今表现不俗，Visa、Mastercard 和 Amex 均报告了支付量和消费动能的稳健增长，而银行的财报也大致符合预期。科技板块方面，消费者在商品和运输领域持续展现韧性，Meta 和 Microsoft 盈利表现出色，但最终被 Amazon 和 Coinbase 令人失望的财报所拖累。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_ac89c7f55c68"
      },
      "title": "疲乏的股市最终选择关注 Amazon/Coinbase 不如预期的业绩，而非 Meta 和 Microsoft 的强劲表现",
      "credit": "Spectra Markets",
      "credit_tokens": [
        "Spectra Markets"
      ],
      "group_id": "grp_0010",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_2b420a8a286d"
      },
      "title": "股市中散户投机情绪仍然非常高涨",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0011",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "最后，在加密货币方面，Coinbase 营收年增 3.3% 至 15 亿美元，但未达分析师预期，且低于 2025 年第一季度的 20 亿美元。净利润受到加密货币和 Circle 持仓未实现收益的提振，不过全球和美国现货交易量在第二季度整体偏淡。"
    },
    {
      "type": "paragraph",
      "text": "Coinbase 股价已自 7 月高点回落 25%，随著整体市场情绪走弱，BTC 价格也下跌至 11.2 万美元，上周五有超过 10 亿美元的多头期货遭到清算，是 5 月以来最惨烈的一次。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_8b986c28105e"
      },
      "title": "Coinbase 股价自 7 月高点回落 25%，拖累整体加密货币市场情绪走弱",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0012",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_5b0997e0456d"
      },
      "title": null,
      "credit": "Bloomberg, Messari",
      "credit_tokens": [
        "Bloomberg",
        "Messari"
      ],
      "group_id": "grp_0012",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_180933dec0c2"
      },
      "title": "BTC 多头期货清算超过 10 亿美元，结束了艰难的一周",
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0013",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "不出所料，BTC 与 ETH 上周均出现显著资金流出，BTC 在周四/周五出现 10 亿美元的流出，为年内单日最差表现之一，而 ETH 也结束了近一个月的连续净流入，在上周五流出 1.52 亿美元。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_c95dc26a9e58"
      },
      "title": "由于整体市场风险情绪降温，ETF 在上周五出现显著的资金流出",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0014",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_5e4e9c09229a"
      },
      "title": null,
      "credit": "Farside Investors",
      "credit_tokens": [
        "Farside Investors"
      ],
      "group_id": "grp_0014",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "整体而言，鉴于资金外流的速度和规模，市场表现其实已较预期稳定，而这也与 BTC 与 Altcoins 的市场深度明显提升有关。随著机构资金与专业投资者加入，次级市场流动性已有改善，避免了 ETF 推出前那种剧烈抛售的情况。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_3bfc2fb1da76"
      },
      "title": "次级市场流动性的显著改善，是机构化进程的一个重要指标",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0015",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_b88b3366afae"
      },
      "title": null,
      "credit": "Kaiko",
      "credit_tokens": [
        "Kaiko"
      ],
      "group_id": "grp_0015",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "展望未来，市场目前处于一个微妙的关口，预期多空双方将陷入拉锯，短期内尚难分出胜负。多头阵营认为市场对非农就业数据过度反应，而空头则会指出，鉴于过去三个月的过热行情，这将是市场转向的初步信号。持续不断的关税消息与 Trump 日益激进的言论，势必进一步加剧市场杂讯，而随著夏季进入后段，整体交易活动减少，市场波动可能会被进一步放大。"
    },
    {
      "type": "paragraph",
      "text": "我们预期短期内不会出现明确的方向性突破，本月价格走势也将较 7 月更为震荡。第四季度将十分关键，届时美联储会全面恢复运作，而关税与通胀的叠加效应也将开始对实体经济产生影响。在此背景下，我们认为现在是适度降低风险敞口的良机，以迎接忙碌的 9 月和年底。祝各位操作顺利，交易愉快！"
    }
  ],
  "assets": [
    {
      "asset_id": "img_74740ea292f9",
      "filename": "250804_negative_revisions/img_74740ea292f9.png",
      "sha256": "74740ea292f9440f456879cb90dfd05914c8de6d1f1a0a91bd36ef320ed12446"
    },
    {
      "asset_id": "img_ac79747eaa30",
      "filename": "250804_negative_revisions/img_ac79747eaa30.png",
      "sha256": "ac79747eaa309ac371fc7723d7416868c878574bdf4d19c5b61fc3d4cb31f56f"
    },
    {
      "asset_id": "img_8ec9cb9ae6e9",
      "filename": "250804_negative_revisions/img_8ec9cb9ae6e9.png",
      "sha256": "8ec9cb9ae6e91e3c313ff9958dec99773ba560c454f2d7c120b85cadfdaa2450"
    },
    {
      "asset_id": "img_03a293910220",
      "filename": "250804_negative_revisions/img_03a293910220.png",
      "sha256": "03a293910220e17c77c6accc06d03b7d1533596bdf140a80d012b3f7cbe8eaca"
    },
    {
      "asset_id": "img_d4ca6e3b06c4",
      "filename": "250804_negative_revisions/img_d4ca6e3b06c4.png",
      "sha256": "d4ca6e3b06c4228faa0b9195c7702cbf8a0b0dfeba21fd7002a051472ce7bf35"
    },
    {
      "asset_id": "img_b5faf10ceb72",
      "filename": "250804_negative_revisions/img_b5faf10ceb72.png",
      "sha256": "b5faf10ceb72753040fe344bbb9dc371aa6c0f894abca9a6659182ac1b2ccb67"
    },
    {
      "asset_id": "img_b6a9fd5b0797",
      "filename": "250804_negative_revisions/img_b6a9fd5b0797.png",
      "sha256": "b6a9fd5b079764e944d9fdda8acb1a248d938f322bdf2eff9c9b8274879ba816"
    },
    {
      "asset_id": "img_916b04850d01",
      "filename": "250804_negative_revisions/img_916b04850d01.png",
      "sha256": "916b04850d0150f3907b8fe24c934077eb17fab69ff0690618dbfb84dc2c8fd6"
    },
    {
      "asset_id": "img_f8dc418031b4",
      "filename": "250804_negative_revisions/img_f8dc418031b4.png",
      "sha256": "f8dc418031b4e6264a99237c3671ea1867637a60fdc7549ebe2c9e18d99bea0f"
    },
    {
      "asset_id": "img_308defa20ceb",
      "filename": "250804_negative_revisions/img_308defa20ceb.png",
      "sha256": "308defa20ceb688b28ecc2a2b5775f722a1de11562831983eb70be6dd8cb540d"
    },
    {
      "asset_id": "img_9531c10ca8b1",
      "filename": "250804_negative_revisions/img_9531c10ca8b1.png",
      "sha256": "9531c10ca8b16802580fe18a956f7f77ec8bbc8233b2b775b4744cddb3ea47de"
    },
    {
      "asset_id": "img_1e4a81f54c2d",
      "filename": "250804_negative_revisions/img_1e4a81f54c2d.png",
      "sha256": "1e4a81f54c2dcf9f9518fba789e4c14a4d139cee7c3b3a1704dd271ba3a6de20"
    },
    {
      "asset_id": "img_ede3812c7482",
      "filename": "250804_negative_revisions/img_ede3812c7482.png",
      "sha256": "ede3812c7482f6bf3b18c9385bbc4560913beffdce0531758bb57cdfe9987166"
    },
    {
      "asset_id": "img_aaea9d097d0b",
      "filename": "250804_negative_revisions/img_aaea9d097d0b.png",
      "sha256": "aaea9d097d0b0b61fb96d1fbadec7a7f3520a7719d815a9a92b711a433e271b4"
    },
    {
      "asset_id": "img_231d13bda64a",
      "filename": "250804_negative_revisions/img_231d13bda64a.png",
      "sha256": "231d13bda64a309e07a429c5c4c6b6a5f949fcabf6c5179bb5c99a28089da27f"
    },
    {
      "asset_id": "img_f061deb8628d",
      "filename": "250804_negative_revisions/img_f061deb8628d.png",
      "sha256": "f061deb8628d7c6e7a011d7b1f855b160f215c9b25a9b04d1c400d79c39db076"
    },
    {
      "asset_id": "img_ac89c7f55c68",
      "filename": "250804_negative_revisions/img_ac89c7f55c68.png",
      "sha256": "ac89c7f55c68240106ce3b71a12c8ff0d28dafcd78c7dba1353957f6b233f0d8"
    },
    {
      "asset_id": "img_2b420a8a286d",
      "filename": "250804_negative_revisions/img_2b420a8a286d.jpeg",
      "sha256": "2b420a8a286d20cf30ab72d08966a3cbc02ccbef4b8e593c22c2224e9b54e8c1"
    },
    {
      "asset_id": "img_8b986c28105e",
      "filename": "250804_negative_revisions/img_8b986c28105e.png",
      "sha256": "8b986c28105eeefbd78bd2badbdb2d533fc5de446a2be36b2012d2a66f130e4e"
    },
    {
      "asset_id": "img_5b0997e0456d",
      "filename": "250804_negative_revisions/img_5b0997e0456d.png",
      "sha256": "5b0997e0456d7ca46b3c5253da1579716fa508d49b6e7033e3e5fa4c1015fbba"
    },
    {
      "asset_id": "img_180933dec0c2",
      "filename": "250804_negative_revisions/img_180933dec0c2.png",
      "sha256": "180933dec0c2dc4b60aa56d4f494f94e45b6d407abad9bdb46843b351d865730"
    },
    {
      "asset_id": "img_c95dc26a9e58",
      "filename": "250804_negative_revisions/img_c95dc26a9e58.png",
      "sha256": "c95dc26a9e5848f8bd58e4dab4f37622c394394bba4c6765125f8166bc83a60b"
    },
    {
      "asset_id": "img_5e4e9c09229a",
      "filename": "250804_negative_revisions/img_5e4e9c09229a.png",
      "sha256": "5e4e9c09229a68f2712445e10ccf0098e22663aa13c45d716f0197b5bcf75ccf"
    },
    {
      "asset_id": "img_3bfc2fb1da76",
      "filename": "250804_negative_revisions/img_3bfc2fb1da76.jpeg",
      "sha256": "3bfc2fb1da763cb2e141ac8535591215c78f3dfa017c96860599531580c57159"
    },
    {
      "asset_id": "img_b88b3366afae",
      "filename": "250804_negative_revisions/img_b88b3366afae.png",
      "sha256": "b88b3366afae44e4387ffe2e2740495c7eb3cfbbe61cbf54cf8135756ec0beab"
    }
  ],
  "report": {
    "warnings": [],
    "debug": []
  }
}
</file>

<file path="docx2json/250818_summer_break_content.json">
{
  "doc": {
    "title": "Summer Break",
    "date": "2025-08-18",
    "locale": "zh-CN",
    "version": "v1",
    "source_file": "250818 - Summer Break.docx"
  },
  "blocks": [
    {
      "type": "figure",
      "image": {
        "asset_id": "img_76f7bfb095b6"
      },
      "title": null,
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0001",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_dbbbe31f43d5"
      },
      "title": "当前市场情绪",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0002",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_0b2aa77c3510"
      },
      "title": null,
      "credit": "FT, Reddit",
      "credit_tokens": [
        "FT",
        "Reddit"
      ],
      "group_id": "grp_0002",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "paragraph",
      "text": "我们结束了一个震荡但最终收于区间内的一周，最新的通胀指标走势分化：在之前一周温和的CPI（消费者价格指数）之后，7月PPI（生产者价格指数）意外大幅上涨（环比+0.9% vs 预期+0.2%，主要由专业服务价格跳涨推动）。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_167b6884e197"
      },
      "title": "通胀指标难以软化至2%目标以下",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0003",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "雪上加霜的是，密西根大学通胀预期资料同样高企，1年期和5-10年期价格预期均显著高于预期（1年期：4.4% vs 4.9%预期；5-10年期：3.4% vs 3.9%预期）。尽管通胀资料令人失望，财政部长贝森特仍继续其鸽派论调，声称根据他们的经济“模型”，中性利率应低150个基点。这无疑在一定程度上受到了特朗普总统持续推行的维持低利率政策议程的影响。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_09aa1fc6253d"
      },
      "title": "密西根大学通胀预期：短期与长期指标均意外上行",
      "credit": "Bloomberg",
      "credit_tokens": [
        "Bloomberg"
      ],
      "group_id": "grp_0004",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_b2b73f4d8b19"
      },
      "title": "财长贝森特近期宣称“中性”利率应低约150个基点",
      "credit": "Forbes, CNBC",
      "credit_tokens": [
        "Forbes",
        "CNBC"
      ],
      "group_id": "grp_0005",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "尽管官方态度乐观，市场自然有其判断。更为火热的通胀资料表明，关税成本可能正以快于预期的速度传导至消费者，这导致美元/美债收益率反弹，金价下跌。对于9月会议降息50个基点的任何希望迅速破灭，截至周五收盘，市场仅定价了约90%的一次降息（25个基点）可能性。不过，市场仍预期年底前会有略多于2次降息。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_88ea3fc64567"
      },
      "title": "强劲PPI后，市场仅定价9月会议降息一次（25基点）的可能性低于90%",
      "credit": "Citi",
      "credit_tokens": [
        "Citi"
      ],
      "group_id": "grp_0006",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "过去一周，加密货币价格停滞不前，宏观因素增加了短期阻力。财长贝森特宣布美国政府持有的BTC价值接近150-200亿美元，而非市场此前希望的230亿美元以上，这令市场失望。更重要的是，他进一步让观察人士失望地表示，政府不会为其“战略比特币储备”购买更多BTC，也不预计政府会对其黄金储备（按每盎司42.22美元计价）进行重估或出售以换取比特币。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_baecaaa2d010"
      },
      "title": "过去一周政府的SBR相关头条令市场失望",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0007",
      "group_seq": 1,
      "group_len": 2,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_78ec0ebdafd6"
      },
      "title": null,
      "credit": "Yahoo Finance, Arkham",
      "credit_tokens": [
        "Yahoo Finance",
        "Arkham"
      ],
      "group_id": "grp_0007",
      "group_seq": 2,
      "group_len": 2,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "另一方面，ETF资金流入依然非常强劲。彭博报导称，BTC和ETH ETF上周录得自推出以来的最大单周资金流入，使这对组合跻身所有股权类ETF的前五名。这一动向主要由ETF资金流入激增推动，单周流入额达170亿美元，打破了之前的记录。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_be731c0a03dc"
      },
      "title": "BTC & ETH ETF 上周资金流入创纪录",
      "credit": "Bloomberg, X",
      "credit_tokens": [
        "Bloomberg",
        "X"
      ],
      "group_id": "grp_0008",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_ec6b56b9b1ef"
      },
      "title": "主要由ETH流入激增170亿美元推动",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0009",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "展望未来，焦点将转向本周晚些时候的杰克逊霍尔（Jackson Hole）会议。美联储主席鲍威尔的讲话将被宏观观察人士仔细审视，以研判今年余下时间的政策基调。然而，鉴于当前的通胀背景，我们不预期会有太多新的鸽派惊喜。除非9月非农就业报告（NFP）非常负面，否则不太可能推动市场重新定价降息50个基点的可能性。"
    },
    {
      "type": "paragraph",
      "text": "在情绪面，我们确实要提醒当前水准感觉有些过度狂热。美国消费者对股价的乐观程度与其自身收入前景之间的分歧已达到历史上前所未有的水准。同时，随著我们进入历史上波动性较大的9-10月，基金经理的现金持有水准已回落至周期低点（表明投资已接近满仓）。"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_c103eaa00355"
      },
      "title": "美国消费者对股价的看涨程度 vs 自身收入前景达历史之最",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0010",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_833164888c66"
      },
      "title": null,
      "credit": "DB",
      "credit_tokens": [
        "DB"
      ],
      "group_id": "grp_0010",
      "group_seq": 2,
      "group_len": 2,
      "layout": "row"
    },
    {
      "type": "figure",
      "image": {
        "asset_id": "img_95a9764054d1"
      },
      "title": "基金经理现金水准降至周期低点",
      "credit": null,
      "credit_tokens": null,
      "group_id": "grp_0011",
      "group_seq": 1,
      "group_len": 1,
      "layout": "column"
    },
    {
      "type": "paragraph",
      "text": "祝好运，交易顺利！"
    }
  ],
  "assets": [
    {
      "asset_id": "img_76f7bfb095b6",
      "filename": "250818_summer_break/img_76f7bfb095b6.png",
      "sha256": "76f7bfb095b6f67f8cc5c56857be9ef285cf4065a3b0a1172b44c547cf82bde0"
    },
    {
      "asset_id": "img_dbbbe31f43d5",
      "filename": "250818_summer_break/img_dbbbe31f43d5.png",
      "sha256": "dbbbe31f43d502e7d9214ec3650ce5c2ae0792232f482049ac0ee5e0d54a8a64"
    },
    {
      "asset_id": "img_0b2aa77c3510",
      "filename": "250818_summer_break/img_0b2aa77c3510.png",
      "sha256": "0b2aa77c351047fbdc45868ef16a784195eeac7707033d3fe139e35ad8d4c8c8"
    },
    {
      "asset_id": "img_167b6884e197",
      "filename": "250818_summer_break/img_167b6884e197.png",
      "sha256": "167b6884e1978256522bf2847b18b0549c5f94d03b4269f8a5dee6c271da0ace"
    },
    {
      "asset_id": "img_09aa1fc6253d",
      "filename": "250818_summer_break/img_09aa1fc6253d.png",
      "sha256": "09aa1fc6253db6aac7009ded4173d5d4229bfc9c0e53d5a2210739e8f31165cf"
    },
    {
      "asset_id": "img_b2b73f4d8b19",
      "filename": "250818_summer_break/img_b2b73f4d8b19.png",
      "sha256": "b2b73f4d8b1980ff4cbecee888faeab7fa126d40e6098f73441e95c9c8e0a25b"
    },
    {
      "asset_id": "img_88ea3fc64567",
      "filename": "250818_summer_break/img_88ea3fc64567.png",
      "sha256": "88ea3fc645678f65b3f9aeea2fdbe49377c6a27a85b696ea55364485a63c9d47"
    },
    {
      "asset_id": "img_baecaaa2d010",
      "filename": "250818_summer_break/img_baecaaa2d010.png",
      "sha256": "baecaaa2d01090f601336d856cfc56917d388969355cdc6c126278ac4fe0c2ea"
    },
    {
      "asset_id": "img_78ec0ebdafd6",
      "filename": "250818_summer_break/img_78ec0ebdafd6.png",
      "sha256": "78ec0ebdafd68b82b41deec69b9ca8e4fa1a593b5c378a45dec8dd51e13c5e42"
    },
    {
      "asset_id": "img_be731c0a03dc",
      "filename": "250818_summer_break/img_be731c0a03dc.png",
      "sha256": "be731c0a03dc6ebd648334d1862714dbbb7a376cf8137f7c177e10609b984f77"
    },
    {
      "asset_id": "img_ec6b56b9b1ef",
      "filename": "250818_summer_break/img_ec6b56b9b1ef.png",
      "sha256": "ec6b56b9b1efdf0a4c5d39a93db03f61ae33f7e1ac4355677e5907112c9b4725"
    },
    {
      "asset_id": "img_c103eaa00355",
      "filename": "250818_summer_break/img_c103eaa00355.jpeg",
      "sha256": "c103eaa00355aacccfecde07487ab0562effecd01e5014204cde8652c62e36f1"
    },
    {
      "asset_id": "img_833164888c66",
      "filename": "250818_summer_break/img_833164888c66.png",
      "sha256": "833164888c66b6436c3d5a34c160066e89f59df450ac99bb0fa6c25767f98726"
    },
    {
      "asset_id": "img_95a9764054d1",
      "filename": "250818_summer_break/img_95a9764054d1.png",
      "sha256": "95a9764054d15a8bb8f27151941952c2b38a259078baad3555117cbf92e1a562"
    }
  ],
  "report": {
    "warnings": [],
    "debug": []
  }
}
</file>

<file path="docx2json/README.md">
# DOCX to JSON Converter

一个智能的DOCX文档转JSON工具，专门用于提取和组织文档中的图像、文本内容，并实现高级的图像分组功能。

## 特性

### 🎯 核心功能
- **智能图像分组**：自动识别并行（row）和垂直相邻（column）的图像组合
- **真实资源提取**：从DOCX文件中提取真实图像并生成SHA256哈希ID
- **完整内容提取**：支持段落文本和表格内容的完整提取
- **标题与来源归属**：智能分配图像标题和来源信息
- **文档顺序保持**：按原文档顺序输出所有内容块
- **繁体转简体**：支持繁体中文自动转换为简体中文（保护英文、数字、URL等）
- **显式标记系统**：支持"标题"/"Title"和"来源"/"Source"显式标记，提高检测准确性
- **统一来源格式**：所有来源信息统一添加"Source: "前缀

### 🔍 显式标记系统 (新特性)

项目现已支持显式标记系统，大幅提升标题和来源检测的准确性：

#### 显式标记格式
- **标题标记**：段落开头包含"标题"或"Title"
- **来源标记**：段落开头包含"来源"或"Source"

#### 检测优先级
1. **显式标记优先**：优先检测带有标记的段落
2. **启发式fallback**：如无显式标记，使用优化后的启发式算法
3. **智能内容提取**：自动去除标记前缀，提取真实内容

#### 使用建议
在DOCX文档中直接添加标记，例如：
```
标题：市场情绪分析图表
来源：Bloomberg, Financial Times
```

### 🧠 二阶段分组算法

#### Phase 1: 同段落分组 (Row Layout)
- 同一段落内的多张图像自动组合为`layout='row'`
- 典型场景：并排对比图表

#### Phase 2: 相邻段落分组 (Column Layout)  
- 连续段落中的图像根据间隔和文本量进行分组
- 仅当间隔≤`max_gap_paras`且无大量文本(>max_title_len chars)时分组
- 特殊规则：若组合宽度≤`page_width_ratio` * 页面宽度，则使用`layout='row'`

#### 标题与来源归属（增强版）
- **显式标记优先**：检测"标题"/"Title"和"来源"/"Source"标记的段落
- **智能启发式fallback**：标题搜索图片前方文本(≤max_title_len chars)，来源搜索图片后方文本
- **统一格式**：所有来源统一添加"Source: "前缀

## 安装

### 环境要求
- Python 3.7+
- python-docx 库
- opencc-python-reimplemented 库（繁体转简体功能）

### 安装步骤
```bash
# 克隆项目
git clone <repository-url>
cd docx2json

# 创建虚拟环境
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 安装依赖
pip install python-docx opencc-python-reimplemented
```

## 使用方法

### 基本用法
```bash
python to_ncj.py "document.docx"
```

### 完整参数
```bash
python to_ncj.py "input.docx" [options]
  --out content.json              # 输出JSON文件 (默认: content.json)
  --assets-dir assets/media       # 图像资源目录 (默认: assets/media)
  --max_title_len 60              # 标题检测最大字符数 (默认: 60)
  --max_gap_paras 1               # 分组最大段落间隔 (默认: 1) 
  --page_width_ratio 0.95         # 行布局检测宽度比例 (默认: 0.95)
  --traditional-to-simplified     # 启用繁体转简体 (保护英文/数字/URL)
  --no-explicit-markers           # 禁用显式标记检测，仅使用启发式算法
  --debug                         # 在输出中包含分组推理信息
```

### 示例
```bash
# 基本转换
python to_ncj.py "报告.docx" --out report.json

# 带繁体转简体的转换
python to_ncj.py "繁體文檔.docx" --traditional-to-simplified --assets-dir assets/

# 带调试信息的转换
python to_ncj.py "分析.docx" --debug --assets-dir images/

# 仅使用启发式算法（禁用显式标记）
python to_ncj.py "文档.docx" --no-explicit-markers --max_gap_paras 2
```

## 输出格式

### JSON结构
```json
{
  "doc": {
    "title": "文档标题",
    "date": "2025-08-18", 
    "locale": "zh-CN",
    "version": "v1",
    "source_file": "original.docx"
  },
  "blocks": [
    {
      "type": "paragraph",
      "text": "段落文本内容"
    },
    {
      "type": "figure",
      "image": {"asset_id": "img_76f7bfb095b6"},
      "title": "图表标题",
      "credit": "数据来源",
      "group_id": "grp_0001",
      "group_seq": 1,
      "group_len": 2,
      "layout": "row"
    }
  ],
  "assets": [
    {
      "asset_id": "img_76f7bfb095b6",
      "filename": "assets/img_76f7bfb095b6.png",
      "sha256": "76f7bfb095b6f67f8cc5c56857be9ef285cf4065..."
    }
  ],
  "report": {
    "warnings": [],
    "debug": ["grp_0001: row by same-paragraph(para=4, 2 images)..."]
  }
}
```

### 字段说明
- **group_id**: 唯一分组标识符
- **group_seq**: 在组内的序号(1开始)  
- **group_len**: 组内图像总数
- **layout**: 布局类型(`"row"`并行 | `"column"`垂直)
- **asset_id**: 基于SHA256的真实图像ID

## 技术架构

### 核心模块
1. **图像提取** (`extract_figures_from_docx`): 从段落和表格中提取图像
2. **资源处理** (`extract_and_hash_images`): ZIP解压和SHA256哈希计算  
3. **智能分组** (`group_figures`): 二阶段分组算法实现
4. **属性分配** (`assign_titles_and_credits`): 标题和来源的智能归属

### 设计特点
- **分离式block设计**：保持文档线性结构，便于顺序渲染
- **可配置参数**：灵活调整分组行为以适应不同文档类型
- **真实资源管理**：避免placeholder，确保资源完整性
- **调试友好**：提供详细的分组推理信息

## 开发

### 项目结构
```
docx2json/
├── to_ncj.py              # 主转换脚本
├── README.md              # 项目文档
├── assets/                # 提取的图像资源
│   ├── 250818_summer_break/
│   └── 250804_negative_revisions/
├── *.docx                 # 测试文档
├── *.json                 # 转换结果
└── venv/                  # 虚拟环境
```

### 测试
项目包含两个测试用例：
- `250818 - Summer Break.docx`: 14图像，11分组，3个多图分组
- `250804 - Negative Revisions.docx`: 25图像，15分组，10个多图分组

### 扩展
算法支持以下扩展：
- 新的布局类型检测
- 自定义标题/来源匹配模式  
- 多语言文档支持
- 更复杂的图像排列识别

## 常见问题

### Q: 为什么有些图像没有标题？
A: 标题分配基于附近文本的长度和位置。建议使用显式标记（"标题："或"Title:"）来提高检测准确性。

### Q: 如何调整分组敏感度？
A: 使用`--max_gap_paras`调整段落间隔容忍度，使用`--max_title_len`调整标题检测长度。

### Q: 输出的图像文件在哪里？
A: 图像保存在`--assets-dir`指定的目录中，文件名使用SHA256哈希确保唯一性。每个文档的图像将保存在以源文件名命名的子目录中。

### Q: 繁体转简体功能是否会影响英文内容？
A: 不会。该功能使用智能保护机制，仅转换中文字符，保护英文文本、数字、URL和标点符号不被修改。

### Q: 显式标记系统是否兼容旧文档？
A: 完全兼容。如果文档中没有显式标记，系统会自动使用优化后的启发式算法作为fallback。

### Q: 所有来源信息都会添加"Source: "前缀吗？
A: 是的。无论原文档中来源格式如何，输出时都会统一添加"Source: "前缀，确保格式一致性。

## License

MIT License - 详见 LICENSE 文件

## 贡献

欢迎提交 Issues 和 Pull Requests！

---

*该项目专为需要精确图像分组和内容提取的文档处理场景设计*
</file>

<file path="docx2json/to_ncj.py">
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DOCX to Normalized Content JSON (NCJ) converter with advanced figure grouping.

Direct python-docx based implementation for accurate figure grouping and 
title/credit attribution.

Usage:
  python to_ncj.py "input.docx" --out content.json [options]
"""
import sys, json, re, os, hashlib, zipfile, shutil
from typing import List, Dict, Any, Tuple, Optional, NamedTuple
from dataclasses import dataclass
from docx import Document
from docx.shared import Emu
import opencc

@dataclass
class FigureCandidate:
    """Represents a potential figure found in the document"""
    para_idx: int
    run_idx: int  
    width_emu: Optional[int] = None
    height_emu: Optional[int] = None
    r_id: Optional[str] = None  # rId from OOXML relationships
    media_path: Optional[str] = None  # path in ZIP: word/media/imageN.ext
    asset_id: Optional[str] = None  # SHA256-based asset ID
    filename: Optional[str] = None  # extracted file path

@dataclass
class GroupCandidate:
    """Represents a potential group of figures"""
    figures: List[FigureCandidate]
    layout: str  # 'row' or 'column'
    title: Optional[str] = None
    credit: Optional[str] = None
    credit_tokens: Optional[List[str]] = None
    reason: Optional[str] = None  # Debug info

# --------- Configuration and Helpers ----------
class Config:
    def __init__(self):
        self.max_title_len = 60
        self.max_gap_paras = 1
        self.page_width_ratio = 0.95
        self.debug = False
        self.assets_dir = "assets/media"
        self.traditional_to_simplified = False  # Enable traditional to simplified conversion
        self.use_explicit_markers = True  # Use explicit title/source markers for better accuracy

def safe_traditional_to_simplified(text: str, converter) -> str:
    """安全的繁简转换，保护特定模式"""
    if not text or not text.strip():
        return text
    
    # 保护模式：先替换为占位符
    protected_replacements = []
    temp_text = text
    
    # 保护拉丁字符（包括单词、缩写、网站等）
    latin_pattern = r'\b[a-zA-Z][a-zA-Z0-9\-\.]*[a-zA-Z0-9]\b|\b[a-zA-Z]\b'
    latin_matches = re.findall(latin_pattern, temp_text)
    for i, match in enumerate(latin_matches):
        placeholder = f'___LATIN_{i:03d}___'
        protected_replacements.append((placeholder, match))
        temp_text = temp_text.replace(match, placeholder, 1)
    
    # 保护数字和百分比
    number_pattern = r'\d+\.?\d*%?'
    number_matches = re.findall(number_pattern, temp_text)
    for i, match in enumerate(number_matches):
        placeholder = f'___NUMBER_{i:03d}___'
        protected_replacements.append((placeholder, match))
        temp_text = temp_text.replace(match, placeholder, 1)
    
    # 保护URL和邮箱
    url_pattern = r'https?://[^\s]+|\b[\w\.-]+@[\w\.-]+\.[a-zA-Z]{2,}\b'
    url_matches = re.findall(url_pattern, temp_text)
    for i, match in enumerate(url_matches):
        placeholder = f'___URL_{i:03d}___'
        protected_replacements.append((placeholder, match))
        temp_text = temp_text.replace(match, placeholder, 1)
    
    # 执行繁简转换
    try:
        simplified_text = converter.convert(temp_text)
    except Exception:
        # 转换失败时返回原文
        simplified_text = temp_text
    
    # 恢复保护的内容
    for placeholder, original in reversed(protected_replacements):
        simplified_text = simplified_text.replace(placeholder, original, 1)
    
    return simplified_text

def sha256_of_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, 'rb') as f:
        for chunk in iter(lambda: f.read(65536), b''):
            h.update(chunk)
    return h.hexdigest()

def normalize_credits(text: str) -> Tuple[str, List[str]]:
    """
    Normalize figure credits to raw credits (no leading label).
    - Strip leading prefix using regex: ^(?:source|来源|來源)\s*[:：]\s* (case-insensitive)
    - Split by separators [、，,;；／/|], trim tokens, drop empties, de-duplicate preserving order
    - Return (joined_str, tokens) where joined_str uses ", " as separator
    """
    if not text:
        return "", []
    # Strip known prefixes ("Source:" / "来源：" / "來源：")
    stripped = re.sub(r'^\s*(?:source|来源|來源)\s*[:：]\s*', '', text, flags=re.I)
    # Split by common separators and clean tokens
    raw_parts = re.split(r'[、，,;；／/|]+', stripped)
    seen = set()
    tokens: List[str] = []
    for part in raw_parts:
        tok = part.strip().strip(' .。；;，,')
        if tok and tok not in seen:
            seen.add(tok)
            tokens.append(tok)
    return (", ".join(tokens), tokens)

def normalize_credit(text: str) -> str:
    """Backward-compatible wrapper returning only the normalized credit string"""
    s, _ = normalize_credits(text)
    return s

def is_short_title(text: str, max_len: int) -> bool:
    """Check if text could be a figure title"""
    if not text or len(text.strip()) == 0:
        return False
    if len(text.strip()) > max_len:
        return False
    # Exclude obvious credit lines
    if re.match(r'^\s*(来源|來源|Source)\s*[：:]', text, re.I):
        return False
    return True

def is_credit_line(text: str) -> bool:
    """Check if text is a credit/source line (legacy method)"""
    return bool(re.match(r'^\s*(来源|來源|Source)\s*[：:]', text, re.I))

def is_potential_credit_line(text: str, max_len: int = 60) -> bool:
    """更严格但增强的来源检测 - 仅使用传统严格模式"""
    if not text or len(text.strip()) == 0:
        return False
    if len(text.strip()) > max_len:  # 来源信息通常较短
        return False
    
    # 传统严格模式：以"来源:/Source:"开头
    if re.match(r'^\s*(来源|來源|Source)\s*[：:]', text, re.I):
        return True
    
    return False

def is_title_paragraph(text: str) -> bool:
    """检测是否为明确标记的标题段落"""
    if not text:
        return False
    text_cleaned = text.strip().lower()
    return (text_cleaned.startswith('标题') or 
            text_cleaned.startswith('title'))

def is_source_paragraph(text: str) -> bool:
    """检测是否为明确标记的来源段落"""  
    if not text:
        return False
    text_cleaned = text.strip().lower()
    return (text_cleaned.startswith('来源') or 
            text_cleaned.startswith('來源') or
            text_cleaned.startswith('source'))

def extract_title_content(text: str) -> str:
    """提取标题内容（去除前缀标记）"""
    if not text:
        return ""
    text = text.strip()
    
    # 定义所有可能的标题前缀（按长度排序，长的优先）
    prefixes = [
        '标题：', '标题:', 'Title：', 'Title:', 
        '标题 ', 'Title ', '标题', 'Title'
    ]
    
    for prefix in prefixes:
        if text.lower().startswith(prefix.lower()):
            return text[len(prefix):].strip()
    
    return text

def extract_source_content(text: str) -> str:
    """提取来源内容（去除前缀标记；返回原始credits，不加任何前缀）"""
    s, _ = normalize_credits(text)
    return s

DOC_TITLE_RE = re.compile(r'^\s*(\d{6})\s*-\s*(.+)')
def parse_date_from_yyMMdd(yyMMdd: str) -> Optional[str]:
    try:
        yy = int(yyMMdd[0:2]); mm = int(yyMMdd[2:4]); dd = int(yyMMdd[4:6])
        yyyy = 2000 + yy
        return f"{yyyy:04d}-{mm:02d}-{dd:02d}"
    except Exception:
        return None

# --------- Phase 1: Extract Figure Candidates ----------
def extract_figures_from_docx(doc: Document, docx_path: str, converter=None) -> Tuple[List[FigureCandidate], List[str], int]:
    """Extract figure candidates and all text content (paragraphs + tables) with real rId mapping"""
    figures = []
    para_texts = []
    page_width_emu = doc.sections[0].page_width.emu if doc.sections else 7559675
    
    # Build rId to media path mapping from document relations
    r_id_to_media = {}
    for r_id, rel in doc.part._rels.items():
        if rel.reltype.endswith('/image'):  # Image relationship
            r_id_to_media[r_id] = rel.target_ref  # e.g., 'media/image1.png'
    
    # Extract all content in document order (paragraphs + tables)
    body = doc._element.body
    content_idx = 0
    paragraph_counter = 0
    
    for element in body:
        if element.tag.endswith('}p'):  # Paragraph
            # Find corresponding paragraph object
            if paragraph_counter < len(doc.paragraphs):
                para = doc.paragraphs[paragraph_counter]
                para_text = para.text.strip()
                if converter:
                    para_text = safe_traditional_to_simplified(para_text, converter)
                para_texts.append(para_text)
                
                # Find drawings in this paragraph
                drawings = para._element.xpath('.//w:drawing')
                for run_idx, drawing in enumerate(drawings):
                    # Extract dimensions if available
                    extents = drawing.xpath('.//wp:extent')
                    width_emu = height_emu = None
                    if extents:
                        extent = extents[0]
                        width_emu = int(extent.get('cx', 0))
                        height_emu = int(extent.get('cy', 0))
                    
                    # Extract rId from drawing XML
                    r_id = None
                    media_path = None
                    try:
                        xml_str = drawing.xml
                        r_embed_matches = re.findall(r'r:embed="(rId\d+)"', xml_str)
                        if r_embed_matches:
                            r_id = r_embed_matches[0]
                            media_path = r_id_to_media.get(r_id)
                    except Exception as e:
                        # Fallback: continue without rId
                        pass
                    
                    figures.append(FigureCandidate(
                        para_idx=content_idx,
                        run_idx=run_idx,
                        width_emu=width_emu,
                        height_emu=height_emu,
                        r_id=r_id,
                        media_path=media_path,
                        asset_id=None,  # Will be set after extraction
                        filename=None   # Will be set after extraction
                    ))
                paragraph_counter += 1
            else:
                # Empty paragraph
                para_texts.append("")
            content_idx += 1
                
        elif element.tag.endswith('}tbl'):  # Table
            # Extract table text content
            table_text = ""
            try:
                # Get text from table cells more accurately to avoid duplication
                cell_texts = []
                # Only get text from w:t (text) elements to avoid duplication
                for t_elem in element.xpath('.//w:t', namespaces={'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}):
                    if t_elem.text and t_elem.text.strip():
                        cell_texts.append(t_elem.text.strip())
                table_text = " ".join(cell_texts).strip()
            except Exception as e:
                # Fallback to simpler method if xpath fails
                try:
                    cell_texts = []
                    for cell in element.iter():
                        if cell.tag.endswith('}t') and cell.text and cell.text.strip():
                            cell_texts.append(cell.text.strip())
                    table_text = " ".join(cell_texts).strip()
                except:
                    table_text = ""
            
            # Convert traditional to simplified if converter provided
            if converter and table_text:
                table_text = safe_traditional_to_simplified(table_text, converter)
            
            # Add table text to para_texts
            para_texts.append(table_text)
            
            # Find drawings in this table
            table_drawings = element.xpath('.//w:drawing')
            for run_idx, drawing in enumerate(table_drawings):
                # Extract dimensions if available
                extents = drawing.xpath('.//wp:extent')
                width_emu = height_emu = None
                if extents:
                    extent = extents[0]
                    width_emu = int(extent.get('cx', 0))
                    height_emu = int(extent.get('cy', 0))
                
                # Extract rId from drawing XML
                r_id = None
                media_path = None
                try:
                    xml_str = drawing.xml
                    r_embed_matches = re.findall(r'r:embed="(rId\d+)"', xml_str)
                    if r_embed_matches:
                        r_id = r_embed_matches[0]
                        media_path = r_id_to_media.get(r_id)
                except Exception as e:
                    # Fallback: continue without rId
                    pass
                
                figures.append(FigureCandidate(
                    para_idx=content_idx,
                    run_idx=run_idx,
                    width_emu=width_emu,
                    height_emu=height_emu,
                    r_id=r_id,
                    media_path=media_path,
                    asset_id=None,  # Will be set after extraction
                    filename=None   # Will be set after extraction
                ))
            content_idx += 1
    
    return figures, para_texts, page_width_emu

# --------- Image Asset Extraction ----------
def extract_and_hash_images(figures: List[FigureCandidate], docx_path: str, assets_dir: str) -> Dict[str, Any]:
    """Extract images from DOCX and calculate real SHA256 hashes"""
    assets = {}
    
    # Ensure assets directory exists
    os.makedirs(assets_dir, exist_ok=True)
    # Build relative prefix for asset filenames (relative to 'assets' root if possible)
    try:
        assets_root_abs = os.path.abspath('assets')
        assets_dir_abs = os.path.abspath(assets_dir)
        rel_prefix = os.path.relpath(assets_dir_abs, assets_root_abs)
        if rel_prefix.startswith('..'):
            # Not under 'assets' root; fallback to basename
            rel_prefix = os.path.basename(assets_dir)
    except Exception:
        rel_prefix = os.path.basename(assets_dir)
    
    # Extract images from DOCX ZIP
    try:
        with zipfile.ZipFile(docx_path, 'r') as zip_file:
            for figure in figures:
                if not figure.media_path:
                    continue
                    
                # Full path in ZIP: word/media/imageN.ext
                zip_media_path = f"word/{figure.media_path}"
                
                if zip_media_path not in zip_file.namelist():
                    continue
                
                # Extract image data
                image_data = zip_file.read(zip_media_path)
                
                # Calculate real SHA256
                sha256_hash = hashlib.sha256(image_data).hexdigest()
                asset_id = f"img_{sha256_hash[:12]}"
                
                # Generate output filename (preserve extension)
                _, ext = os.path.splitext(figure.media_path)
                output_filename = f"{asset_id}{ext}"
                output_path = os.path.join(assets_dir, output_filename)
                
                # Write image to disk
                with open(output_path, 'wb') as f:
                    f.write(image_data)
                
                # Update figure with real asset info
                figure.asset_id = asset_id
                figure.filename = output_path
                
                # Store asset metadata
                if asset_id not in assets:
                    assets[asset_id] = {
                        "asset_id": asset_id,
                        "filename": os.path.join(rel_prefix, output_filename),
                        "sha256": sha256_hash
                    }
    
    except Exception as e:
        # Fallback: generate placeholder assets for figures without real extraction
        for i, figure in enumerate(figures):
            if not figure.asset_id:
                placeholder_id = f"img_placeholder_{i:03d}"
                figure.asset_id = placeholder_id
                if placeholder_id not in assets:
                    assets[placeholder_id] = {
                        "asset_id": placeholder_id,
                        "filename": f"assets/media/placeholder_{i:03d}.png",
                        "sha256": placeholder_id + "0" * (64 - len(placeholder_id))
                    }
    
    return assets

# --------- Phase 2: Group Figures ----------
def group_figures(figures: List[FigureCandidate], para_texts: List[str], 
                 page_width_emu: int, config: Config) -> List[GroupCandidate]:
    """Group figures using two-phase algorithm"""
    if not figures:
        return []
    
    groups = []
    used_figure_indices = set()
    
    # Phase 1: Same-paragraph grouping (row layout)
    figures_by_para = {}
    for i, fig in enumerate(figures):
        para_idx = fig.para_idx
        if para_idx not in figures_by_para:
            figures_by_para[para_idx] = []
        figures_by_para[para_idx].append((i, fig))
    
    for para_idx, para_figs in figures_by_para.items():
        if len(para_figs) >= 2:
            # Multiple figures in same paragraph -> row group
            group_figures = [fig for _, fig in para_figs]
            reason = f"row by same-paragraph(para={para_idx}, {len(group_figures)} images)"
            groups.append(GroupCandidate(
                figures=group_figures,
                layout='row',
                reason=reason
            ))
            used_figure_indices.update(i for i, _ in para_figs)
    
    # Phase 2: Adjacent-paragraph grouping (column layout)
    remaining_figures = [(i, fig) for i, fig in enumerate(figures) if i not in used_figure_indices]
    
    i = 0
    while i < len(remaining_figures):
        current_idx, current_fig = remaining_figures[i]
        group_figures = [current_fig]
        group_indices = [current_idx]
        reason_parts = [f"para={current_fig.para_idx}"]
        
        # Look ahead for adjacent figures
        j = i + 1
        while j < len(remaining_figures):
            next_idx, next_fig = remaining_figures[j]
            current_para = group_figures[-1].para_idx
            next_para = next_fig.para_idx
            
            # Check gap between paragraphs
            gap = next_para - current_para - 1
            if gap > config.max_gap_paras:
                break
            
            # Check if there's substantial text between images
            has_substantial_text = False
            for para_idx in range(current_para + 1, next_para):
                text = para_texts[para_idx]
                if text and len(text) > config.max_title_len and not is_credit_line(text):
                    has_substantial_text = True
                    break
            
            if has_substantial_text:
                break
            
            # Determine if this should be row or column layout
            layout = 'column'  # Default for adjacent paragraphs
            if (current_fig.width_emu and next_fig.width_emu and 
                (current_fig.width_emu + next_fig.width_emu) <= config.page_width_ratio * page_width_emu):
                layout = 'row'  # Could be side-by-side despite being in different paras
            
            group_figures.append(next_fig)
            group_indices.append(next_idx)
            reason_parts.append(f"para={next_fig.para_idx}")
            j += 1
        
        # Determine final layout for the group
        if len(group_figures) > 1:
            layout = 'row' if len(set(fig.para_idx for fig in group_figures)) == 1 else 'column'
            reason = f"{layout} by adjacent-paragraphs({', '.join(reason_parts)}, gap≤{config.max_gap_paras})"
        else:
            layout = 'column'  # Single figure
            reason = f"single figure(para={current_fig.para_idx})"
        
        groups.append(GroupCandidate(
            figures=group_figures,
            layout=layout,
            reason=reason
        ))
        
        used_figure_indices.update(group_indices)
        i = j if len(group_figures) > 1 else i + 1
    
    return groups

# --------- Phase 3: Assign Titles and Credits ----------
def assign_titles_and_credits(groups: List[GroupCandidate], para_texts: List[str], config: Config, doc_full_title: str = None, converter=None):
    """Assign titles and credits to groups"""
    
    for group in groups:
        if not group.figures:
            continue
            
        first_fig = group.figures[0]
        last_fig = group.figures[-1]
        
        title = None
        credit = None
        
        if config.use_explicit_markers:
            # New method: Look for explicit markers
            # Find title (look before first figure for "标题" or "Title")
            for offset in [-2, -1]:  # Check before figure
                check_idx = first_fig.para_idx + offset
                if 0 <= check_idx < len(para_texts):
                    text = para_texts[check_idx]
                    if text and is_title_paragraph(text):
                        title_content = extract_title_content(text)
                        if title_content and title_content != doc_full_title:
                            title = safe_traditional_to_simplified(title_content, converter) if converter else title_content
                            break
            
            # Find credit (look after last figure for "来源" or "Source")
            for offset in [1, 2]:  # Check after figure
                check_idx = last_fig.para_idx + offset
                if 0 <= check_idx < len(para_texts):
                    text = para_texts[check_idx]
                    if text and is_source_paragraph(text):
                        credit_str, credit_tokens = normalize_credits(text)
                        if credit_tokens:
                            if converter:
                                credit_tokens = [safe_traditional_to_simplified(t, converter) for t in credit_tokens]
                            credit = ", ".join(credit_tokens)
                            group.credit_tokens = credit_tokens
                            break
        
        # Fallback to legacy heuristic method if explicit markers not found
        if not title:
            for offset in [-2, -1]:  # Check only before first figure (titles should precede images)
                check_idx = first_fig.para_idx + offset
                if 0 <= check_idx < len(para_texts):
                    text = para_texts[check_idx]
                    # Skip document title and explicit markers (to avoid double processing)
                    if (text and text != doc_full_title and 
                        not is_title_paragraph(text) and not is_source_paragraph(text) and
                        is_short_title(text, config.max_title_len)):
                        title = safe_traditional_to_simplified(text, converter) if converter else text
                        break
        
        if not credit:
            for offset in [1, 2]:  # Check only after last figure (sources should follow images)
                check_idx = last_fig.para_idx + offset
                if 0 <= check_idx < len(para_texts):
                    text = para_texts[check_idx]
                    # Skip explicit markers (to avoid double processing)
                    if text and not is_title_paragraph(text) and not is_source_paragraph(text) and is_potential_credit_line(text):
                        credit_str, credit_tokens = normalize_credits(text)
                        if credit_tokens:
                            if converter:
                                credit_tokens = [safe_traditional_to_simplified(t, converter) for t in credit_tokens]
                            credit = ", ".join(credit_tokens)
                            group.credit_tokens = credit_tokens
                        break
        
        group.title = title
        group.credit = credit
        
        # Update debug reason with method indication
        method_title = "explicit" if (config.use_explicit_markers and title and 
                                    any(is_title_paragraph(para_texts[first_fig.para_idx + offset]) 
                                       for offset in [-2, -1] if 0 <= first_fig.para_idx + offset < len(para_texts) and 
                                       extract_title_content(para_texts[first_fig.para_idx + offset]) == title)) else "heuristic"
        method_credit = "explicit" if (config.use_explicit_markers and credit and 
                                     any(is_source_paragraph(para_texts[last_fig.para_idx + offset]) 
                                        for offset in [1, 2] if 0 <= last_fig.para_idx + offset < len(para_texts) and 
                                        extract_source_content(para_texts[last_fig.para_idx + offset]) == credit)) else "heuristic"
        
        title_part = f"title({method_title}): '{title[:20]}...'" if title else "title: None"
        credit_part = f"credit({method_credit}): '{credit[:20]}...'" if credit else "credit: None"
        group.reason += f", {title_part}, {credit_part}"

# --------- Main Conversion ----------
def convert_docx_to_ncj(docx_path: str, config: Config) -> Dict[str, Any]:
    """Convert DOCX to NCJ format with improved figure grouping"""
    doc = Document(docx_path)
    
    # Initialize traditional to simplified converter if needed
    converter = None
    if config.traditional_to_simplified:
        try:
            converter = opencc.OpenCC('t2s')  # Traditional to Simplified
        except Exception as e:
            print(f"Warning: Failed to initialize OpenCC converter: {e}", file=sys.stderr)
    
    # Extract figures and paragraph texts
    figures, para_texts, page_width_emu = extract_figures_from_docx(doc, docx_path, converter)
    
    # Extract and hash real image assets (per-doc subdirectory under assets_dir)
    doc_base = os.path.splitext(os.path.basename(docx_path))[0]
    # Build slug: lowercase, non [0-9a-z] -> '_', collapse '_'
    tmp = doc_base.lower()
    tmp = re.sub(r'[^0-9a-z]+', '_', tmp)
    tmp = re.sub(r'_+', '_', tmp).strip('_')
    doc_slug = (tmp or "doc")
    per_doc_assets_dir = os.path.join(config.assets_dir, doc_slug)
    assets = extract_and_hash_images(figures, docx_path, per_doc_assets_dir)
    
    # Group figures
    groups = group_figures(figures, para_texts, page_width_emu, config)
    
    # Extract document metadata
    doc_title = None
    doc_date = None
    doc_full_title = None  # Store full title for skipping logic
    if para_texts:
        first_text = para_texts[0]
        match = DOC_TITLE_RE.match(first_text or '')
        if match:
            doc_full_title = first_text.strip()  # Full title for comparison
            doc_title = match.group(2).strip()   # Clean title without date
            if converter:
                doc_title = safe_traditional_to_simplified(doc_title, converter)
            doc_date = parse_date_from_yyMMdd(match.group(1))
    
    # Assign titles and credits
    assign_titles_and_credits(groups, para_texts, config, doc_full_title, converter)
    
    # Build output blocks
    out_blocks = []
    debug_info = []
    
    # Add non-image paragraphs and figures
    para_consumed = set()
    
    # First pass: mark paragraphs that contain figures or are consumed as titles/credits
    for group in groups:
        for fig in group.figures:
            para_consumed.add(fig.para_idx)
        
        # Mark title paragraph as consumed (check both original and extracted content)
        if group.title:
            for para_idx, text in enumerate(para_texts):
                # Check if this paragraph is a title paragraph with matching content
                if (is_title_paragraph(text) and extract_title_content(text) == group.title) or text == group.title:
                    para_consumed.add(para_idx)
                    break
        
        # Mark credit paragraph as consumed (check both original and extracted content)
        if group.credit:
            # Find the closest credit paragraph to the last figure in this group
            last_fig = group.figures[-1]
            best_match_idx = None
            best_distance = float('inf')
            
            for para_idx, text in enumerate(para_texts):
                # Check if this paragraph is a source paragraph with matching content
                # or if normalizing this text produces the same credit
                if (is_source_paragraph(text) and extract_source_content(text) == group.credit) or \
                   (text and normalize_credit(text) == group.credit):
                    distance = abs(para_idx - last_fig.para_idx)
                    if distance < best_distance:
                        best_distance = distance
                        best_match_idx = para_idx
            
            # Mark the closest match as consumed
            if best_match_idx is not None:
                para_consumed.add(best_match_idx)
                if config.debug:
                    debug_info.append(f"Consumed closest para {best_match_idx}: '{para_texts[best_match_idx][:30]}...' -> credit: '{group.credit}' (distance: {best_distance})")
    
    # Process all content in document order
    group_counter = 1
    figure_global_index = 0
    processed_groups = set()
    
    for para_idx, para_text in enumerate(para_texts):
        # Skip document title
        if para_idx == 0 and doc_full_title and para_text == doc_full_title:
            continue
            
        # Check if this paragraph starts a new group
        group_starting_here = None
        for g in groups:
            if g.figures and g.figures[0].para_idx == para_idx and id(g) not in processed_groups:
                group_starting_here = g
                break
        
        if group_starting_here:
            # Output the entire group
            group_id = f"grp_{group_counter:04d}"
            group_len = len(group_starting_here.figures)
            
            # Generate figures for this group
            for seq, fig in enumerate(group_starting_here.figures):
                # Use real asset_id from extracted images
                asset_id = fig.asset_id or f"img_missing_{figure_global_index:03d}"
                
                # Create figure block
                figure_block = {
                    "type": "figure",
                    "image": {"asset_id": asset_id},
                    "title": group_starting_here.title if seq == 0 else None,  # Title on first figure
                    "credit": group_starting_here.credit if seq == group_len - 1 else None,  # Credit on last figure
                    "credit_tokens": group_starting_here.credit_tokens if seq == group_len - 1 else None,
                    "group_id": group_id,
                    "group_seq": seq + 1,
                    "group_len": group_len,
                    "layout": group_starting_here.layout
                }
                
                out_blocks.append(figure_block)
                figure_global_index += 1
            
            debug_info.append(f"{group_id}: {group_starting_here.reason}")
            processed_groups.add(id(group_starting_here))
            group_counter += 1
            
        elif para_text and para_idx not in para_consumed:
            # Regular text paragraph
            # Convert text if needed (should already be converted, but double-check)
            display_text = para_text
            out_blocks.append({
                "type": "paragraph", 
                "text": display_text
            })
    
    # Build final NCJ structure
    ncj = {
        "doc": {
            "title": doc_title,
            "date": doc_date,
            "locale": "zh-CN",
            "version": "v1",
            "source_file": os.path.basename(docx_path)
        },
        "blocks": out_blocks,
        "assets": list(assets.values()),
        "report": {
            "warnings": [],
            "debug": debug_info if config.debug else []
        }
    }
    
    return ncj

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Convert DOCX to NCJ with advanced figure grouping')
    parser.add_argument('input', help='Input DOCX file')
    parser.add_argument('--out', default='content.json', help='Output JSON file')
    parser.add_argument('--assets-dir', default='assets', 
                       help='Directory to extract image assets (per-doc subfolders)')
    parser.add_argument('--max_title_len', type=int, default=60, 
                       help='Maximum length for title detection')
    parser.add_argument('--max_gap_paras', type=int, default=1,
                       help='Maximum paragraphs gap for grouping')
    parser.add_argument('--page_width_ratio', type=float, default=0.95,
                       help='Page width ratio for row layout detection')
    parser.add_argument('--debug', action='store_true',
                       help='Include debug information in output')
    parser.add_argument('--traditional-to-simplified', dest='traditional_to_simplified',
                       action='store_true', default=True,
                       help='Convert traditional Chinese to simplified Chinese (default: on)')
    parser.add_argument('--no-traditional-to-simplified', dest='traditional_to_simplified',
                       action='store_false',
                       help='Disable traditional→simplified conversion')
    parser.add_argument('--no-explicit-markers', action='store_true',
                       help='Disable explicit title/source marker detection (use legacy heuristic only)')
    parser.add_argument('--self-test-credits', action='store_true',
                       help='Run credit normalization self-test and exit')
    
    args = parser.parse_args()
    
    # Configure
    config = Config()
    config.max_title_len = args.max_title_len
    config.max_gap_paras = args.max_gap_paras
    config.page_width_ratio = args.page_width_ratio
    config.debug = args.debug
    config.assets_dir = args.assets_dir
    config.traditional_to_simplified = args.traditional_to_simplified
    config.use_explicit_markers = not args.no_explicit_markers  # Default: use explicit markers
    
    # Self test for credits normalization
    if args.self_test_credits:
        samples = [
            "Source: FT, Reddit",
            "来源：FT；WSJ；FT",
            "來源: BBC／Reuters | FT",
            " source ：  Bloomberg  ,  Bloomberg  ,  Nikkei  ",
        ]
        for s in samples:
            joined, tokens = normalize_credits(s)
            print(json.dumps({"input": s, "credit": joined, "tokens": tokens}, ensure_ascii=False))
        return

    # Convert
    try:
        ncj = convert_docx_to_ncj(args.input, config)
        
        # Output
        if args.out == '-':
            json.dump(ncj, sys.stdout, ensure_ascii=False, indent=2)
        else:
            with open(args.out, 'w', encoding='utf-8') as f:
                json.dump(ncj, f, ensure_ascii=False, indent=2)
                
        print(f"Converted {args.input} -> {args.out}")
        
        # Print summary
        total_figures = len([b for b in ncj['blocks'] if b['type'] == 'figure'])
        groups = len(set(b.get('group_id') for b in ncj['blocks'] if b['type'] == 'figure' and b.get('group_id')))
        multi_groups = len([g for g in set(b.get('group_id') for b in ncj['blocks'] if b['type'] == 'figure' and b.get('group_id')) 
                           if any(b.get('group_len', 1) > 1 for b in ncj['blocks'] if b.get('group_id') == g)])
        
        print(f"Summary: {total_figures} figures, {groups} groups, {multi_groups} multi-figure groups")
        
        if config.debug:
            print("Debug info:")
            for info in ncj['report']['debug']:
                print(f"  {info}")
    
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
</file>

<file path="scripts/setup.sh">
#!/bin/bash

# Create .cursor directory if it doesn't exist
mkdir -p .cursor

bun install

# Create mcp.json with the current directory path
echo "{
  \"mcpServers\": {
    \"TalkToFigma\": {
      \"command\": \"bunx\",
      \"args\": [
        \"cursor-talk-to-figma-mcp@latest\"
      ]
    }
  }
}" > .cursor/mcp.json
</file>

<file path="src/cursor_mcp_plugin/setcharacters.js">
function uniqBy(arr, predicate) {
  const cb = typeof predicate === "function" ? predicate : (o) => o[predicate];
  return [
    ...arr
      .reduce((map, item) => {
        const key = item === null || item === undefined ? item : cb(item);

        map.has(key) || map.set(key, item);

        return map;
      }, new Map())
      .values(),
  ];
}
export const setCharacters = async (node, characters, options) => {
  const fallbackFont = options?.fallbackFont || {
    family: "Roboto",
    style: "Regular",
  };
  try {
    if (node.fontName === figma.mixed) {
      if (options?.smartStrategy === "prevail") {
        const fontHashTree = {};
        for (let i = 1; i < node.characters.length; i++) {
          const charFont = node.getRangeFontName(i - 1, i);
          const key = `${charFont.family}::${charFont.style}`;
          fontHashTree[key] = fontHashTree[key] ? fontHashTree[key] + 1 : 1;
        }
        const prevailedTreeItem = Object.entries(fontHashTree).sort(
          (a, b) => b[1] - a[1]
        )[0];
        const [family, style] = prevailedTreeItem[0].split("::");
        const prevailedFont = {
          family,
          style,
        };
        await figma.loadFontAsync(prevailedFont);
        node.fontName = prevailedFont;
      } else if (options?.smartStrategy === "strict") {
        return setCharactersWithStrictMatchFont(node, characters, fallbackFont);
      } else if (options?.smartStrategy === "experimental") {
        return setCharactersWithSmartMatchFont(node, characters, fallbackFont);
      } else {
        const firstCharFont = node.getRangeFontName(0, 1);
        await figma.loadFontAsync(firstCharFont);
        node.fontName = firstCharFont;
      }
    } else {
      await figma.loadFontAsync({
        family: node.fontName.family,
        style: node.fontName.style,
      });
    }
  } catch (err) {
    console.warn(
      `Failed to load "${node.fontName["family"]} ${node.fontName["style"]}" font and replaced with fallback "${fallbackFont.family} ${fallbackFont.style}"`,
      err
    );
    await figma.loadFontAsync(fallbackFont);
    node.fontName = fallbackFont;
  }
  try {
    node.characters = characters;
    return true;
  } catch (err) {
    console.warn(`Failed to set characters. Skipped.`, err);
    return false;
  }
};

const setCharactersWithStrictMatchFont = async (
  node,
  characters,
  fallbackFont
) => {
  const fontHashTree = {};
  for (let i = 1; i < node.characters.length; i++) {
    const startIdx = i - 1;
    const startCharFont = node.getRangeFontName(startIdx, i);
    const startCharFontVal = `${startCharFont.family}::${startCharFont.style}`;
    while (i < node.characters.length) {
      i++;
      const charFont = node.getRangeFontName(i - 1, i);
      if (startCharFontVal !== `${charFont.family}::${charFont.style}`) {
        break;
      }
    }
    fontHashTree[`${startIdx}_${i}`] = startCharFontVal;
  }
  await figma.loadFontAsync(fallbackFont);
  node.fontName = fallbackFont;
  node.characters = characters;
  console.log(fontHashTree);
  await Promise.all(
    Object.keys(fontHashTree).map(async (range) => {
      console.log(range, fontHashTree[range]);
      const [start, end] = range.split("_");
      const [family, style] = fontHashTree[range].split("::");
      const matchedFont = {
        family,
        style,
      };
      await figma.loadFontAsync(matchedFont);
      return node.setRangeFontName(Number(start), Number(end), matchedFont);
    })
  );
  return true;
};

const getDelimiterPos = (str, delimiter, startIdx = 0, endIdx = str.length) => {
  const indices = [];
  let temp = startIdx;
  for (let i = startIdx; i < endIdx; i++) {
    if (
      str[i] === delimiter &&
      i + startIdx !== endIdx &&
      temp !== i + startIdx
    ) {
      indices.push([temp, i + startIdx]);
      temp = i + startIdx + 1;
    }
  }
  temp !== endIdx && indices.push([temp, endIdx]);
  return indices.filter(Boolean);
};

const buildLinearOrder = (node) => {
  const fontTree = [];
  const newLinesPos = getDelimiterPos(node.characters, "\n");
  newLinesPos.forEach(([newLinesRangeStart, newLinesRangeEnd], n) => {
    const newLinesRangeFont = node.getRangeFontName(
      newLinesRangeStart,
      newLinesRangeEnd
    );
    if (newLinesRangeFont === figma.mixed) {
      const spacesPos = getDelimiterPos(
        node.characters,
        " ",
        newLinesRangeStart,
        newLinesRangeEnd
      );
      spacesPos.forEach(([spacesRangeStart, spacesRangeEnd], s) => {
        const spacesRangeFont = node.getRangeFontName(
          spacesRangeStart,
          spacesRangeEnd
        );
        if (spacesRangeFont === figma.mixed) {
          const spacesRangeFont = node.getRangeFontName(
            spacesRangeStart,
            spacesRangeStart[0]
          );
          fontTree.push({
            start: spacesRangeStart,
            delimiter: " ",
            family: spacesRangeFont.family,
            style: spacesRangeFont.style,
          });
        } else {
          fontTree.push({
            start: spacesRangeStart,
            delimiter: " ",
            family: spacesRangeFont.family,
            style: spacesRangeFont.style,
          });
        }
      });
    } else {
      fontTree.push({
        start: newLinesRangeStart,
        delimiter: "\n",
        family: newLinesRangeFont.family,
        style: newLinesRangeFont.style,
      });
    }
  });
  return fontTree
    .sort((a, b) => +a.start - +b.start)
    .map(({ family, style, delimiter }) => ({ family, style, delimiter }));
};

const setCharactersWithSmartMatchFont = async (
  node,
  characters,
  fallbackFont
) => {
  const rangeTree = buildLinearOrder(node);
  const fontsToLoad = uniqBy(
    rangeTree,
    ({ family, style }) => `${family}::${style}`
  ).map(({ family, style }) => ({
    family,
    style,
  }));

  await Promise.all([...fontsToLoad, fallbackFont].map(figma.loadFontAsync));

  node.fontName = fallbackFont;
  node.characters = characters;

  let prevPos = 0;
  rangeTree.forEach(({ family, style, delimiter }) => {
    if (prevPos < node.characters.length) {
      const delimeterPos = node.characters.indexOf(delimiter, prevPos);
      const endPos =
        delimeterPos > prevPos ? delimeterPos : node.characters.length;
      const matchedFont = {
        family,
        style,
      };
      node.setRangeFontName(prevPos, endPos, matchedFont);
      prevPos = endPos + 1;
    }
  });
  return true;
};
</file>

<file path=".gitignore">
node_modules/
.cursor/
dist/
docs/
</file>

<file path="Dockerfile">
# Use the Bun image as the base image
FROM oven/bun:latest

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY package*.json ./

RUN bun install

# Expose the port on which the API will listen
EXPOSE 3055

# Run the server when the container launches
CMD ["bun", "src/talk_to_figma_mcp/server.ts"]
</file>

<file path="LICENSE">
The MIT License (MIT)

Copyright (c) 2025 Github User sonnylazuardi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="smithery.yaml">
# Smithery configuration file: https://smithery.ai/docs/config#smitheryyaml

startCommand:
  type: stdio
  configSchema:
    # JSON Schema defining the configuration options for the MCP.
    {}
  commandFunction:
    # A JS function that produces the CLI command based on the given config to start the MCP on stdio.
    |-
    (config) => ({
      command: 'bunx',
      args: ['cursor-talk-to-figma-mcp']
    })
</file>

<file path="tsup.config.ts">
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: ['src/talk_to_figma_mcp/server.ts'],
  format: ['cjs', 'esm'],
  dts: true,
  clean: true,
  outDir: 'dist',
  target: 'node18',
  sourcemap: true,
  minify: false,
  splitting: false,
  bundle: true,
});
</file>

<file path=".grok/settings.json">
{
  "model": "grok-4-latest"
}
</file>

<file path="config/node_name_map.json">
{
  "template_discovery": {
    "status": "completed", 
    "discovered_at": "2025-08-30T09:51:00.000Z",
    "user_confirmed": false,
    "algorithm_version": "v2_visual_container_detection"
  },
  "nodes": {
    "BackgroundFrame": {
      "id": "6:5403",
      "name": "O",
      "type": "FRAME", 
      "confidence": 100
    },
    "ContentGroup": {
      "id": "6:6377",
      "name": "Group 1000015016",
      "type": "GROUP",
      "confidence": 95,
      "bbox": {"x": 155, "y": 2331, "width": 1609.2945556640625, "height": 24509}
    },
    "doc_title": {
      "id": "6:6357",
      "name": "每日晨報",
      "type": "TEXT",
      "confidence": 95
    },
    "date": {
      "id": "6:6351", 
      "name": "24",
      "type": "TEXT",
      "confidence": 90
    },
    "date_month": {
      "id": "6:6352",
      "name": "AUG", 
      "type": "TEXT",
      "confidence": 90
    }
  },
  "content_elements": {
    "images": [
      {"id": "6:6441", "name": "image 7311", "bbox": {"x": 158, "y": 2331, "width": 1604, "height": 1405}},
      {"id": "6:6442", "name": "image 7312", "bbox": {"x": 157, "y": 4116, "width": 1604.5435791015625, "height": 1236}},
      {"id": "6:6443", "name": "image 7313", "bbox": {"x": 158, "y": 8150, "width": 1604, "height": 828}},
      {"id": "6:6444", "name": "image 7314", "bbox": {"x": 158, "y": 10208, "width": 1604, "height": 264}},
      {"id": "6:6445", "name": "image 7315", "bbox": {"x": 158, "y": 10795, "width": 1604, "height": 760}},
      {"id": "6:6378", "name": "image 7302", "bbox": {"x": 158, "y": 23713, "width": 1604, "height": 921}},
      {"id": "6:6379", "name": "image 7303", "bbox": {"x": 158, "y": 22362, "width": 1604, "height": 1028}},
      {"id": "6:6380", "name": "image 7304", "bbox": {"x": 157, "y": 21377, "width": 1604.41455078125, "height": 905}},
      {"id": "6:6381", "name": "image 7305", "bbox": {"x": 158, "y": 18762, "width": 1604, "height": 545}},
      {"id": "6:6382", "name": "image 7306", "bbox": {"x": 158, "y": 17417, "width": 1604, "height": 1022}},
      {"id": "6:6383", "name": "image 7307", "bbox": {"x": 155, "y": 15838, "width": 1609, "height": 466}},
      {"id": "6:6384", "name": "image 7308", "bbox": {"x": 155, "y": 15455, "width": 1609.2945556640625, "height": 303}},
      {"id": "6:6385", "name": "image 7309", "bbox": {"x": 158, "y": 12988, "width": 1604, "height": 1054}},
      {"id": "6:6386", "name": "image 7310", "bbox": {"x": 157, "y": 5432, "width": 1605, "height": 1605}}
    ],
    "title_groups": [
      {"id": "6:6394", "name": "2行标题", "bbox": {"x": 158, "y": 3896, "width": 1604, "height": 140}},
      {"id": "6:6397", "name": "2行标题", "bbox": {"x": 158, "y": 8010, "width": 1604, "height": 140}},
      {"id": "6:6400", "name": "2行标题", "bbox": {"x": 158, "y": 10068, "width": 1604, "height": 140}},
      {"id": "6:6403", "name": "2行标题", "bbox": {"x": 158, "y": 10655, "width": 1604, "height": 140}},
      {"id": "6:6406", "name": "2行标题", "bbox": {"x": 158, "y": 15235, "width": 1604, "height": 140}},
      {"id": "6:6409", "name": "2行标题", "bbox": {"x": 158, "y": 17277, "width": 1604, "height": 140}},
      {"id": "6:6412", "name": "2行标题", "bbox": {"x": 158, "y": 18622, "width": 1604, "height": 140}},
      {"id": "6:6415", "name": "2行标题", "bbox": {"x": 158, "y": 23573, "width": 1604, "height": 140}},
      {"id": "6:6418", "name": "2行标题", "bbox": {"x": 158, "y": 12748, "width": 1604, "height": 240}},
      {"id": "6:6422", "name": "2行标题", "bbox": {"x": 158, "y": 21057, "width": 1604, "height": 240}}
    ],
    "sources": [
      {"id": "6:6387", "name": "Source: CS, Citi", "bbox": {"x": 729, "y": 7077, "width": 462, "height": 63}},
      {"id": "6:6388", "name": "Source: CS, Citi", "bbox": {"x": 729, "y": 10512, "width": 462, "height": 63}},
      {"id": "6:6389", "name": "Source: CS, Citi", "bbox": {"x": 649, "y": 11595, "width": 622, "height": 63}},
      {"id": "6:6390", "name": "Source: CS, Citi", "bbox": {"x": 649, "y": 14082, "width": 622, "height": 63}},
      {"id": "6:6391", "name": "Source: CS, Citi", "bbox": {"x": 561, "y": 16344, "width": 797, "height": 63}},
      {"id": "6:6392", "name": "Source: CS, Citi", "bbox": {"x": 561, "y": 18479, "width": 797, "height": 63}},
      {"id": "6:6393", "name": "Source: CS, Citi", "bbox": {"x": 561, "y": 23430, "width": 797, "height": 63}}
    ],
    "paragraphs": [
      {"id": "6:6426", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 7300, "width": 1604, "height": 550}},
      {"id": "6:6427", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 9138, "width": 1604, "height": 770}},
      {"id": "6:6428", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 11818, "width": 1604, "height": 770}},
      {"id": "6:6429", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 14305, "width": 1604, "height": 770}},
      {"id": "6:6430", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 16567, "width": 1604, "height": 550}},
      {"id": "6:6431", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 19467, "width": 1604, "height": 1430}},
      {"id": "6:6432", "name": "Last Friday saw a li", "bbox": {"x": 158, "y": 24794, "width": 1604, "height": 110}}
    ]
  },
  "visual_mapping": {
    "sorted_by_y": "按视觉顺序(y坐标)排列所有内容元素",
    "image_title_associations": "基于邻域距离建立图片与标题组的关联关系",
    "content_flow": "从上到下: 图片->标题组->段落->来源，循环重复"
  }
}
</file>

<file path="scripts/execute_seedless_validation.js">
#!/usr/bin/env node
/**
 * Minimal MCP JSON-RPC client for "talk-to-figma" tools.
 * - Connects to ws://HOST:PORT (defaults 127.0.0.1:3055)
 * - Joins CHANNEL_ID (CLI --channel or env CHANNEL_ID)
 * - Provides call(method, params) helper
 *
 * Usage of all scripts:
 *   node <script> --channel <id> [--content <file.json>] [--dry-run]
 *
 * Assumptions:
 * - Server exposes methods like:
 *   mcp__talk-to-figma__join_channel
 *   mcp__talk-to-figma__get_document_info
 *   mcp__talk-to-figma__get_node_info
 *   mcp__talk-to-figma__get_local_components
 *   mcp__talk-to-figma__create_component_instance
 *   mcp__talk-to-figma__clone_node
 *   mcp__talk-to-figma__append_card_to_container
 *   mcp__talk-to-figma__set_text_content
 *   mcp__talk-to-figma__set_image_fill
 *   mcp__talk-to-figma__set_instance_overrides   // if available
 *   mcp__talk-to-figma__set_node_visible         // optional fallback
 *   mcp__talk-to-figma__delete_node              // optional cleanup
 */
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import url from "url";
import WebSocket from "ws";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

function parseArgs() {
  const args = process.argv.slice(2);
  const out = {};
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a.startsWith("--")) {
      const k = a.replace(/^--/, "");
      const v = (i+1 < args.length && !args[i+1].startsWith("--")) ? args[++i] : true;
      out[k] = v;
    }
  }
  return out;
}

function envOr(obj, key, fallback) {
  return process.env[key] ?? obj[key] ?? fallback;
}

function readJSON(p) {
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function getContentPath(projectRoot, options={}) {
  // priority: CLI --content > ENV CONTENT_JSON_PATH > server-config.workflow.current_content_file > autodiscover (latest *.json in docx2json)
  const cli = options.cliContent;
  if (cli) {
    const p = path.isAbsolute(cli) ? cli : path.join(projectRoot, "docx2json", cli);
    if (fs.existsSync(p)) return p;
  }
  const envP = process.env.CONTENT_JSON_PATH;
  if (envP) {
    const p = path.isAbsolute(envP) ? envP : path.join(projectRoot, "docx2json", envP);
    if (fs.existsSync(p)) return p;
  }
  // server-config.json
  try {
    const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
    const dir = cfg?.workflow?.content_directory ? path.resolve(projectRoot, cfg.workflow.content_directory) : path.join(projectRoot, "docx2json");
    let base = cfg?.workflow?.current_content_file || null;
    if (base) {
      const p = path.isAbsolute(base) ? base : path.join(dir, base);
      if (fs.existsSync(p)) return p;
    }
    // autodiscover latest
    const files = fs.readdirSync(dir).filter(x => x.endsWith(".json"));
    if (files.length) {
      files.sort((a,b)=>fs.statSync(path.join(dir,b)).mtimeMs - fs.statSync(path.join(dir,a)).mtimeMs);
      return path.join(dir, files[0]);
    }
  } catch {}
  throw new Error("Cannot resolve content JSON path");
}

class MCPClient {
  constructor({host="127.0.0.1", port=3055, channel}) {
    this.url = `ws://${host}:${port}`;
    this.channel = channel;
    this.id = 0;
    this.pending = new Map();
  }
  async connect() {
    this.ws = new WebSocket(this.url);
    await new Promise((res, rej)=>{
      this.ws.on("open", res);
      this.ws.on("error", rej);
    });
    this.ws.on("message", (data)=>{
      try {
        const msg = JSON.parse(data.toString());
        if (msg.id && this.pending.has(msg.id)) {
          const {resolve, reject} = this.pending.get(msg.id);
          this.pending.delete(msg.id);
          if (msg.error) reject(new Error(msg.error.message || String(msg.error)));
          else resolve(msg.result);
        }
      } catch {}
    });
    if (this.channel) {
      await this.call("mcp__talk-to-figma__join_channel", { channel: this.channel });
    }
  }
  async call(method, params={}) {
    const id = ++this.id;
    const payload = { jsonrpc: "2.0", id, method, params };
    const p = new Promise((resolve, reject)=>{
      this.pending.set(id, {resolve, reject});
      setTimeout(()=>{
        if (this.pending.has(id)) {
          this.pending.delete(id);
          reject(new Error(`Timeout waiting for ${method}`));
        }
      }, 30000);
    });
    this.ws.send(JSON.stringify(payload));
    return p;
  }
  close() { try { this.ws?.close(); } catch {} }
}

async function getWorkflowMapping(projectRoot) {
  const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
  if (!cfg?.workflow?.mapping) throw new Error("workflow.mapping not found in server-config.json");
  return { cfg, mapping: cfg.workflow.mapping };
}

async function resolveAnchors(mcp, mapping) {
  // Find frame -> container -> cards stack
  const doc = await mcp.call("mcp__talk-to-figma__get_document_info", {});
  const frame = (doc.children || []).find(n => n.name === mapping.anchors.frame);
  if (!frame) throw new Error(`Frame "${mapping.anchors.frame}" not found`);
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frame.id });
  const container = (frameInfo.children || []).find(n => n.name === mapping.anchors.container);
  if (!container) throw new Error(`Container "${mapping.anchors.container}" not found`);
  const contInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: container.id });
  const cards = (contInfo.children || []).find(n => n.name === mapping.anchors.cards_stack);
  if (!cards) throw new Error(`Cards stack "${mapping.anchors.cards_stack}" not found`);
  return { frameId: frame.id, containerId: container.id, cardsId: cards.id };
}

async function resolveSeeds(mcp, mapping, frameId) {
  const out = { figureSeedId: null, bodySeedId: null };
  const seedsCfg = mapping.anchors?.seeds;
  if (!seedsCfg) return out;
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frameId });
  const seedsFrame = (frameInfo.children || []).find(n => n.name === seedsCfg.frame);
  if (!seedsFrame) return out;
  const seedsInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: seedsFrame.id });
  const fig = (seedsInfo.children || []).find(n => n.name === seedsCfg.figure);
  const body= (seedsInfo.children || []).find(n => n.name === seedsCfg.body);
  out.figureSeedId = fig?.id || null;
  out.bodySeedId   = body?.id || null;
  return out;
}

async function findChildByName(mcp, nodeId, name, maxDepth=3) {
  // BFS limited depth
  let frontier = [{id: nodeId, depth: 0}];
  while (frontier.length) {
    const {id, depth} = frontier.shift();
    if (depth>maxDepth) continue;
    const info = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: id });
    const children = info.children || [];
    for (const c of children) {
      if (c.name === name) return c.id;
      frontier.push({id: c.id, depth: depth+1});
    }
  }
  return null;
}

function groupOrderedContent(content) {
  const blocks = content.blocks || [];
  const groupsMap = new Map();  // group_id -> arr
  const order = [];              // sequence of items: {type:"group", id} | {type:"paragraph", idx}
  blocks.forEach((b, i) => {
    if (b.group_id) {
      if (!groupsMap.has(b.group_id)) {
        groupsMap.set(b.group_id, []);
        order.push({ type: "group", group_id: b.group_id });
      }
      groupsMap.get(b.group_id).push(b);
    } else if (b.type === "paragraph") {
      order.push({ type: "paragraph", idx: i });
    }
  });
  // sort inside group by group_seq
  const sequence = [];
  order.forEach(item => {
    if (item.type === "group") {
      const arr = groupsMap.get(item.group_id) || [];
      arr.sort((a,b)=> (a.group_seq||0)-(b.group_seq||0));
      sequence.push({ type:"figure_group",
                      group_id: item.group_id,
                      blocks: arr,
                      figures: arr.filter(x=>x.type==="figure"),
                      paragraphs: arr.filter(x=>x.type==="paragraph") });
    } else {
      sequence.push({ type:"standalone_paragraph", blockIndex: item.idx });
    }
  });
  return sequence;
}

function byPath(obj, dotted) {
  const parts = dotted.split(".");
  let cur = obj;
  for (const p of parts) {
    if (cur == null) return undefined;
    cur = cur[p];
  }
  return cur;
}

(async () => {
  const args = parseArgs();
  const host = envOr(args, "host", "127.0.0.1");
  const port = Number(envOr(args, "port", 3055));
  const channel = envOr(args, "channel", process.env.CHANNEL_ID || null);
  const projectRoot = path.resolve(__dirname, "..");
  const mcp = new MCPClient({host, port, channel});
  try {
    await mcp.connect();
    const { mapping } = await getWorkflowMapping(projectRoot);
    const { frameId, containerId, cardsId } = await resolveAnchors(mcp, mapping);

    // Prefer direct-local with componentId if available via get_local_components
    const comps = await mcp.call("mcp__talk-to-figma__get_local_components", {});
    const fig = (comps.components||[]).find(c=>c.name===mapping.anchors.figure_component);
    if (!fig) throw new Error("FigureCard component not found locally");

    const res = await mcp.call("mcp__talk-to-figma__create_component_instance", {
      componentId: fig.id, parentId: cardsId, x: 0, y: 0
    });
    const instanceId = res.id || res.nodeId;
    if (!instanceId) throw new Error("create_component_instance returned no id");
    console.log("✅ Instance created:", instanceId);

    // Fill quick smoke: title + image slot1 (if exists)
    const titleId = await findChildByName(mcp, instanceId, mapping.title?.text_prop || "titleText");
    if (titleId) await mcp.call("mcp__talk-to-figma__set_text_content", { nodeId: titleId, text: "Smoke: FigureCard" });
    const slot1 = await findChildByName(mcp, instanceId, (mapping.anchors.image_slots||["imgSlot1"])[0]);
    if (slot1) {
      const STATIC_BASE = process.env.STATIC_BASE || "http://127.0.0.1:3056/assets";
      await mcp.call("mcp__talk-to-figma__set_image_fill", {
        nodeId: slot1, imageUrl: `${STATIC_BASE}/img_placeholder.png`, scaleMode: "FILL", opacity: 1
      });
    }
    console.log("✅ Seedless execute smoke done");
    mcp.close();
  } catch (e) {
    console.error("💥 Execute seedless failed:", e.stack || e.message);
    process.exitCode = 1;
  }
})();
</file>

<file path="scripts/test_plugin_startup.js">
#!/usr/bin/env node
/**
 * Minimal MCP JSON-RPC client for "talk-to-figma" tools.
 * - Connects to ws://HOST:PORT (defaults 127.0.0.1:3055)
 * - Joins CHANNEL_ID (CLI --channel or env CHANNEL_ID)
 * - Provides call(method, params) helper
 *
 * Usage of all scripts:
 *   node <script> --channel <id> [--content <file.json>] [--dry-run]
 *
 * Assumptions:
 * - Server exposes methods like:
 *   mcp__talk-to-figma__join_channel
 *   mcp__talk-to-figma__get_document_info
 *   mcp__talk-to-figma__get_node_info
 *   mcp__talk-to-figma__get_local_components
 *   mcp__talk-to-figma__create_component_instance
 *   mcp__talk-to-figma__clone_node
 *   mcp__talk-to-figma__append_card_to_container
 *   mcp__talk-to-figma__set_text_content
 *   mcp__talk-to-figma__set_image_fill
 *   mcp__talk-to-figma__set_instance_overrides   // if available
 *   mcp__talk-to-figma__set_node_visible         // optional fallback
 *   mcp__talk-to-figma__delete_node              // optional cleanup
 */
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import url from "url";
import WebSocket from "ws";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

function parseArgs() {
  const args = process.argv.slice(2);
  const out = {};
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a.startsWith("--")) {
      const k = a.replace(/^--/, "");
      const v = (i+1 < args.length && !args[i+1].startsWith("--")) ? args[++i] : true;
      out[k] = v;
    }
  }
  return out;
}

function envOr(obj, key, fallback) {
  return process.env[key] ?? obj[key] ?? fallback;
}

function readJSON(p) {
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function getContentPath(projectRoot, options={}) {
  // priority: CLI --content > ENV CONTENT_JSON_PATH > server-config.workflow.current_content_file > autodiscover (latest *.json in docx2json)
  const cli = options.cliContent;
  if (cli) {
    const p = path.isAbsolute(cli) ? cli : path.join(projectRoot, "docx2json", cli);
    if (fs.existsSync(p)) return p;
  }
  const envP = process.env.CONTENT_JSON_PATH;
  if (envP) {
    const p = path.isAbsolute(envP) ? envP : path.join(projectRoot, "docx2json", envP);
    if (fs.existsSync(p)) return p;
  }
  // server-config.json
  try {
    const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
    const dir = cfg?.workflow?.content_directory ? path.resolve(projectRoot, cfg.workflow.content_directory) : path.join(projectRoot, "docx2json");
    let base = cfg?.workflow?.current_content_file || null;
    if (base) {
      const p = path.isAbsolute(base) ? base : path.join(dir, base);
      if (fs.existsSync(p)) return p;
    }
    // autodiscover latest
    const files = fs.readdirSync(dir).filter(x => x.endsWith(".json"));
    if (files.length) {
      files.sort((a,b)=>fs.statSync(path.join(dir,b)).mtimeMs - fs.statSync(path.join(dir,a)).mtimeMs);
      return path.join(dir, files[0]);
    }
  } catch {}
  throw new Error("Cannot resolve content JSON path");
}

class MCPClient {
  constructor({host="127.0.0.1", port=3055, channel}) {
    this.url = `ws://${host}:${port}`;
    this.channel = channel;
    this.id = 0;
    this.pending = new Map();
  }
  async connect() {
    this.ws = new WebSocket(this.url);
    await new Promise((res, rej)=>{
      this.ws.on("open", res);
      this.ws.on("error", rej);
    });
    this.ws.on("message", (data)=>{
      try {
        const msg = JSON.parse(data.toString());
        if (msg.id && this.pending.has(msg.id)) {
          const {resolve, reject} = this.pending.get(msg.id);
          this.pending.delete(msg.id);
          if (msg.error) reject(new Error(msg.error.message || String(msg.error)));
          else resolve(msg.result);
        }
      } catch {}
    });
    if (this.channel) {
      await this.call("mcp__talk-to-figma__join_channel", { channel: this.channel });
    }
  }
  async call(method, params={}) {
    const id = ++this.id;
    const payload = { jsonrpc: "2.0", id, method, params };
    const p = new Promise((resolve, reject)=>{
      this.pending.set(id, {resolve, reject});
      setTimeout(()=>{
        if (this.pending.has(id)) {
          this.pending.delete(id);
          reject(new Error(`Timeout waiting for ${method}`));
        }
      }, 30000);
    });
    this.ws.send(JSON.stringify(payload));
    return p;
  }
  close() { try { this.ws?.close(); } catch {} }
}

async function getWorkflowMapping(projectRoot) {
  const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
  if (!cfg?.workflow?.mapping) throw new Error("workflow.mapping not found in server-config.json");
  return { cfg, mapping: cfg.workflow.mapping };
}

async function resolveAnchors(mcp, mapping) {
  // Find frame -> container -> cards stack
  const doc = await mcp.call("mcp__talk-to-figma__get_document_info", {});
  const frame = (doc.children || []).find(n => n.name === mapping.anchors.frame);
  if (!frame) throw new Error(`Frame "${mapping.anchors.frame}" not found`);
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frame.id });
  const container = (frameInfo.children || []).find(n => n.name === mapping.anchors.container);
  if (!container) throw new Error(`Container "${mapping.anchors.container}" not found`);
  const contInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: container.id });
  const cards = (contInfo.children || []).find(n => n.name === mapping.anchors.cards_stack);
  if (!cards) throw new Error(`Cards stack "${mapping.anchors.cards_stack}" not found`);
  return { frameId: frame.id, containerId: container.id, cardsId: cards.id };
}

async function resolveSeeds(mcp, mapping, frameId) {
  const out = { figureSeedId: null, bodySeedId: null };
  const seedsCfg = mapping.anchors?.seeds;
  if (!seedsCfg) return out;
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frameId });
  const seedsFrame = (frameInfo.children || []).find(n => n.name === seedsCfg.frame);
  if (!seedsFrame) return out;
  const seedsInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: seedsFrame.id });
  const fig = (seedsInfo.children || []).find(n => n.name === seedsCfg.figure);
  const body= (seedsInfo.children || []).find(n => n.name === seedsCfg.body);
  out.figureSeedId = fig?.id || null;
  out.bodySeedId   = body?.id || null;
  return out;
}

async function findChildByName(mcp, nodeId, name, maxDepth=3) {
  // BFS limited depth
  let frontier = [{id: nodeId, depth: 0}];
  while (frontier.length) {
    const {id, depth} = frontier.shift();
    if (depth>maxDepth) continue;
    const info = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: id });
    const children = info.children || [];
    for (const c of children) {
      if (c.name === name) return c.id;
      frontier.push({id: c.id, depth: depth+1});
    }
  }
  return null;
}

function groupOrderedContent(content) {
  const blocks = content.blocks || [];
  const groupsMap = new Map();  // group_id -> arr
  const order = [];              // sequence of items: {type:"group", id} | {type:"paragraph", idx}
  blocks.forEach((b, i) => {
    if (b.group_id) {
      if (!groupsMap.has(b.group_id)) {
        groupsMap.set(b.group_id, []);
        order.push({ type: "group", group_id: b.group_id });
      }
      groupsMap.get(b.group_id).push(b);
    } else if (b.type === "paragraph") {
      order.push({ type: "paragraph", idx: i });
    }
  });
  // sort inside group by group_seq
  const sequence = [];
  order.forEach(item => {
    if (item.type === "group") {
      const arr = groupsMap.get(item.group_id) || [];
      arr.sort((a,b)=> (a.group_seq||0)-(b.group_seq||0));
      sequence.push({ type:"figure_group",
                      group_id: item.group_id,
                      blocks: arr,
                      figures: arr.filter(x=>x.type==="figure"),
                      paragraphs: arr.filter(x=>x.type==="paragraph") });
    } else {
      sequence.push({ type:"standalone_paragraph", blockIndex: item.idx });
    }
  });
  return sequence;
}

function byPath(obj, dotted) {
  const parts = dotted.split(".");
  let cur = obj;
  for (const p of parts) {
    if (cur == null) return undefined;
    cur = cur[p];
  }
  return cur;
}

(async () => {
  const args = parseArgs();
  const host = envOr(args, "host", "127.0.0.1");
  const port = Number(envOr(args, "port", 3055));
  const channel = envOr(args, "channel", process.env.CHANNEL_ID || null);
  const mcp = new MCPClient({host, port, channel});
  try {
    await mcp.connect();
    const doc = await mcp.call("mcp__talk-to-figma__get_document_info", {});
    console.log("✅ Connected. Document root:", doc.name, "children:", (doc.children||[]).length);

    const comps = await mcp.call("mcp__talk-to-figma__get_local_components", {});
    const names = (comps.components||[]).map(c=>c.name);
    console.log("✅ Local components:", names.join(", ") || "(none)");

    // quick anchor sanity if server-config exists
    try {
      const projectRoot = path.resolve(__dirname, "..");
      const { mapping } = await getWorkflowMapping(projectRoot);
      console.log("Anchors (from server-config):", mapping.anchors);
      // try resolve
      const { frameId, containerId, cardsId } = await (async()=>{
        const doc = await mcp.call("mcp__talk-to-figma__get_document_info", {});
        const frame = (doc.children||[]).find(n=>n.name===mapping.anchors.frame);
        const frameInfo = frame ? await mcp.call("mcp__talk-to-figma__get_node_info", {nodeId: frame.id}) : null;
        const cont = frameInfo ? (frameInfo.children||[]).find(n=>n.name===mapping.anchors.container) : null;
        const contInfo = cont ? await mcp.call("mcp__talk-to-figma__get_node_info", {nodeId: cont.id}) : null;
        const cards = contInfo ? (contInfo.children||[]).find(n=>n.name===mapping.anchors.cards_stack) : null;
        return { frameId: frame?.id, containerId: cont?.id, cardsId: cards?.id };
      })();
      console.log("✅ Anchor nodeIds:", { frameId, containerId, cardsId });
    } catch (e) {
      console.warn("⚠️ server-config anchor resolution skipped:", e.message);
    }

    mcp.close();
  } catch (e) {
    console.error("💥 Plugin startup test failed:", e.stack || e.message);
    process.exitCode = 1;
  }
})();
</file>

<file path="scripts/validate_seedless.js">
#!/usr/bin/env node
/**
 * Minimal MCP JSON-RPC client for "talk-to-figma" tools.
 * - Connects to ws://HOST:PORT (defaults 127.0.0.1:3055)
 * - Joins CHANNEL_ID (CLI --channel or env CHANNEL_ID)
 * - Provides call(method, params) helper
 *
 * Usage of all scripts:
 *   node <script> --channel <id> [--content <file.json>] [--dry-run]
 *
 * Assumptions:
 * - Server exposes methods like:
 *   mcp__talk-to-figma__join_channel
 *   mcp__talk-to-figma__get_document_info
 *   mcp__talk-to-figma__get_node_info
 *   mcp__talk-to-figma__get_local_components
 *   mcp__talk-to-figma__create_component_instance
 *   mcp__talk-to-figma__clone_node
 *   mcp__talk-to-figma__append_card_to_container
 *   mcp__talk-to-figma__set_text_content
 *   mcp__talk-to-figma__set_image_fill
 *   mcp__talk-to-figma__set_instance_overrides   // if available
 *   mcp__talk-to-figma__set_node_visible         // optional fallback
 *   mcp__talk-to-figma__delete_node              // optional cleanup
 */
import fs from "fs";
import fsp from "fs/promises";
import path from "path";
import url from "url";
import WebSocket from "ws";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);

function parseArgs() {
  const args = process.argv.slice(2);
  const out = {};
  for (let i = 0; i < args.length; i++) {
    const a = args[i];
    if (a.startsWith("--")) {
      const k = a.replace(/^--/, "");
      const v = (i+1 < args.length && !args[i+1].startsWith("--")) ? args[++i] : true;
      out[k] = v;
    }
  }
  return out;
}

function envOr(obj, key, fallback) {
  return process.env[key] ?? obj[key] ?? fallback;
}

function readJSON(p) {
  return JSON.parse(fs.readFileSync(p, "utf8"));
}

function getContentPath(projectRoot, options={}) {
  // priority: CLI --content > ENV CONTENT_JSON_PATH > server-config.workflow.current_content_file > autodiscover (latest *.json in docx2json)
  const cli = options.cliContent;
  if (cli) {
    const p = path.isAbsolute(cli) ? cli : path.join(projectRoot, "docx2json", cli);
    if (fs.existsSync(p)) return p;
  }
  const envP = process.env.CONTENT_JSON_PATH;
  if (envP) {
    const p = path.isAbsolute(envP) ? envP : path.join(projectRoot, "docx2json", envP);
    if (fs.existsSync(p)) return p;
  }
  // server-config.json
  try {
    const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
    const dir = cfg?.workflow?.content_directory ? path.resolve(projectRoot, cfg.workflow.content_directory) : path.join(projectRoot, "docx2json");
    let base = cfg?.workflow?.current_content_file || null;
    if (base) {
      const p = path.isAbsolute(base) ? base : path.join(dir, base);
      if (fs.existsSync(p)) return p;
    }
    // autodiscover latest
    const files = fs.readdirSync(dir).filter(x => x.endsWith(".json"));
    if (files.length) {
      files.sort((a,b)=>fs.statSync(path.join(dir,b)).mtimeMs - fs.statSync(path.join(dir,a)).mtimeMs);
      return path.join(dir, files[0]);
    }
  } catch {}
  throw new Error("Cannot resolve content JSON path");
}

class MCPClient {
  constructor({host="127.0.0.1", port=3055, channel}) {
    this.url = `ws://${host}:${port}`;
    this.channel = channel;
    this.id = 0;
    this.pending = new Map();
  }
  async connect() {
    this.ws = new WebSocket(this.url);
    await new Promise((res, rej)=>{
      this.ws.on("open", res);
      this.ws.on("error", rej);
    });
    this.ws.on("message", (data)=>{
      try {
        const msg = JSON.parse(data.toString());
        if (msg.id && this.pending.has(msg.id)) {
          const {resolve, reject} = this.pending.get(msg.id);
          this.pending.delete(msg.id);
          if (msg.error) reject(new Error(msg.error.message || String(msg.error)));
          else resolve(msg.result);
        }
      } catch {}
    });
    if (this.channel) {
      await this.call("mcp__talk-to-figma__join_channel", { channel: this.channel });
    }
  }
  async call(method, params={}) {
    const id = ++this.id;
    const payload = { jsonrpc: "2.0", id, method, params };
    const p = new Promise((resolve, reject)=>{
      this.pending.set(id, {resolve, reject});
      setTimeout(()=>{
        if (this.pending.has(id)) {
          this.pending.delete(id);
          reject(new Error(`Timeout waiting for ${method}`));
        }
      }, 30000);
    });
    this.ws.send(JSON.stringify(payload));
    return p;
  }
  close() { try { this.ws?.close(); } catch {} }
}

async function getWorkflowMapping(projectRoot) {
  const cfg = readJSON(path.join(projectRoot, "config", "server-config.json"));
  if (!cfg?.workflow?.mapping) throw new Error("workflow.mapping not found in server-config.json");
  return { cfg, mapping: cfg.workflow.mapping };
}

async function resolveAnchors(mcp, mapping) {
  // Find frame -> container -> cards stack
  const doc = await mcp.call("mcp__talk-to-figma__get_document_info", {});
  const frame = (doc.children || []).find(n => n.name === mapping.anchors.frame);
  if (!frame) throw new Error(`Frame "${mapping.anchors.frame}" not found`);
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frame.id });
  const container = (frameInfo.children || []).find(n => n.name === mapping.anchors.container);
  if (!container) throw new Error(`Container "${mapping.anchors.container}" not found`);
  const contInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: container.id });
  const cards = (contInfo.children || []).find(n => n.name === mapping.anchors.cards_stack);
  if (!cards) throw new Error(`Cards stack "${mapping.anchors.cards_stack}" not found`);
  return { frameId: frame.id, containerId: container.id, cardsId: cards.id };
}

async function resolveSeeds(mcp, mapping, frameId) {
  const out = { figureSeedId: null, bodySeedId: null };
  const seedsCfg = mapping.anchors?.seeds;
  if (!seedsCfg) return out;
  const frameInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: frameId });
  const seedsFrame = (frameInfo.children || []).find(n => n.name === seedsCfg.frame);
  if (!seedsFrame) return out;
  const seedsInfo = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: seedsFrame.id });
  const fig = (seedsInfo.children || []).find(n => n.name === seedsCfg.figure);
  const body= (seedsInfo.children || []).find(n => n.name === seedsCfg.body);
  out.figureSeedId = fig?.id || null;
  out.bodySeedId   = body?.id || null;
  return out;
}

async function findChildByName(mcp, nodeId, name, maxDepth=3) {
  // BFS limited depth
  let frontier = [{id: nodeId, depth: 0}];
  while (frontier.length) {
    const {id, depth} = frontier.shift();
    if (depth>maxDepth) continue;
    const info = await mcp.call("mcp__talk-to-figma__get_node_info", { nodeId: id });
    const children = info.children || [];
    for (const c of children) {
      if (c.name === name) return c.id;
      frontier.push({id: c.id, depth: depth+1});
    }
  }
  return null;
}

function groupOrderedContent(content) {
  const blocks = content.blocks || [];
  const groupsMap = new Map();  // group_id -> arr
  const order = [];              // sequence of items: {type:"group", id} | {type:"paragraph", idx}
  blocks.forEach((b, i) => {
    if (b.group_id) {
      if (!groupsMap.has(b.group_id)) {
        groupsMap.set(b.group_id, []);
        order.push({ type: "group", group_id: b.group_id });
      }
      groupsMap.get(b.group_id).push(b);
    } else if (b.type === "paragraph") {
      order.push({ type: "paragraph", idx: i });
    }
  });
  // sort inside group by group_seq
  const sequence = [];
  order.forEach(item => {
    if (item.type === "group") {
      const arr = groupsMap.get(item.group_id) || [];
      arr.sort((a,b)=> (a.group_seq||0)-(b.group_seq||0));
      sequence.push({ type:"figure_group",
                      group_id: item.group_id,
                      blocks: arr,
                      figures: arr.filter(x=>x.type==="figure"),
                      paragraphs: arr.filter(x=>x.type==="paragraph") });
    } else {
      sequence.push({ type:"standalone_paragraph", blockIndex: item.idx });
    }
  });
  return sequence;
}

function byPath(obj, dotted) {
  const parts = dotted.split(".");
  let cur = obj;
  for (const p of parts) {
    if (cur == null) return undefined;
    cur = cur[p];
  }
  return cur;
}

(async () => {
  const args = parseArgs();
  const host = envOr(args, "host", "127.0.0.1");
  const port = Number(envOr(args, "port", 3055));
  const channel = envOr(args, "channel", process.env.CHANNEL_ID || null);
  const projectRoot = path.resolve(__dirname, "..");
  const mcp = new MCPClient({host, port, channel});
  try {
    await mcp.connect();
    const { mapping } = await getWorkflowMapping(projectRoot);
    const { frameId, containerId, cardsId } = await resolveAnchors(mcp, mapping);

    // try local components by name
    const comps = await mcp.call("mcp__talk-to-figma__get_local_components", {});
    const fig = (comps.components||[]).find(c=>c.name===mapping.anchors.figure_component);
    const body= (comps.components||[]).find(c=>c.name===mapping.anchors.body_component);
    if (!fig || !body) throw new Error("Local components not found");

    // create 1 figure instance
    const res = await mcp.call("mcp__talk-to-figma__create_component_instance", {
      componentId: fig.id, parentId: cardsId, x: 0, y: 0
    });
    const instanceId = res.id || res.nodeId;
    if (!instanceId) throw new Error("Empty instance id from create_component_instance");

    // set overrides
    const overrides = {};
    if (mapping.title?.visible_prop) overrides[mapping.title.visible_prop] = true;
    if (mapping.source?.visible_prop) overrides[mapping.source.visible_prop] = false;
    if (mapping.images?.visibility_props?.imgSlot2) overrides[mapping.images.visibility_props.imgSlot2] = false;
    try {
      await mcp.call("mcp__talk-to-figma__set_instance_overrides", { nodeId: instanceId, overrides });
      console.log("✅ set_instance_overrides OK");
    } catch (e) {
      console.warn("⚠️ set_instance_overrides not available:", e.message);
    }

    // text
    const titleId = await findChildByName(mcp, instanceId, mapping.title?.text_prop || "titleText");
    if (titleId) await mcp.call("mcp__talk-to-figma__set_text_content", { nodeId: titleId, text: "[Validation] Title" });

    console.log("✅ Seedless validation passed");
    mcp.close();
  } catch (e) {
    console.error("💥 Validation failed:", e.stack || e.message);
    process.exitCode = 1;
  }
})();
</file>

<file path="src/cursor_mcp_plugin/manifest.json">
{
  "name": "Cursor MCP Plugin",
  "id": "cursor-mcp-plugin",
  "api": "1.0.0",
  "main": "code.js",
  "ui": "ui.html",
  "editorType": [
    "figma",
    "figjam"
  ],
  "permissions": [],
  "networkAccess": {
    "allowedDomains": [
      "https://google.com"
    ],
    "devAllowedDomains": [
      "http://localhost:3055",
      "ws://localhost:3055",
      "http://localhost:3056"
    ]
  },
  "documentAccess": "dynamic-page",
  "enableProposedApi": true,
  "enablePrivatePluginApi": true
}
</file>

<file path="src/talk_to_figma_mcp/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist",
    "rootDir": ".",
    "declaration": true,
    "experimentalDecorators": false,
    "emitDecoratorMetadata": false
  },
  "include": ["./**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/template-styles.js">
#!/usr/bin/env node

/**
 * Template Styles - 固化的模板样式常量
 * 
 * 基于"Group 1000015016"的样式分析结果，固化所有视觉规范
 * 避免运行时测量，确保样式一致性
 */

export const TEMPLATE_STYLES = {
  // 容器尺寸和位置常量
  CONTAINER: {
    baseX: 42859,           // 左对齐基准X位置
    contentWidth: 1604,     // 内容区域宽度
    verticalSpacing: {
      betweenGroups: 60,    // 组间距
      betweenItems: 20,     // 组内元素间距
      titleToImage: 0,      // 标题到图片距离(紧贴)
      imageToSource: 40,    // 图片到来源距离
      sourceToNext: 60      // 来源到下一组距离
    }
  },

  // 图片样式
  IMAGE: {
    width: 1604,
    scaleMode: "FILL",
    fills: [{
      type: "IMAGE",
      blendMode: "NORMAL"
    }],
    // 多图布局时的宽度计算
    multiImage: {
      spacing: 20,          // 图片间距
      getWidth: (count) => Math.floor((1604 - (count - 1) * 20) / count)
    }
  },

  // 标题样式 (GROUP + RECTANGLE + TEXT)
  TITLE: {
    background: {
      fills: [{
        type: "SOLID",
        color: { r: 0, g: 70/255, b: 108/255 },  // #00476c
        blendMode: "NORMAL"
      }],
      width: 1604,
      height: {
        single: 140,        // 单行标题高度
        double: 240         // 双行标题高度  
      }
    },
    text: {
      fills: [{
        type: "SOLID", 
        color: { r: 1, g: 1, b: 1 },             // #ffffff
        blendMode: "NORMAL"
      }],
      fontFamily: "Source Han Sans CN",
      fontStyle: "Bold", 
      fontWeight: 700,
      fontSize: 64,
      textAlignHorizontal: "LEFT",
      letterSpacing: 0,
      lineHeightPx: 100,
      // 内边距
      padding: {
        left: 11.890625,    // 从分析结果得出
        top: 33.828125,
        right: 11.890625,
        bottom: 33.828125
      }
    }
  },

  // 来源样式 (TEXT)
  SOURCE: {
    fills: [{
      type: "SOLID",
      color: { r: 153/255, g: 153/255, b: 153/255 },  // #999999
      blendMode: "NORMAL"
    }],
    fontFamily: "DIN Pro",
    fontStyle: "Bold",
    fontWeight: 700,
    fontSize: 50,
    textAlignHorizontal: "LEFT", 
    letterSpacing: 0,
    lineHeightPx: 64.4,
    textAutoResize: "HEIGHT"
  },

  // 正文段落样式 (TEXT)
  PARAGRAPH: {
    fills: [{
      type: "SOLID",
      color: { r: 219/255, g: 219/255, b: 219/255 },  // #dbdbdb
      blendMode: "NORMAL"
    }],
    strokes: [{
      type: "SOLID", 
      color: { r: 0, g: 0, b: 0 },                    // #000000
      blendMode: "NORMAL"
    }],
    fontFamily: "Source Han Sans CN",
    fontStyle: "Bold",
    fontWeight: 700, 
    fontSize: 66,
    textAlignHorizontal: "LEFT",
    letterSpacing: 0,
    lineHeightPx: 110,
    textAutoResize: "HEIGHT"
  },

  // Auto Layout 容器样式
  AUTO_LAYOUT: {
    // 主内容组容器 (VERTICAL)
    contentGroup: {
      layoutMode: "VERTICAL",
      itemSpacing: 60,                    // 组间距
      paddingLeft: 0,
      paddingRight: 0, 
      paddingTop: 0,
      paddingBottom: 0,
      primaryAxisAlignItems: "MIN",       // 顶对齐
      counterAxisAlignItems: "MIN",       // 左对齐
      layoutSizingHorizontal: "FIXED",    // 固定宽度
      layoutSizingVertical: "HUG"         // 高度自适应内容
    },

    // 图片组容器 (VERTICAL)
    figureGroup: {
      layoutMode: "VERTICAL", 
      itemSpacing: 20,                    // 元素间距
      paddingLeft: 0,
      paddingRight: 0,
      paddingTop: 0, 
      paddingBottom: 0,
      primaryAxisAlignItems: "MIN",       // 顶对齐
      counterAxisAlignItems: "MIN",       // 左对齐  
      layoutSizingHorizontal: "FIXED",    // 固定宽度
      layoutSizingVertical: "HUG"         // 高度自适应
    },

    // 图片行容器 (HORIZONTAL/VERTICAL)
    imageContainer: {
      horizontal: {
        layoutMode: "HORIZONTAL",
        itemSpacing: 20,                  // 图片间距
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        primaryAxisAlignItems: "MIN",     // 左对齐
        counterAxisAlignItems: "MIN",     // 顶对齐
        layoutSizingHorizontal: "FIXED", // 固定宽度
        layoutSizingVertical: "HUG"      // 高度自适应
      },
      vertical: {
        layoutMode: "VERTICAL", 
        itemSpacing: 20,                  // 图片间距
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        primaryAxisAlignItems: "MIN",     // 顶对齐
        counterAxisAlignItems: "MIN",     // 左对齐
        layoutSizingHorizontal: "FIXED", // 固定宽度
        layoutSizingVertical: "HUG"      // 高度自适应
      }
    }
  },

  // 背景调整参数
  BACKGROUND: {
    nodeId: "6:5403",           // BackgroundFrame ID
    topPadding: 120,            // 内容上方留白
    bottomPadding: 120          // 内容下方留白
  }
};

/**
 * 计算标题背景高度 - 根据文本行数
 * @param {number} lineCount - 文本行数
 * @returns {number} 背景高度
 */
export function getTitleHeight(lineCount) {
  return lineCount <= 1 ? 
    TEMPLATE_STYLES.TITLE.background.height.single : 
    TEMPLATE_STYLES.TITLE.background.height.double;
}

/**
 * 计算多图布局中单图宽度
 * @param {number} imageCount - 图片数量
 * @returns {number} 单图宽度
 */
export function getImageWidth(imageCount) {
  if (imageCount === 1) {
    return TEMPLATE_STYLES.IMAGE.width;
  }
  return TEMPLATE_STYLES.IMAGE.multiImage.getWidth(imageCount);
}

/**
 * 获取容器位置信息
 * @param {number} yOffset - Y轴偏移
 * @returns {Object} 位置信息
 */
export function getContainerPosition(yOffset = 0) {
  return {
    x: TEMPLATE_STYLES.CONTAINER.baseX,
    y: yOffset,
    width: TEMPLATE_STYLES.CONTAINER.contentWidth
  };
}

export default TEMPLATE_STYLES;
</file>

<file path="src/workflow_automation.js">
#!/usr/bin/env node

/**
 * End-to-End Workflow Automation: DOCX to Figma Poster
 * 
 * This script processes content.json data and applies it to Figma template
 * using the MCP tools through WebSocket communication.
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const CONFIG = {
  contentPath: path.join(__dirname, '../docx2json/content.json'),
  nodeMappingPath: path.join(__dirname, '../config/node_name_map.json'),
  runStatePath: path.join(__dirname, '../config/run_state.json'),
  assetsPath: path.join(__dirname, '../docx2json/assets/media'),
  
  // WebSocket connection (this would need to be implemented)
  websocketUrl: 'ws://localhost:3055',
  channel: 'rdgea13n', // Current active channel
};

class FigmaWorkflowAutomator {
  constructor() {
    this.contentData = null;
    this.nodeMapping = null;
    this.runState = null;
    this.processedGroups = 0;
  }

  async initialize() {
    console.log('🚀 Initializing Figma Workflow Automator...');
    
    // Load configuration files
    this.contentData = JSON.parse(await fs.readFile(CONFIG.contentPath, 'utf8'));
    this.nodeMapping = JSON.parse(await fs.readFile(CONFIG.nodeMappingPath, 'utf8'));
    this.runState = JSON.parse(await fs.readFile(CONFIG.runStatePath, 'utf8'));
    
    console.log(`📄 Loaded content with ${this.contentData.blocks.length} blocks`);
    console.log(`🗺️ Loaded node mapping with ${Object.keys(this.nodeMapping.nodes).length} base nodes`);
    console.log(`📊 Current run state: ${this.runState.current_phase}`);
  }

  async processWorkflow() {
    console.log('\n🔄 Starting end-to-end workflow processing...');
    
    // Update run state
    this.runState.execution_started_at = new Date().toISOString();
    this.runState.current_phase = 'workflow_execution';
    await this.updateRunState();
    
    // Group content blocks by group_id
    const contentGroups = this.groupContentBlocks();
    console.log(`📦 Found ${Object.keys(contentGroups).length} content groups`);
    
    // Process each group
    let groupIndex = 0;
    for (const [groupId, groupBlocks] of Object.entries(contentGroups)) {
      console.log(`\n📝 Processing ${groupId} (${groupIndex + 1}/${Object.keys(contentGroups).length})`);
      await this.processContentGroup(groupId, groupBlocks, groupIndex);
      
      groupIndex++;
      this.runState.last_processed_group_index = groupIndex - 1;
      await this.updateRunState();
    }
    
    console.log('\n✅ Workflow processing completed!');
    this.runState.current_phase = 'completed';
    await this.updateRunState();
  }

  groupContentBlocks() {
    const groups = {};
    
    for (const block of this.contentData.blocks) {
      if (block.group_id) {
        if (!groups[block.group_id]) {
          groups[block.group_id] = [];
        }
        groups[block.group_id].push(block);
      }
    }
    
    return groups;
  }

  async processContentGroup(groupId, blocks, groupIndex) {
    const { images, title_groups, sources, paragraphs } = this.nodeMapping.content_elements;
    
    for (const block of blocks) {
      switch (block.type) {
        case 'figure':
          await this.processFigureBlock(block, groupIndex, images, title_groups, sources);
          break;
        case 'paragraph':
          await this.processParagraphBlock(block, groupIndex, paragraphs);
          break;
        default:
          console.warn(`⚠️  Unknown block type: ${block.type}`);
      }
    }
  }

  async processFigureBlock(block, groupIndex, images, titleGroups, sources) {
    console.log(`  🖼️  Processing figure: ${block.title}`);
    
    // Map image using set_image_fill
    if (block.image && images[groupIndex]) {
      const imageNode = images[groupIndex];
      const imagePath = path.join(CONFIG.assetsPath, `${block.image.asset_id}.png`);
      
      try {
        const imageBase64 = await this.loadImageAsBase64(imagePath);
        console.log(`    📁 Loading image: ${block.image.asset_id}`);
        // TODO: Call MCP set_image_fill tool
        console.log(`    ✅ Would call set_image_fill for node ${imageNode.id}`);
      } catch (error) {
        console.error(`    ❌ Failed to load image ${imagePath}:`, error.message);
      }
    }
    
    // Map title using set_text_content  
    if (block.title && titleGroups[groupIndex]) {
      const titleNode = titleGroups[groupIndex];
      console.log(`    📝 Setting title: ${block.title.substring(0, 30)}...`);
      // TODO: Call MCP set_text_content tool
      console.log(`    ✅ Would call set_text_content for node ${titleNode.id}`);
    }
    
    // Map credit using set_text_content
    if (block.credit && sources[groupIndex]) {
      const sourceNode = sources[groupIndex];
      console.log(`    📄 Setting source: ${block.credit}`);
      // TODO: Call MCP set_text_content tool  
      console.log(`    ✅ Would call set_text_content for node ${sourceNode.id}`);
    }
  }

  async processParagraphBlock(block, groupIndex, paragraphs) {
    console.log(`  📄 Processing paragraph: ${block.text.substring(0, 50)}...`);
    
    if (paragraphs[groupIndex]) {
      const paragraphNode = paragraphs[groupIndex];
      // TODO: Call MCP set_text_content tool
      console.log(`    ✅ Would call set_text_content for node ${paragraphNode.id}`);
    }
  }

  async loadImageAsBase64(imagePath) {
    try {
      const imageBuffer = await fs.readFile(imagePath);
      const base64Data = imageBuffer.toString('base64');
      return `data:image/png;base64,${base64Data}`;
    } catch (error) {
      throw new Error(`Cannot load image: ${imagePath}`);
    }
  }

  async updateRunState() {
    await fs.writeFile(CONFIG.runStatePath, JSON.stringify(this.runState, null, 2));
  }
}

// Main execution
async function main() {
  try {
    const automator = new FigmaWorkflowAutomator();
    await automator.initialize();
    await automator.processWorkflow();
  } catch (error) {
    console.error('💥 Workflow automation failed:', error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
</file>

<file path=".gitmodules">
[submodule "docx2json"]
	path = docx2json
	url = https://github.com/logicrw/docx2json.git
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- `src/talk_to_figma_mcp/` — TypeScript MCP server (entry: `server.ts`), bundled to `dist/` via tsup.
- `src/socket.ts` — Bun WebSocket relay; reads `config/server-config.json` for `host`/`port`.
- `src/cursor_mcp_plugin/` — Figma plugin (`manifest.json`, `code.js`, `ui.html`).
- `config/` — JSON config and mapping data (`server-config.json`, `node_name_map.json`, etc.). No secrets.
- `scripts/setup.sh` — Creates `.cursor/mcp.json` for quick MCP setup.
- `dist/` — Build output. Do not edit by hand.
- Root test scripts — e.g., `test_*.js`, `quick_test.js` for manual E2E checks.

## Build, Test, and Development Commands
- `bun install` — Install dependencies.
- `bun run build` — Bundle TypeScript to `dist/` (tsup).
- `bun run dev` — Watch + rebuild during development.
- `bun socket` — Start WebSocket server (uses `config/server-config.json`).
- `bun start` — Run MCP server from `dist/server.js` over stdio.
- `bun run setup` — Write `.cursor/mcp.json` pointing to published package.
- Maintainers: `bun run pub:release` — Build and `npm publish`.

## Coding Style & Naming Conventions
- TypeScript (ES2022, ESM, Node 18 target). Prefer named exports; camelCase for vars/functions.
- Indentation: 2 spaces. Keep diffs focused; avoid sweeping refactors.
- Filenames: follow existing patterns; new TS files use kebab-case under `src/`. Plugin remains plain JS.
- No ESLint/Prettier configured; mirror existing style. Add minimal TSDoc where helpful.

## Testing Guidelines
- No formal test framework. Use root scripts for E2E against a live Figma session.
- Example: `bun socket` → open Figma plugin → join channel → `node test_base_properties.js`.
- For changes, add/adjust a small script (e.g., `test_new_feature.js`) demonstrating behavior.

## Commit & Pull Request Guidelines
- Use Conventional Commits (e.g., `feat: …`, `fix: …`, `test: …`), consistent with history.
- PRs include: clear description, linked issues, reproduction steps, and screenshots/GIFs for plugin UX.
- Call out any config changes (e.g., `config/server-config.json`).

## Security & Config Tips
- Do not commit secrets. `server.ts` redacts sensitive fields; keep logs clean.
- Edit `config/server-config.json` for networking; prefer localhost defaults.
</file>

<file path="DRAGME.md">
# README for AI Agent: Cursor-Figma MCP Setup Guide

## 🤖 AI Agent Decision Flow

```mermaid
flowchart TD
    A[Start Setup] --> B{System Check}
    B -->|✅ Pass| C{Admin Access?}
    B -->|❌ Failed| Z[❌ Fix Prerequisites]
    
    C -->|✅ Yes| D[Method A: Full Install<br/>Homebrew + Bun]
    C -->|❌ No| E[Method B: Cursor-Only<br/>No System Changes]
    
    D --> F[Clone in Cursor]
    E --> F
    
    F --> G[Configure MCP]
    G --> H{MCP Connected?}
    H -->|✅ Yes| I[Start WebSocket]
    H -->|❌ No| J[Debug & Retry]
    
    I --> K[Install Figma Plugin]
    K --> L[Test Integration]
    L --> M[✅ Complete]
    
    J --> H
```

## 🎯 Objective

Install and configure Cursor-Figma MCP integration with **AI-agent-friendly decision trees** and fail-safe checkpoints at each step. This guide uses Cursor's built-in Git clone functionality to directly clone the official repository, simplifying the setup process.

### 🤖 For AI Agents Reading This Guide

This guide is **specifically designed for AI agents** to understand, parse, and execute setup instructions autonomously. Each section includes:

- **Clear boolean decision points** for branching logic
- **Explicit command verification steps** with expected outputs  
- **Fallback strategies** when primary methods fail
- **Environment-specific instructions** based on system capabilities
- **Checkpoint validations** before proceeding to next steps

**AI Agent Instructions**: 
1. Execute each command and verify the expected output
2. Follow the branching logic based on system environment
3. If any step fails, use the provided fallback methods
4. Always validate checkpoints before continuing
5. **CRITICAL**: Create and update visual progress tracking using Mermaid diagrams at each major checkpoint

## 📋 System Environment Detection

**CRITICAL FOR AI AGENTS**: Execute these detection commands and use results for branching decisions.

```bash
# System Detection Commands - Execute ALL and store results
echo "=== SYSTEM ENVIRONMENT DETECTION ==="

# 1. Operating System Check
OS_TYPE=$(uname -s)
echo "OS_TYPE: $OS_TYPE"

# 2. Shell Type Detection  
echo "SHELL_TYPE: $SHELL"

# 3. Homebrew Availability
HOMEBREW_AVAILABLE=$(which brew >/dev/null 2>&1 && echo "YES" || echo "NO")
echo "HOMEBREW_AVAILABLE: $HOMEBREW_AVAILABLE"

# 4. Node.js Availability
NODE_AVAILABLE=$(which node >/dev/null 2>&1 && echo "YES" || echo "NO")
if [ "$NODE_AVAILABLE" = "YES" ]; then
    NODE_VERSION=$(node --version 2>/dev/null || echo "UNKNOWN")
    echo "NODE_VERSION: $NODE_VERSION"
fi

# 5. Bun Availability
BUN_AVAILABLE=$(which bun >/dev/null 2>&1 && echo "YES" || echo "NO")
if [ "$BUN_AVAILABLE" = "YES" ]; then
    BUN_VERSION=$(bun --version 2>/dev/null || echo "UNKNOWN")
    echo "BUN_VERSION: $BUN_VERSION"
fi

# 6. Cursor IDE Availability
CURSOR_AVAILABLE=$(which cursor >/dev/null 2>&1 && echo "YES" || echo "NO")
echo "CURSOR_AVAILABLE: $CURSOR_AVAILABLE"

# 7. Git Availability
GIT_AVAILABLE=$(which git >/dev/null 2>&1 && echo "YES" || echo "NO")
if [ "$GIT_AVAILABLE" = "YES" ]; then
    GIT_VERSION=$(git --version 2>/dev/null || echo "UNKNOWN")
    echo "GIT_VERSION: $GIT_VERSION"
fi

# 8. Admin/Sudo Access Check
SUDO_AVAILABLE=$(sudo -n true 2>/dev/null && echo "YES" || echo "NO")
echo "SUDO_AVAILABLE: $SUDO_AVAILABLE"

echo "=== DETECTION COMPLETE ==="
```

## 📊 AI Agent Progress Tracking Templates

**MANDATORY FOR AI AGENTS**: Use these Mermaid templates to show progress at each checkpoint.

### 🎯 Progress Status Template

Use these exact status indicators:
- ✅ **COMPLETED** - Step finished successfully
- 🔄 **CURRENT** - Currently executing this step  
- ⏳ **PENDING** - Not started yet
- ❌ **FAILED** - Step failed, needs attention
- ⚠️ **WARNING** - Step completed with warnings

### 📋 Standard Progress Tracking Template

**AI AGENTS MUST CREATE THIS DIAGRAM** after environment detection and update it at each checkpoint:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
    classDef failed fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
    classDef warning fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
```

### 🎨 How to Update Progress Status

**AI Agents must use this exact format** at each checkpoint:

```
## 📊 Current Progress Status

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    class A completed
    class B current
    class C,D,E,F,G,H pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
    classDef failed fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
    classDef warning fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
```



### 🛠️ Method-Specific Progress Templates

#### For Method A (Full Installation):
```mermaid
graph LR
    A1[🍺 Homebrew Check] --> A2[📦 Install Dependencies]
    A2 --> A3[⚙️ MCP Setup]  
    A3 --> A4[✅ Ready for WebSocket]
```

#### For Method B (Cursor-Only):
```mermaid
graph LR
    B1[🖥️ Project Already Open] --> B2[📖 Setup Dependencies]
    B2 --> B3[⚙️ MCP Setup] 
    B3 --> B4[✅ Ready for WebSocket]
```

### 📍 Mandatory Progress Update Points

**AI Agents MUST update progress diagram at these checkpoints:**

1. **After Environment Detection** (Step 1)
2. **After Method Selection** (Step 2)  
3. **After Dependency Installation** (Step 3)
4. **After MCP Setup and Configuration** (Step 4)
5. **After WebSocket Start** (Step 5)
6. **After Figma Plugin Install** (Step 6)
7. **After Integration Test** (Step 7)
8. **Final Completion** (Step 8)

### 🤖 AI Agent Progress Update Commands

**Use these exact commands at each checkpoint:**

```
CHECKPOINT [STEP_NUMBER]: [STEP_NAME]

Please create/update the progress tracking diagram to show:
- Current step: [STEP_NAME] 
- Status: [✅ COMPLETED / 🔄 CURRENT / ❌ FAILED]
- Next step: [NEXT_STEP_NAME]
- Any warnings or issues encountered

Update the Mermaid diagram with appropriate class assignments and show the overall progress percentage.
```

### 🤖 AI Agent Decision Logic

Based on the detection results above, AI agents should follow this decision tree:

```bash
# AI Agent Decision Variables (set based on detection above)
HOMEBREW_AVAILABLE="YES"  # or "NO"
NODE_AVAILABLE="YES"      # or "NO" 
BUN_AVAILABLE="YES"       # or "NO"
CURSOR_AVAILABLE="YES"    # or "NO"
SUDO_AVAILABLE="YES"      # or "NO"
```

**Decision Tree**:
- IF `HOMEBREW_AVAILABLE="YES"` AND `SUDO_AVAILABLE="YES"` → **Method A1: Homebrew Installation**
- ELIF `SUDO_AVAILABLE="YES"` AND `HOMEBREW_AVAILABLE="NO"` → **Method A2: Direct Installation**  
- ELIF `CURSOR_AVAILABLE="YES"` AND `SUDO_AVAILABLE="NO"` → **Method B: Cursor-Only Setup**
- ELSE → **Error: Insufficient System Access**

## 🛡️ Method Selection Based on Environment

### 🌟 Method A1: Homebrew Installation (Recommended)
**Conditions**: `HOMEBREW_AVAILABLE="YES"` AND `SUDO_AVAILABLE="YES"`
- Uses Homebrew package manager
- Cleanest dependency management
- Best for macOS systems with Homebrew

### 🔧 Method A2: Direct Installation  
**Conditions**: `SUDO_AVAILABLE="YES"` AND `HOMEBREW_AVAILABLE="NO"`
- Direct installation without package manager
- For systems without Homebrew but with admin access
- Manual dependency management

### 📱 Method B: Cursor-Only Setup
**Conditions**: `CURSOR_AVAILABLE="YES"` AND `SUDO_AVAILABLE="NO"`
- No system-wide installations
- Uses Cursor's built-in capabilities
- For restricted environments

---

## 🚀 Method A1: Homebrew Installation

### 📊 Progress Tracking for Method A1

**AI AGENTS**: Start by creating initial progress diagram:

```
CHECKPOINT 1: STARTING METHOD A1 - HOMEBREW INSTALLATION

Please create the Method A1 progress tracking diagram:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A1 Selected]
    B --> C[🍺 Homebrew Check] 
    C --> D[📦 Install Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A completed
    class B current
    class C,D,E,F pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Prerequisites Check for Method A1
```bash
# Verify Homebrew functionality
brew --version && echo "✅ Homebrew functional" || echo "❌ ERROR: Homebrew broken"

# Check brew permissions
brew doctor && echo "✅ Homebrew healthy" || echo "⚠️ WARNING: Homebrew has issues"
```

### Step A1.1: Install Dependencies via Homebrew

```bash
# Update Homebrew first
brew update

# Install Node.js if not available
if [ "$NODE_AVAILABLE" = "NO" ]; then
    echo "Installing Node.js via Homebrew..."
    brew install node
    NODE_AVAILABLE="YES"
    NODE_VERSION=$(node --version)
    echo "✅ Node.js installed: $NODE_VERSION"
else
    echo "✅ Node.js already available: $NODE_VERSION"
fi

# Install Bun if not available  
if [ "$BUN_AVAILABLE" = "NO" ]; then
    echo "Installing Bun via Homebrew..."
    brew install bun
    BUN_AVAILABLE="YES"
    BUN_VERSION=$(bun --version)
    echo "✅ Bun installed: $BUN_VERSION"
else
    echo "✅ Bun already available: $BUN_VERSION"
fi

# Verify installations
echo "=== DEPENDENCY VERIFICATION ==="
node --version && echo "✅ Node.js working"
bun --version && echo "✅ Bun working"  
git --version && echo "✅ Git working"
which cursor && echo "✅ Cursor available" || echo "❌ Install Cursor IDE manually"
```

**CHECKPOINT A1.1**: All dependencies must show ✅ before proceeding.

**AI AGENTS**: Update progress after dependency installation:

```
CHECKPOINT 2: DEPENDENCIES INSTALLED

Update Method A1 progress - mark Homebrew Check and Dependencies as completed:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A1 Selected]
    B --> C[🍺 Homebrew Check] 
    C --> D[📦 Install Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A,B,C,D completed
    class E current
    class F pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Step A1.2: MCP Setup via Homebrew Method

**🎯 Project is already cloned and open in Cursor IDE**

1. **Verify project structure**:

```bash
# Verify current directory (should already be in cursor-talk-to-figma-mcp)
pwd | grep "cursor-talk-to-figma-mcp" && echo "✅ Correct directory" || echo "❌ ERROR: Wrong directory"

# Verify project structure
ls package.json src && echo "✅ Project structure valid" || echo "❌ ERROR: Invalid project structure"

# Install dependencies and setup
bun install
bun run build

# Run setup (this configures MCP automatically)
bun setup && echo "✅ Setup complete" || echo "❌ ERROR: Setup failed"

# Verify MCP config was created
test -f .cursor/mcp.json && echo "✅ MCP config created" || echo "❌ ERROR: MCP config missing"
```

**AI AGENTS**: Update progress after Method A1 completion:

```
CHECKPOINT 3: METHOD A1 COMPLETE

Method A1 fully completed, ready for common steps:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A1 Selected]
    B --> C[🍺 Homebrew Check] 
    C --> D[📦 Install Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A,B,C,D,E,F completed
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
```

Progress: Method A1 100% Complete ✅ - Proceeding to Common Steps
```

**Continue to Common Steps below.**

---

## 🔧 Method A2: Direct Installation

### 📊 Progress Tracking for Method A2

**AI AGENTS**: Start by creating Method A2 progress diagram:

```
CHECKPOINT 1: STARTING METHOD A2 - DIRECT INSTALLATION

Please create the Method A2 progress tracking diagram:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A2 Selected]
    B --> C[⚡ Install Bun Direct] 
    C --> D[⚙️ MCP Setup]
    D --> E[🚀 Ready for WebSocket]
    
    class A completed
    class B current
    class C,D,E pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Prerequisites Check for Method A2
```bash
# Verify we have sudo access but no Homebrew
[ "$SUDO_AVAILABLE" = "YES" ] && echo "✅ Sudo access confirmed" || exit 1
[ "$HOMEBREW_AVAILABLE" = "NO" ] && echo "✅ Direct installation path confirmed" || echo "⚠️ Homebrew available, consider Method A1"
```

### Step A2.1: Install Bun Directly

```bash
# Install Bun directly (requires internet access)
curl -fsSL https://bun.sh/install | bash

# Reload shell environment 
if [[ "$SHELL" == *"zsh"* ]]; then
    source ~/.zshrc 2>/dev/null || echo "⚠️ No .zshrc found"
    echo "🐚 Using Zsh shell"
elif [[ "$SHELL" == *"bash"* ]]; then
    source ~/.bashrc 2>/dev/null || source ~/.bash_profile 2>/dev/null || echo "⚠️ No .bashrc or .bash_profile found"
    echo "🐚 Using Bash shell"
fi

# Verify installation
bun --version && echo "✅ Bun installed successfully" || echo "❌ ERROR: Bun installation failed"
BUN_AVAILABLE="YES"
BUN_VERSION=$(bun --version)
```

**AI AGENTS**: Update progress after Bun installation:

```
CHECKPOINT 2: BUN INSTALLED DIRECTLY

Update Method A2 progress - Bun installation completed:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A2 Selected]
    B --> C[⚡ Install Bun Direct] 
    C --> D[⚙️ MCP Setup]
    D --> E[🚀 Ready for WebSocket]
    
    class A,B,C completed
    class D current
    class E pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Step A2.2: MCP Setup via Direct Method

**🎯 Project is already cloned and open in Cursor IDE**

1. **Verify project setup**:

```bash
# Verify current directory (should already be in cursor-talk-to-figma-mcp)
pwd | grep "cursor-talk-to-figma-mcp" && echo "✅ Correct directory" || echo "❌ ERROR: Wrong directory"

# Verify and setup
ls package.json src && echo "✅ Project structure valid" || echo "❌ ERROR: Invalid project structure"
bun install
bun run build
bun setup && echo "✅ Setup complete" || echo "❌ ERROR: Setup failed"
test -f .cursor/mcp.json && echo "✅ MCP config created" || echo "❌ ERROR: MCP config missing"
```

**AI AGENTS**: Update progress after Method A2 completion:

```
CHECKPOINT 3: METHOD A2 COMPLETE

Method A2 fully completed, ready for common steps:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method A2 Selected]
    B --> C[⚡ Install Bun Direct] 
    C --> D[⚙️ MCP Setup]
    D --> E[🚀 Ready for WebSocket]
    
    class A,B,C,D,E completed
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
```

Progress: Method A2 100% Complete ✅ - Proceeding to Common Steps
```

**Continue to Common Steps below.**

---

## 📱 Method B: Cursor-Only Setup

### 📊 Progress Tracking for Method B

**AI AGENTS**: Start by creating Method B progress diagram:

```
CHECKPOINT 1: STARTING METHOD B - CURSOR-ONLY SETUP

Please create the Method B progress tracking diagram:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method B Selected]
    B --> C[🖥️ Project Already Open] 
    C --> D[📖 Setup Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A completed
    class B current
    class C,D,E,F pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Prerequisites Check for Method B
```bash
# Verify Cursor-only setup conditions
[ "$CURSOR_AVAILABLE" = "YES" ] && echo "✅ Cursor IDE available" || echo "❌ ERROR: Install Cursor IDE first"
[ "$SUDO_AVAILABLE" = "NO" ] && echo "✅ Restricted environment confirmed" || echo "⚠️ Admin access available, consider Method A"
```

### Step B.1: Verify Project is Open in Cursor

**🎯 Project is already cloned and open in Cursor IDE**

1. **Verify project is properly loaded**:
   - Confirm Cursor IDE has the project open
   - Open terminal in Cursor: `Terminal > New Terminal` (or `Ctrl+Shift+`)

### Step B.2: Setup Dependencies in Cursor

```bash
# Verify current directory (should already be in cursor-talk-to-figma-mcp)
pwd | grep "cursor-talk-to-figma-mcp" && echo "✅ Correct directory" || echo "❌ ERROR: Wrong directory"

# Verify project structure
ls package.json src && echo "✅ Project structure valid" || echo "❌ ERROR: Invalid project structure"
```

**AI AGENTS**: Update progress after project cloning:

```
CHECKPOINT 2: PROJECT CLONED IN CURSOR

Update Method B progress - project cloned successfully:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method B Selected]
    B --> C[🖥️ Project Already Open] 
    C --> D[📖 Setup Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A,B,C,D completed
    class E current
    class F pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```
```

### Step B.3: Follow README Setup in Cursor

**📖 CRITICAL FOR AI AGENTS**: Ask the AI assistant in Cursor to read and execute the README:

```
Please read the @readme.md file and help me set up this project by following the installation instructions step by step.

IMPORTANT: For each step in the setup process, please:
1. Create a Mermaid flowchart showing the complete installation process
2. Highlight which step we're currently on  
3. Show what steps are completed, current, and upcoming
4. Include brief descriptions of what each step does
5. Update the diagram as we progress through each step

Use this Mermaid template structure:
- Use different colors/styles to show: ✅ Completed, 🔄 Current, ⏳ Upcoming  
- Include step numbers and brief descriptions
- Show the flow from Prerequisites → Installation → Configuration → Testing
- Make it visually clear where we are in the process

This will help track overall progress and determine next steps at each stage.
```

**AI AGENTS**: Update progress after Method B completion:

```
CHECKPOINT 3: METHOD B COMPLETE

Method B fully completed, ready for common steps:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method B Selected]
    B --> C[🖥️ Project Already Open] 
    C --> D[📖 Setup Dependencies]
    D --> E[⚙️ MCP Setup]
    E --> F[🚀 Ready for WebSocket]
    
    class A,B,C,D,E,F completed
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
```

Progress: Method B 100% Complete ✅ - Proceeding to Common Steps
```

**Continue to Common Steps below.**

---

## 🔗 Common Steps (All Methods)

### Step C.1: Verify MCP Configuration

**🚨 CRITICAL FOR AI AGENTS**: Project is already cloned and open in Cursor.

```bash
# Verify current directory (should already be in cursor-talk-to-figma-mcp)
pwd | grep "cursor-talk-to-figma-mcp" && echo "✅ Correct directory" || echo "❌ ERROR: Wrong directory"

# Verify project structure
ls package.json src && echo "✅ Project structure valid" || echo "❌ ERROR: Invalid project structure"

# Verify MCP config exists (created by bun setup)
if [ -f ".cursor/mcp.json" ]; then
    echo "✅ MCP config found"
else
    echo "⚠️ MCP config not found - running setup..."
    bun setup
fi

echo "✅ Project verified - MCP should be configured"
```

**CHECKPOINT C.1**: Verify in Cursor:
1. Open Settings (`Cmd+,` on Mac, `Ctrl+,` on Windows/Linux)
2. Search "MCP"  
3. Confirm "TalkToFigma" shows as "Connected"

**AI AGENTS**: Update overall progress after Cursor launch:

```
CHECKPOINT 3: MCP SETUP AND CONFIGURATION COMPLETE

Update overall progress - MCP setup and configured:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    class A,B,C,D completed
    class E current
    class F,G,H pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```

Progress: 50% Complete - MCP Configured ✅ - Starting WebSocket Server
```

### Step C.2: Start WebSocket Server

To ensure stability and easy monitoring, we will run the WebSocket server in the foreground. This is the recommended method as it dedicates a terminal to the server, confirming it's always running, and saves all logs to a file for later review.

**How to Start and Monitor the Server:**

1.  **Start the Server**: Open a new terminal in Cursor and run the following command. The terminal will become unresponsive, which means the server is running correctly.
    ```bash
    # Runs the server in the foreground and saves all logs to websocket.log
    bun socket > websocket.log 2>&1
    ```

2.  **Monitor Logs**: To see server activity, open a *second* terminal and use this command for a live feed of the logs:
    ```bash
    tail -f websocket.log
    ```
    You can also simply open the `websocket.log` file to view its contents.

3.  **Stop the Server**: To stop the server, go to its dedicated terminal window and press `Ctrl + C`.

**CHECKPOINT C.2**: The server terminal should be active (and unresponsive). You should see a "WebSocket server running on port 3055" message at the beginning of the `websocket.log` file. **Keep the server terminal open.**

### 🔍 Verify WebSocket Server Status

**🚨 CRITICAL FOR AI AGENTS**: Use Cursor's `@Terminals` to monitor WebSocket server status:

1. **Check Active Terminals**:
   - In Cursor, type `@Terminals` in chat
   - This will show all currently running terminal processes
   - Verify you can see the WebSocket server terminal running
   - Confirm the server shows "WebSocket server running on port 3055" message

2. **Verify Server is Active**:
   ```bash
   # In a new terminal (don't close the WebSocket terminal!)
   curl -I http://localhost:3055 2>/dev/null && echo "✅ WebSocket server responding" || echo "❌ Server not responding"
   
   # Check port status
   lsof -i :3055 && echo "✅ Port 3055 in use by WebSocket server" || echo "❌ Port 3055 not in use"
   ```

3. **Monitor Server Logs**:
   - Keep the WebSocket terminal visible in Cursor
   - Watch for connection messages when Figma plugin connects
   - Server logs will show plugin connection status in real-time

**⚠️ IMPORTANT**: Do NOT close the WebSocket terminal - it must stay running throughout the entire Figma integration session.

**AI AGENTS**: Update progress after WebSocket server start:

```
CHECKPOINT 4: WEBSOCKET SERVER RUNNING

Update progress - WebSocket server successfully started:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    class A,B,C,D,E completed
    class F current
    class G,H pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```

Progress: 63% Complete - WebSocket Running ✅ - Installing Figma Plugin
```

### Step C.3: Install and Configure Figma Plugin

#### 🔌 Install the Community Plugin

1. **Open the Plugin Page**:
   - Navigate to: https://www.figma.com/community/plugin/1485687494525374295/cursor-talk-to-figma-mcp-plugin
   - Click **"Install"** to add the plugin to your Figma account

2. **Open Figma and Run the Plugin**:
   - Open any Figma file (or create a new one)
   - Go to `Plugins` menu → `Cursor Talk to Figma MCP Plugin`
   - The plugin panel will open

#### ⚙️ Configure Plugin to Connect to Local WebSocket

**🚨 CRITICAL**: The plugin needs to connect to your local WebSocket server:

1. **In the Plugin Panel**:
   - Look for **"WebSocket URL"** or **"Server URL"** setting
   - Change the URL from default to: `ws://localhost:3055`
   - Click **"Connect"** or **"Save"** to apply the setting

2. **Verify Connection**:
   - The plugin should show **"Connected"** status
   - You should see green indicator or success message in the plugin

#### 📡 Monitor Connection Status Using @Terminals

**🔍 IMPORTANT FOR AI AGENTS**: Use Cursor's `@Terminals` to verify the plugin connection:

1. **Check WebSocket Server Logs**:
   - In Cursor, type `@Terminals` in chat
   - Look at the WebSocket server terminal
   - When plugin connects successfully, you should see log messages like:
     ```
     ✅ New WebSocket connection from Figma plugin
     ✅ Plugin connected successfully
     ✅ Handshake completed
     ```

2. **Connection Troubleshooting**:
   - If no connection messages appear in server logs, the plugin is not connecting properly
   - Check that WebSocket URL in plugin is set to `ws://localhost:3055`
   - Verify the WebSocket server is still running (check `@Terminals`)
   - Try refreshing the Figma page and reconnecting the plugin

**AI AGENTS**: Update progress after Figma plugin installation:

```
CHECKPOINT 5: FIGMA PLUGIN INSTALLED

Update progress - Figma plugin successfully installed:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    class A,B,C,D,E,F completed
    class G current
    class H pending
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
    classDef current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    classDef pending fill:#6b7280,stroke:#4b5563,stroke-width:2px,color:#fff
```

Progress: 75% Complete - Plugin Installed ✅ - Running Integration Tests
```

### Step C.4: Test Integration

#### 🧪 Test MCP Commands in Cursor

**In Cursor (where MCP is connected):**

```bash
# Test 1: MCP Connection
join_channel
# Expected: "Successfully joined channel" message

# Test 2: Figma Communication  
get_document_info
# Expected: JSON data from Figma document
```

#### 📋 Verify Complete Integration Using @Terminals

**🔍 FINAL VERIFICATION FOR AI AGENTS**:

1. **Check All Active Processes**:
   - In Cursor, type `@Terminals` in chat
   - Verify you can see:
     - ✅ **WebSocket server terminal** still running with "WebSocket server running on port 3055"
     - ✅ **Connection logs** showing Figma plugin is connected
     - ✅ **MCP status** showing TalkToFigma as connected

2. **Test End-to-End Communication**:
   ```bash
   # In Cursor chat, test these MCP commands:
   get_document_info
   get_selection
   ```
   - Commands should return JSON data from your Figma document
   - Check `@Terminals` - WebSocket logs should show command activity
   - Figma plugin should show activity/response indicators

3. **Integration Status Checklist**:
   - ✅ WebSocket server running (visible in `@Terminals`)
   - ✅ Figma plugin connected (connection logs in server terminal)
   - ✅ MCP commands working (returns Figma data)
   - ✅ No error messages in any terminals

**CHECKPOINT C.4**: All tests must pass and `@Terminals` should show healthy connections for successful setup.

**AI AGENTS**: Update progress after successful integration test:

```
CHECKPOINT 6: SETUP COMPLETE - INTEGRATION SUCCESSFUL

🎉 FINAL STATUS - All components working perfectly:

```mermaid
graph TD
    A[🔍 Environment Detection] --> B[📦 Method Selection]
    B --> C[⚡ Dependency Installation] 
    C --> D[⚙️ MCP setup and configuration]
    D --> E[🌐 WebSocket Server]
    E --> F[🔌 Figma Plugin]
    F --> G[🧪 Integration Test]
    G --> H[✅ Setup Complete]
    
    class A,B,C,D,E,F,G,H completed
    
    classDef completed fill:#22c55e,stroke:#16a34a,stroke-width:2px,color:#fff
```

🎯 **FINAL RESULT**: 100% Complete ✅
- ✅ Environment Detection Complete
- ✅ Method Successfully Executed  
- ✅ Dependencies Installed
- ✅ Project Cloned & Configured
- ✅ MCP Connected
- ✅ WebSocket Server Running
- ✅ Figma Plugin Active
- ✅ Integration Tests Passed
- ✅ **READY TO USE!**

**🚀 AI Agent can now assist with Figma design tasks through Cursor!**
```

---

## 🔍 AI Agent Troubleshooting Decision Tree

### Issue: Prerequisites Failed
```bash
# Decision tree for prerequisite failures
if [ "$CURSOR_AVAILABLE" = "NO" ]; then
    echo "❌ CRITICAL: Install Cursor IDE first - https://cursor.sh/"
    exit 1
elif [ "$GIT_AVAILABLE" = "NO" ]; then
    echo "❌ CRITICAL: Install Git first"
    exit 1
else
    echo "✅ Prerequisites satisfied, continue setup"
fi
```

### Issue: MCP Not Connected
```bash
# AI Agent debugging steps
echo "🔍 Debugging MCP connection..."

# Check if in correct project directory
if [ ! -f "package.json" ] || [ ! -d "src" ]; then
    echo "❌ Not in project directory"
    echo "💡 Please ensure you're in the cloned cursor-talk-to-figma-mcp directory"
    echo "💡 Use Cursor's File > Open Folder to open the cloned project"
    exit 1
fi

# Check if MCP config exists
if [ ! -f ".cursor/mcp.json" ]; then
    echo "⚠️ MCP config missing - running setup..."
    bun setup
fi

# Restart Cursor if needed
echo "💡 Restarting Cursor to reload MCP configuration..."
cursor .
sleep 5
```

### Issue: WebSocket Connection Failed  
```bash
# AI Agent network debugging
echo "🔍 Debugging WebSocket connection..."

# Step 1: Use @Terminals to check current state
echo "💡 First, type '@Terminals' in Cursor chat to see all running processes"
echo "💡 Look for WebSocket server terminal and check its status"

# Check if port is in use
if lsof -i :3055 >/dev/null 2>&1; then
    echo "⚠️ Port 3055 in use, killing existing process"
    lsof -ti:3055 | xargs kill -9 2>/dev/null || true
    sleep 2
fi

# Restart WebSocket server based on available runtime
if [ "$BUN_AVAILABLE" = "YES" ]; then
    echo "🚀 Starting WebSocket server with Bun..."
    bun socket
elif [ "$NODE_AVAILABLE" = "YES" ]; then
    echo "🚀 Starting WebSocket server with Node..."
    npm run socket || npx bun socket
else
    echo "❌ No suitable runtime for WebSocket server"
    exit 1
fi

echo "💡 After starting server, use '@Terminals' again to verify it's running"
echo "💡 Look for 'WebSocket server running on port 3055' message"
```

### Issue: Figma Plugin Not Connecting
```bash
# AI Agent plugin debugging  
echo "🔍 Debugging Figma plugin connection..."

echo "💡 Use '@Terminals' in Cursor to check WebSocket server logs"
echo "💡 You should see connection attempts from Figma plugin"

# Common plugin connection issues:
echo "🔧 Plugin Connection Checklist:"
echo "1. Plugin WebSocket URL set to 'ws://localhost:3055'"
echo "2. WebSocket server running (check '@Terminals')" 
echo "3. Figma plugin installed and activated"
echo "4. No firewall blocking localhost:3055"

echo "💡 In Figma plugin panel:"
echo "- Verify connection URL is 'ws://localhost:3055'"
echo "- Click disconnect/reconnect if needed"
echo "- Check for error messages in plugin"

echo "💡 Monitor '@Terminals' for real-time connection logs"
```

### Issue: Runtime Not Found
```bash
# AI Agent runtime fallback logic
echo "🔍 Attempting runtime fallback..."

if [ "$HOMEBREW_AVAILABLE" = "YES" ] && [ "$SUDO_AVAILABLE" = "YES" ]; then
    echo "Installing missing runtime via Homebrew..."
    brew install bun node
elif [ "$SUDO_AVAILABLE" = "YES" ]; then
    echo "Installing Bun directly..."
    curl -fsSL https://bun.sh/install | bash
    source ~/.zshrc 2>/dev/null || source ~/.bashrc 2>/dev/null || true
else
    echo "❌ Cannot install runtime in restricted environment"
    echo "💡 Try Method B: Cursor-Only Setup"
    exit 1
fi
```

---

## ✅ AI Agent Success Verification Matrix

**AI Agents should verify ALL conditions before marking setup as complete:**

### Environment Verification
```bash
echo "=== FINAL VERIFICATION MATRIX ==="

# System Environment
[ "$OS_TYPE" != "" ] && echo "✅ OS Detection: $OS_TYPE" || echo "❌ OS Detection Failed"

# Required Tools  
[ "$CURSOR_AVAILABLE" = "YES" ] && echo "✅ Cursor IDE Available" || echo "❌ Cursor Missing"
[ "$GIT_AVAILABLE" = "YES" ] && echo "✅ Git Available" || echo "❌ Git Missing"

# Runtime Environment
if [ "$BUN_AVAILABLE" = "YES" ]; then
    echo "✅ Bun Runtime: $BUN_VERSION"
elif [ "$NODE_AVAILABLE" = "YES" ]; then  
    echo "✅ Node.js Runtime: $NODE_VERSION"
else
    echo "❌ No Suitable Runtime Found"
fi

# Project Setup
[ -f ".cursor/mcp.json" ] && echo "✅ MCP Config Present" || echo "❌ MCP Config Missing"
[ -f "package.json" ] && echo "✅ Project Structure Valid" || echo "❌ Invalid Project"

# Process Status
if lsof -i :3055 >/dev/null 2>&1; then
    echo "✅ WebSocket Server Running (Port 3055)"
else
    echo "❌ WebSocket Server Not Running"
fi
```

### Functional Verification
**Execute in Cursor with MCP connected:**

1. **MCP Connection Test**: `join_channel` → Should return success message
2. **Figma Communication Test**: `get_document_info` → Should return JSON data
3. **Plugin Status**: Figma plugin should show as connected

### 🎉 Success Criteria
**ALL of the following must be true:**
- ✅ Environment detection completed without errors
- ✅ Appropriate method selected and executed based on system capabilities  
- ✅ Project successfully cloned and configured
- ✅ MCP configuration file present and valid
- ✅ Cursor IDE launched from project directory
- ✅ MCP shows "TalkToFigma" as "Connected" in settings
- ✅ WebSocket server running on port 3055 (verified via `@Terminals`)
- ✅ Figma plugin installed, configured with `ws://localhost:3055`, and connected
- ✅ Plugin connection visible in WebSocket server logs (check `@Terminals`)
- ✅ `join_channel` command works in Cursor
- ✅ `get_document_info` returns Figma document data
- ✅ All processes healthy and running (verified via `@Terminals`)

**If any criterion fails, AI agents should follow the troubleshooting decision tree above.**

---

## 🚀 AI Agent Quick Commands

### Recommended Setup (Use Cursor's Built-in Git Clone)
**AI AGENTS**: Instead of terminal commands, guide users to:

1. **Open Cursor IDE**
2. **Clone Repository**: Use `Cmd+Shift+P` → "Git: Clone"
3. **Enter URL**: `https://github.com/sonnylazuardi/cursor-talk-to-figma-mcp.git`
4. **Select location and clone**
5. **Open cloned project in Cursor**
6. **Run setup**: `bun setup`

### Alternative One-Line Commands (For Advanced Users)
```bash
# Method A1 (Homebrew) - Clone and auto-open in Cursor
[ "$HOMEBREW_AVAILABLE" = "YES" ] && cd ~/Desktop && git clone https://github.com/sonnylazuardi/cursor-talk-to-figma-mcp.git && cd cursor-talk-to-figma-mcp && brew install bun && bun setup && cursor .

# Method A2 (Direct) - Clone and auto-open in Cursor
[ "$SUDO_AVAILABLE" = "YES" ] && cd ~/Desktop && git clone https://github.com/sonnylazuardi/cursor-talk-to-figma-mcp.git && cd cursor-talk-to-figma-mcp && curl -fsSL https://bun.sh/install | bash && source ~/.zshrc && bun setup && cursor .

# Method B (Cursor-only) - Clone and open manually
[ "$CURSOR_AVAILABLE" = "YES" ] && cd ~/Desktop && git clone https://github.com/sonnylazuardi/cursor-talk-to-figma-mcp.git && echo "✅ Project cloned to ~/Desktop/cursor-talk-to-figma-mcp" && echo "💡 Open this folder in Cursor and run 'bun setup'"
```

### Service Management
```bash
# Start WebSocket Server (background)
nohup bun socket > websocket.log 2>&1 & echo $! > websocket.pid

# Stop WebSocket Server  
[ -f websocket.pid ] && kill $(cat websocket.pid) && rm websocket.pid

# Check Service Status
ps aux | grep -E "(bun socket|node.*socket)" || echo "WebSocket server not running"
```

### 📊 Monitor Services Using @Terminals

**🔍 RECOMMENDED FOR AI AGENTS**: Use Cursor's `@Terminals` for real-time monitoring:

1. **Check Active Services**:
   - Type `@Terminals` in Cursor chat anytime
   - Instantly see all running terminal processes
   - Verify WebSocket server status without additional commands

2. **Real-time Connection Monitoring**:
   - Watch WebSocket server logs for Figma plugin connections
   - See MCP command activity in real-time
   - Monitor for errors or disconnections

3. **Quick Health Check**:
   - `@Terminals` shows if WebSocket server is still running
   - Displays connection status and recent activity
   - No need for additional terminal commands

**Remember**: Always keep the WebSocket server running for the Figma plugin to communicate with Cursor! Use `@Terminals` to monitor its health.
</file>

<file path="mcp-config.json">
{
  "mcpServers": {
    "talk-to-figma": {
      "command": "node",
      "args": ["/Users/chenrongwei/Projects/cursor-talk-to-figma-mcp/dist/server.js"]
    }
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "strict": false,
    "skipLibCheck": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src",
    "lib": ["ES2022"],
    "types": ["bun-types"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="config/corrected_mapping_table.json">
{
  "mapping_correction_analysis": {
    "issue": "Content groups were mapped to Figma nodes by Y-coordinate order instead of content sequence order",
    "solution": "Map groups by content.json order to Figma nodes sorted by Y-coordinate ascending"
  },
  "correct_content_order": [
    {"group_id": "grp_0001", "title": "当前市场情绪", "asset": "img_76f7bfb095b6", "filename": "image1.png"},
    {"group_id": "grp_0002", "title": "通胀指标难以软化至2%目标以下", "asset": "img_167b6884e197", "filename": "image4.png"},
    {"group_id": "grp_0003", "title": "密西根大学通胀预期：短期与长期指标均意外上行", "asset": "img_09aa1fc6253d", "filename": "image5.png"},
    {"group_id": "grp_0004", "title": "财长贝森特近期宣称“中性”利率应低约150个基点", "asset": "img_b2b73f4d8b19", "filename": "image6.png"},
    {"group_id": "grp_0005", "title": "强劲PPI后，市场仅定价9月会议降息一次（25基点）的可能性低于90%", "asset": "img_88ea3fc64567", "filename": "image7.png"},
    {"group_id": "grp_0006", "title": "过去一周政府的SBR相关头条令市场失望", "asset": "img_baecaaa2d010", "filename": "image8.png"},
    {"group_id": "grp_0007", "title": null, "asset": "img_78ec0ebdafd6", "filename": "image9.png"},
    {"group_id": "grp_0008", "title": "BTC & ETH ETF 上周资金流入创纪录", "asset": "img_be731c0a03dc", "filename": "image10.png"},
    {"group_id": "grp_0009", "title": "主要由ETH流入激增170亿美元推动", "asset": "img_ec6b56b9b1ef", "filename": "image11.png"},
    {"group_id": "grp_0010", "title": "基金经理现金水准降至周期低点", "asset": "img_95a9764054d1", "filename": "image14.png"}
  ],
  "figma_nodes_by_y_coordinate": [
    {"rank": 1, "node_id": "6:6441", "name": "image 7311", "y": 2331},
    {"rank": 2, "node_id": "6:6442", "name": "image 7312", "y": 4116},
    {"rank": 3, "node_id": "6:6386", "name": "image 7310", "y": 5432},
    {"rank": 4, "node_id": "6:6443", "name": "image 7313", "y": 8150},
    {"rank": 5, "node_id": "6:6444", "name": "image 7314", "y": 10208},
    {"rank": 6, "node_id": "6:6445", "name": "image 7315", "y": 10795},
    {"rank": 7, "node_id": "6:6385", "name": "image 7309", "y": 12988},
    {"rank": 8, "node_id": "6:6384", "name": "image 7308", "y": 15455},
    {"rank": 9, "node_id": "6:6383", "name": "image 7307", "y": 15838},
    {"rank": 10, "node_id": "6:6382", "name": "image 7306", "y": 17417}
  ],
  "corrected_mapping": [
    {"group": "grp_0001", "title": "当前市场情绪", "filename": "image1.png", "node_id": "6:6441", "node_name": "image 7311"},
    {"group": "grp_0002", "title": "通胀指标难以软化至2%目标以下", "filename": "image4.png", "node_id": "6:6442", "node_name": "image 7312"},
    {"group": "grp_0003", "title": "密西根大学通胀预期：短期与长期指标均意外上行", "filename": "image5.png", "node_id": "6:6386", "node_name": "image 7310"},
    {"group": "grp_0004", "title": "财长贝森特近期宣称“中性”利率应低约150个基点", "filename": "image6.png", "node_id": "6:6443", "node_name": "image 7313"},
    {"group": "grp_0005", "title": "强劲PPI后，市场仅定价9月会议降息一次（25基点）的可能性低于90%", "filename": "image7.png", "node_id": "6:6444", "node_name": "image 7314"},
    {"group": "grp_0006", "title": "过去一周政府的SBR相关头条令市场失望", "filename": "image8.png", "node_id": "6:6445", "node_name": "image 7315"},
    {"group": "grp_0007", "title": null, "filename": "image9.png", "node_id": "6:6385", "node_name": "image 7309"},
    {"group": "grp_0008", "title": "BTC & ETH ETF 上周资金流入创纪录", "filename": "image10.png", "node_id": "6:6384", "node_name": "image 7308"},
    {"group": "grp_0009", "title": "主要由ETH流入激增170亿美元推动", "filename": "image11.png", "node_id": "6:6383", "node_name": "image 7307"},
    {"group": "grp_0010", "title": "基金经理现金水准降至周期低点", "filename": "image14.png", "node_id": "6:6382", "node_name": "image 7306"}
  ]
}
</file>

<file path="config/run_state.json">
{
  "current_phase": "phase6c_completed",
  "did_write_fixed_text": true,
  "last_processed_group_index": 9,
  "execution_started_at": "2025-08-31T08:57:00.000Z",
  "execution_completed_at": "2025-08-31T09:05:00.000Z",
  "total_groups": 10,
  "processing_status": "completed_successfully",
  "performance_metrics": {
    "start_time": "2025-08-31T08:57:00.000Z",
    "end_time": "2025-08-31T09:05:00.000Z",
    "total_duration_minutes": 8,
    "groups_completed": 10,
    "mcp_calls_total": 14,
    "mcp_calls_successful": 14,
    "errors_encountered": 0,
    "error_recovery_tests": 1,
    "average_call_latency_seconds": 1.2
  },
  "final_validation": {
    "all_images_filled": true,
    "smart_mapping_accuracy": "100%",
    "channel_stability": "stable",
    "quality_check": "passed"
  }
}
</file>

<file path="src/talk_to_figma_mcp/package.json">
{
  "name": "talk-to-figma-mcp",
  "version": "1.0.0",
  "description": "MCP server for Figma integration",
  "main": "server.ts",
  "type": "module",
  "scripts": {
    "start": "node --loader ts-node/esm server.ts",
    "build": "tsc",
    "dev": "node --loader ts-node/esm --watch server.ts"
  },
  "keywords": [
    "figma",
    "mcp",
    "cursor",
    "ai"
  ],
  "dependencies": {
    "@modelcontextprotocol/sdk": "1.13.1",
    "uuid": "^9.0.1",
    "ws": "^8.16.0",
    "zod": "3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.10.5",
    "@types/uuid": "^9.0.7",
    "@types/ws": "^8.5.10",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3"
  }
}
</file>

<file path="src/config-resolver.js">
#!/usr/bin/env node

/**
 * Content Configuration Resolver - 简化而稳健的文件路径解析
 * 
 * 优先级: initialize() > CLI > ENV > config > 智能发现
 */

import fs from 'fs';
import path from 'path';

export default class ContentResolver {
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.defaultContentDir = path.join(projectRoot, 'docx2json');
  }
  
  /**
   * 解析内容文件路径
   * @param {Object} options - 配置选项
   * @param {string} options.initParam - 来自initialize()参数
   * @param {string} options.cliArg - CLI --content参数
   * @param {string} options.envVar - CONTENT_JSON_PATH环境变量
   * @param {string} options.configOverride - 可选的配置文件路径
   * @returns {Object} { contentPath, source }
   */
  resolve(options = {}) {
    const {
      initParam,
      cliArg,
      envVar,
      configOverride
    } = options;
    
    // 简化的优先级链
    const candidates = [
      { path: initParam, source: 'initialize()' },
      { path: cliArg, source: 'CLI --content' },
      { path: envVar, source: 'ENV CONTENT_JSON_PATH' },
      { path: this.getFromConfig(configOverride), source: 'server-config.json' },
      { path: this.autoDiscover(), source: 'auto-discovery' }
    ].filter(c => c.path);
    
    for (const candidate of candidates) {
      const resolved = this.resolvePath(candidate.path);
      if (this.validatePath(resolved)) {
        console.log(`📄 Using content: ${resolved} (via ${candidate.source})`);
        return { contentPath: resolved, source: candidate.source };
      }
    }
    
    throw new Error(`No valid content file found. Tried: ${
      candidates.map(c => `${c.source}: ${c.path}`).join(', ')
    }`);
  }
  
  /**
   * 将输入路径解析为绝对路径
   */
  resolvePath(pathInput) {
    if (!pathInput) return null;
    return path.isAbsolute(pathInput) 
      ? pathInput 
      : path.join(this.defaultContentDir, pathInput);
  }
  
  /**
   * 验证文件路径是否有效且包含正确格式的JSON
   */
  validatePath(filePath) {
    if (!filePath) return false;
    
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const json = JSON.parse(content);
      
      // 基本结构检查：必须有blocks数组
      return json.blocks && Array.isArray(json.blocks);
    } catch {
      return false;
    }
  }
  
  /**
   * 从配置文件读取内容文件名
   */
  getFromConfig(configPath) {
    try {
      const configFile = configPath || path.join(this.projectRoot, 'config/server-config.json');
      const config = JSON.parse(fs.readFileSync(configFile, 'utf8'));
      return config.workflow?.current_content_file;
    } catch {
      return null;
    }
  }
  
  /**
   * 智能发现内容文件
   * 按文件修改时间和名称模式，选择最合适的内容文件
   */
  autoDiscover() {
    try {
      const files = fs.readdirSync(this.defaultContentDir)
        .filter(f => f.endsWith('.json') && 
                    !f.includes('config') && 
                    !f.includes('mapping') &&
                    !f.includes('state'))
        .map(f => {
          const fullPath = path.join(this.defaultContentDir, f);
          const stat = fs.statSync(fullPath);
          return { name: f, mtime: stat.mtime };
        })
        .sort((a, b) => b.mtime - a.mtime); // 按修改时间降序
      
      if (files.length === 0) return null;
      
      // 策略1: 如果只有一个文件，直接返回
      if (files.length === 1) return files[0].name;
      
      // 策略2: 优先选择最新修改的日期格式文件
      const dateFiles = files.filter(f => f.name.match(/^\d{6}.*\.json$/));
      if (dateFiles.length > 0) {
        // 如果修改时间相同，按日期字符串降序选择（更新的日期）
        const sortedByDate = dateFiles.sort((a, b) => {
          const dateA = a.name.substring(0, 6);
          const dateB = b.name.substring(0, 6);
          return dateB.localeCompare(dateA); // 降序，更新日期在前
        });
        console.log(`🔍 Auto-discovery: Found ${dateFiles.length} date-pattern files, choosing latest date: ${sortedByDate[0].name}`);
        return sortedByDate[0].name;
      }
      
      // 策略3: 返回最新修改的文件
      console.log(`🔍 Auto-discovery: No date-pattern files, choosing latest modified: ${files[0].name}`);
      return files[0].name;
    } catch {
      return null;
    }
  }
}

/**
 * 简单的CLI参数解析器
 */
export function parseArgs() {
  const args = process.argv.slice(2);
  const parsed = {};
  
  for (let i = 0; i < args.length; i++) {
    if (args[i].startsWith('--')) {
      const key = args[i].slice(2);
      parsed[key] = args[i + 1] && !args[i + 1].startsWith('--') ? args[i + 1] : true;
      if (parsed[key] !== true) i++; // 跳过值
    }
  }
  
  return parsed;
}

// 便捷导出函数
export function resolveContentPath(projectRoot, options = {}) {
  const resolver = new ContentResolver(projectRoot);
  return resolver.resolve(options);
}

// Infer dataset name from assets list or content filename stem
export function inferDataset(assets = [], contentFilePath = null) {
  try {
    if (Array.isArray(assets) && assets.length > 0 && assets[0]?.filename) {
      // filename example: "250818_summer_break/img_xxx.png"
      const parts = String(assets[0].filename).split('/');
      if (parts.length > 1) return parts[0];
    }
    if (contentFilePath) {
      const base = path.basename(contentFilePath);
      // Prefer removing suffix _content.json; else trim .json
      return base.replace(/_content\.json$/i, '').replace(/\.json$/i, '');
    }
  } catch {}
  return 'dataset';
}

// Derive asset extension from assets[], default 'png'
export function getAssetExtension(assetId, assets = []) {
  try {
    const found = (assets || []).find(a => a.asset_id === assetId);
    if (found?.filename) {
      const ext = path.extname(found.filename).toLowerCase().replace(/^\./, '');
      if (ext) return ext;
    }
  } catch {}
  return 'png';
}

// Build full asset URL with dataset + ext
export function buildAssetUrl(staticServerUrl, assets, assetId, contentFilePath = null) {
  const dataset = inferDataset(assets, contentFilePath);
  const ext = getAssetExtension(assetId, assets);
  const base = (staticServerUrl || '').replace(/\/$/, '');
  return `${base}/${dataset}/${assetId}.${ext}`;
}

// Compute static server URL from config
export function computeStaticServerUrl(serverConfig) {
  try {
    const cfg = serverConfig?.static_server || {};
    const host = cfg.host || '127.0.0.1';
    const port = cfg.port || 3056;
    const route = cfg.publicRoute || '/assets';
    return `http://${host}:${port}${route}`;
  } catch {
    return 'http://127.0.0.1:3056/assets';
  }
}
</file>

<file path="src/content-generator.js">
#!/usr/bin/env node

/**
 * Content Generator - 基于JSON的内容生成器
 * 
 * 实现专家建议的"内容生成流"：
 * 1. 清空现有内容 (可回退)
 * 2. 根据content.json动态生成
 * 3. 自动布局和背景调整
 */

import TEMPLATE_STYLES, { getTitleHeight, getImageWidth, getContainerPosition } from './template-styles.js';
import { buildAssetUrl, inferDataset } from './config-resolver.js';

export default class ContentGenerator {
  constructor(mcpClient) {
    this.mcpClient = mcpClient;
    this.recycleGroupId = null; // 回收站组ID
    this.assets = [];
    this.dataset = null;
  }

  /**
   * 清空内容组 - 可回退机制
   * @param {string} contentGroupId - 内容组ID (默认: 6:6377)
   * @param {boolean} enableRecycle - 是否启用回收站 (默认: true)
   */
  async clearContentGroup(contentGroupId = "6:6377", enableRecycle = true) {
    console.log(`🗑️ Clearing content group: ${contentGroupId} (recycle: ${enableRecycle})`);
    
    try {
      // 获取现有子节点
      const groupInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: contentGroupId
      });
      
      if (!groupInfo.children || groupInfo.children.length === 0) {
        console.log('✅ Content group is already empty');
        return;
      }

      if (enableRecycle) {
        // 创建回收站组 (隐藏但保留)
        const recycleGroup = await this.mcpClient.call("mcp__talk-to-figma__create_frame", {
          x: groupInfo.absoluteBoundingBox.x - 2000, // 移到画布外
          y: groupInfo.absoluteBoundingBox.y,
          width: 100,
          height: 100,
          name: `Recycle_${Date.now()}`,
          parentId: groupInfo.parent?.id, // 与原组同级
          fillColor: { r: 0.5, g: 0.5, b: 0.5, a: 0.1 }
        });
        
        this.recycleGroupId = recycleGroup.id;
        console.log(`📦 Created recycle group: ${this.recycleGroupId}`);
        
        // TODO: 移动子节点到回收站 (需要move_node工具)
        // 当前先直接删除，后续可实现节点移动
      }
      
      // 删除所有子节点
      const childIds = groupInfo.children.map(child => child.id);
      
      if (childIds.length > 0) {
        await this.mcpClient.call("mcp__talk-to-figma__delete_multiple_nodes", {
          nodeIds: childIds
        });
        console.log(`🗑️ Deleted ${childIds.length} existing nodes`);
      }
      
      console.log('✅ Content group cleared successfully');
      
    } catch (error) {
      throw new Error(`Failed to clear content group: ${error.message}`);
    }
  }

  /**
   * 从JSON生成内容
   * @param {Object} contentData - content.json数据
   * @param {string} contentGroupId - 目标内容组ID
   */
  async buildFromJson(contentData, contentGroupId = "6:6377") {
    console.log('🏗️ Building content from JSON...');
    
    try {
      // 保存 assets 与 dataset 供后续图片 URL 构建
      this.assets = contentData?.assets || [];
      this.dataset = inferDataset(this.assets, null);

      // 按组聚合内容
      const groups = this.groupContentByGroupId(contentData.blocks);
      console.log(`📊 Found ${groups.length} content groups`);
      
      // 获取容器起始位置
      const containerInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: contentGroupId
      });
      
      let currentY = containerInfo.absoluteBoundingBox.y;
      const basePosition = getContainerPosition(currentY);
      
      // 逐组生成内容
      for (const group of groups) {
        const groupHeight = await this.generateGroup(group, basePosition.x, currentY);
        currentY += groupHeight + TEMPLATE_STYLES.CONTAINER.verticalSpacing.betweenGroups;
      }
      
      // 生成段落内容
      const paragraphs = contentData.blocks.filter(block => block.type === 'paragraph');
      if (paragraphs.length > 0) {
        await this.generateParagraphs(paragraphs, basePosition.x, currentY);
      }
      
      // 调整背景高度
      await this.adjustBackgroundHeight(contentGroupId);
      
      console.log('✅ Content generation completed successfully');
      
    } catch (error) {
      throw new Error(`Failed to build from JSON: ${error.message}`);
    }
  }

  /**
   * 按group_id聚合内容
   * @param {Array} blocks - 内容块数组
   * @returns {Array} 按组聚合的内容
   */
  groupContentByGroupId(blocks) {
    const figures = blocks.filter(block => block.type === 'figure');
    const groupMap = new Map();
    
    // 按group_id分组
    figures.forEach(figure => {
      const groupId = figure.group_id;
      if (!groupMap.has(groupId)) {
        groupMap.set(groupId, []);
      }
      groupMap.get(groupId).push(figure);
    });
    
    // 按group_seq排序并转换为数组
    const groups = Array.from(groupMap.entries()).map(([groupId, figures]) => {
      const sortedFigures = figures.sort((a, b) => 
        (a.group_seq || 0) - (b.group_seq || 0)
      );
      
      return {
        groupId,
        figures: sortedFigures,
        layout: figures[0]?.layout || 'column', // 获取布局模式
        title: sortedFigures[0]?.title,         // 组首标题
        credit: sortedFigures[sortedFigures.length - 1]?.credit  // 组尾来源
      };
    });
    
    return groups;
  }

  /**
   * 生成单个图片组
   * @param {Object} group - 图片组数据
   * @param {number} x - X位置
   * @param {number} y - Y位置
   * @returns {number} 生成内容的高度
   */
  async generateGroup(group, x, y) {
    console.log(`🎨 Generating group: ${group.groupId} (${group.figures.length} figures, layout: ${group.layout})`);
    
    let currentY = y;
    let totalHeight = 0;
    
    // 1. 生成组标题 (仅组首)
    if (group.title && group.title.trim()) {
      const titleHeight = await this.createTitleBar(group.title, x, currentY);
      currentY += titleHeight;
      totalHeight += titleHeight;
    }
    
    // 2. 生成图片容器
    const imageContainerHeight = await this.createImageContainer(
      group.figures, 
      group.layout, 
      x, 
      currentY
    );
    currentY += imageContainerHeight;
    totalHeight += imageContainerHeight;
    
    // 3. 生成来源信息 (仅组尾)
    if (group.credit && group.credit.trim()) {
      currentY += TEMPLATE_STYLES.CONTAINER.verticalSpacing.imageToSource;
      const sourceHeight = await this.createSourceText(group.credit, x, currentY);
      currentY += sourceHeight;
      totalHeight += sourceHeight + TEMPLATE_STYLES.CONTAINER.verticalSpacing.imageToSource;
    }
    
    console.log(`✅ Group ${group.groupId} generated, height: ${totalHeight}px`);
    return totalHeight;
  }

  /**
   * 创建标题栏
   * @param {string} titleText - 标题文本
   * @param {number} x - X位置
   * @param {number} y - Y位置
   * @returns {number} 标题栏高度
   */
  async createTitleBar(titleText, x, y) {
    // 估算行数 (简化算法: 每32个中文字符约1行)
    const estimatedLines = Math.ceil(titleText.length / 32);
    const titleHeight = getTitleHeight(estimatedLines);
    
    console.log(`📝 Creating title: "${titleText}" (${estimatedLines} lines, height: ${titleHeight}px)`);
    
    // 创建标题组容器
    const titleGroup = await this.mcpClient.call("mcp__talk-to-figma__create_frame", {
      x: x,
      y: y, 
      width: TEMPLATE_STYLES.CONTAINER.contentWidth,
      height: titleHeight,
      name: "标题组",
      fillColor: TEMPLATE_STYLES.TITLE.background.fills[0].color
    });
    
    // 创建标题文本
    await this.mcpClient.call("mcp__talk-to-figma__create_text", {
      x: x + TEMPLATE_STYLES.TITLE.text.padding.left,
      y: y + TEMPLATE_STYLES.TITLE.text.padding.top,
      text: titleText,
      name: titleText,
      parentId: titleGroup.id,
      fontColor: TEMPLATE_STYLES.TITLE.text.fills[0].color,
      fontSize: TEMPLATE_STYLES.TITLE.text.fontSize,
      fontWeight: TEMPLATE_STYLES.TITLE.text.fontWeight
    });
    
    return titleHeight;
  }

  /**
   * 创建图片容器
   * @param {Array} figures - 图片数据数组
   * @param {string} layout - 布局模式 ('row'/'column')
   * @param {number} x - X位置
   * @param {number} y - Y位置
   * @returns {number} 容器高度
   */
  async createImageContainer(figures, layout, x, y) {
    console.log(`🖼️ Creating ${figures.length} images in ${layout} layout`);
    
    if (layout === 'row' && figures.length > 1) {
      return await this.createHorizontalImages(figures, x, y);
    } else {
      return await this.createVerticalImages(figures, x, y);
    }
  }

  /**
   * 创建横排图片
   * @param {Array} figures - 图片数据 
   * @param {number} x - X位置
   * @param {number} y - Y位置
   * @returns {number} 容器高度
   */
  async createHorizontalImages(figures, x, y) {
    const imageWidth = getImageWidth(figures.length);
    const spacing = TEMPLATE_STYLES.IMAGE.multiImage.spacing;
    
    let maxHeight = 0;
    let currentX = x;
    
    for (const figure of figures) {
      const imageHeight = await this.createSingleImage(figure, currentX, y, imageWidth);
      maxHeight = Math.max(maxHeight, imageHeight);
      currentX += imageWidth + spacing;
    }
    
    return maxHeight;
  }

  /**
   * 创建竖排图片
   * @param {Array} figures - 图片数据
   * @param {number} x - X位置  
   * @param {number} y - Y位置
   * @returns {number} 容器高度
   */
  async createVerticalImages(figures, x, y) {
    let totalHeight = 0;
    let currentY = y;
    
    for (const figure of figures) {
      const imageHeight = await this.createSingleImage(figure, x, currentY);
      currentY += imageHeight + TEMPLATE_STYLES.CONTAINER.verticalSpacing.betweenItems;
      totalHeight += imageHeight + TEMPLATE_STYLES.CONTAINER.verticalSpacing.betweenItems;
    }
    
    return totalHeight - TEMPLATE_STYLES.CONTAINER.verticalSpacing.betweenItems; // 移除最后的间距
  }

  /**
   * 创建单个图片
   * @param {Object} figure - 图片数据
   * @param {number} x - X位置
   * @param {number} y - Y位置  
   * @param {number} width - 图片宽度 (可选，默认使用标准宽度)
   * @returns {number} 图片高度
   */
  async createSingleImage(figure, x, y, width = TEMPLATE_STYLES.IMAGE.width) {
    // 根据宽度按比例计算高度 (这里使用固定比例，实际可能需要从资源获取)
    const aspectRatio = 0.6; // 临时使用的宽高比
    const height = Math.round(width * aspectRatio);
    
    console.log(`🖼️ Creating image: ${figure.image?.asset_id} (${width}x${height})`);
    
    // 创建图片节点
    const imageNode = await this.mcpClient.call("mcp__talk-to-figma__create_rectangle", {
      x: x,
      y: y,
      width: width,
      height: height,
      name: figure.image?.asset_id || "image"
    });
    
    // 填充图片内容 (如果有asset_id)
    if (figure.image?.asset_id) {
      const staticServerUrl = 'http://127.0.0.1:3056/assets';
      const imageUrl = buildAssetUrl(staticServerUrl, this.assets || [], figure.image.asset_id, null);
      try {
        await this.mcpClient.call("mcp__talk-to-figma__set_image_fill", {
          nodeId: imageNode.id,
          imageUrl: imageUrl,
          scaleMode: TEMPLATE_STYLES.IMAGE.scaleMode
        });
        console.log(`✅ Image filled: ${figure.image.asset_id}`);
      } catch (error) {
        console.warn(`⚠️ Failed to fill image ${figure.image.asset_id}: ${error.message}`);
      }
    }
    
    return height;
  }

  /**
   * 创建来源文本
   * @param {string} sourceText - 来源文本
   * @param {number} x - X位置
   * @param {number} y - Y位置
   * @returns {number} 文本高度
   */
  async createSourceText(sourceText, x, y) {
    console.log(`📄 Creating source: "${sourceText}"`);
    
    const sourceNode = await this.mcpClient.call("mcp__talk-to-figma__create_text", {
      x: x,
      y: y,
      text: sourceText,
      name: "来源",
      fontColor: TEMPLATE_STYLES.SOURCE.fills[0].color,
      fontSize: TEMPLATE_STYLES.SOURCE.fontSize,
      fontWeight: TEMPLATE_STYLES.SOURCE.fontWeight
    });
    
    // 设置文本自动调整高度
    await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", {
      nodeId: sourceNode.id,
      autoResize: "HEIGHT"
    });
    
    // 返回估算高度 (基于字体行高)
    return TEMPLATE_STYLES.SOURCE.lineHeightPx;
  }

  /**
   * 生成段落内容
   * @param {Array} paragraphs - 段落数据
   * @param {number} x - X位置
   * @param {number} y - Y位置
   */
  async generateParagraphs(paragraphs, x, y) {
    console.log(`📄 Generating ${paragraphs.length} paragraphs`);
    
    let currentY = y;
    
    for (const paragraph of paragraphs) {
      const content = paragraph.content || paragraph.text || '';
      const paragraphNode = await this.mcpClient.call("mcp__talk-to-figma__create_text", {
        x: x,
        y: currentY,
        text: content,
        name: "段落",
        fontColor: TEMPLATE_STYLES.PARAGRAPH.fills[0].color,
        fontSize: TEMPLATE_STYLES.PARAGRAPH.fontSize,
        fontWeight: TEMPLATE_STYLES.PARAGRAPH.fontWeight
      });
      
      // 设置文本自动调整高度
      await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", {
        nodeId: paragraphNode.id,
        autoResize: "HEIGHT"
      });
      
      // 估算段落高度并更新位置 
      const estimatedHeight = Math.ceil(content.length / 30) * TEMPLATE_STYLES.PARAGRAPH.lineHeightPx;
      currentY += estimatedHeight + TEMPLATE_STYLES.CONTAINER.verticalSpacing.betweenItems;
    }
  }

  /**
   * 调整背景高度
   * @param {string} contentGroupId - 内容组ID
   */
  async adjustBackgroundHeight(contentGroupId) {
    try {
      // 获取内容组的实际高度
      const contentGroupInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: contentGroupId
      });
      
      const contentHeight = contentGroupInfo.absoluteBoundingBox.height;
      const newBackgroundHeight = contentHeight + 
        TEMPLATE_STYLES.BACKGROUND.topPadding + 
        TEMPLATE_STYLES.BACKGROUND.bottomPadding;
      
      console.log(`📏 Adjusting background height: ${newBackgroundHeight}px (content: ${contentHeight}px)`);
      
      // 调整背景Frame高度
      await this.mcpClient.call("mcp__talk-to-figma__resize_node", {
        nodeId: TEMPLATE_STYLES.BACKGROUND.nodeId,
        width: contentGroupInfo.absoluteBoundingBox.width, // 保持原宽度
        height: newBackgroundHeight
      });
      
      console.log('✅ Background height adjusted');
      
    } catch (error) {
      console.warn(`⚠️ Failed to adjust background height: ${error.message}`);
    }
  }

  /**
   * 恢复内容 (从回收站)
   * @returns {boolean} 恢复是否成功
   */
  async restoreContent() {
    if (!this.recycleGroupId) {
      console.log('❌ No recycle group available for restoration');
      return false;
    }
    
    try {
      // TODO: 实现从回收站恢复节点的逻辑
      console.log(`🔄 Restoring content from recycle group: ${this.recycleGroupId}`);
      return true;
    } catch (error) {
      console.error(`Failed to restore content: ${error.message}`);
      return false;
    }
  }
}
</file>

<file path="src/figma-channel-manager.js">
#!/usr/bin/env node

/**
 * Figma Channel Manager - Simplified Connection Handler
 * 
 * Lightweight connector for Figma plugin communication:
 * - Memory-only channel storage
 * - Direct connect/health check methods
 * - Optional environment variable default
 */

// No file system imports needed - pure memory approach

class FigmaChannelManager {
  constructor(mcpClient = null) {
    this.mcpClient = mcpClient;
    this.currentChannel = process.env.FIGMA_CHANNEL || null;
    this.maxRetries = 2; // Simplified retry logic
  }

  // DEPRECATED: Config file support removed
  async loadChannelConfig() {
    console.warn('DEPRECATED: loadChannelConfig() - config file support removed. Use connect(channelId) instead.');
    return { deprecated: true };
  }

  // DEPRECATED: Config file support removed  
  async saveChannelConfig(config) {
    console.warn('DEPRECATED: saveChannelConfig() - config file support removed. Channel stored in memory only.');
  }

  // Core connection method
  async connect(channelId) {
    if (!this.mcpClient) {
      throw new Error('MCP client not provided. Use: new FigmaChannelManager(mcpClient)');
    }
    
    try {
      console.log(`Connecting to channel: ${channelId}`);
      
      // Step 1: Join channel
      await this.mcpClient.call("mcp__talk-to-figma__join_channel", { 
        channel: channelId 
      });
      
      // Step 2: Set current channel (needed for healthCheck)
      this.currentChannel = channelId;
      
      // Step 3: Health check with get_selection
      await this.mcpClient.call("mcp__talk-to-figma__get_selection", {});
      
      console.log(`✅ Connected to channel: ${channelId}`);
      return channelId;
    } catch (error) {
      // Clear channel on failure
      this.currentChannel = null;
      throw new Error(`Failed to connect to channel ${channelId}: ${error.message}`);
    }
  }
  
  async healthCheck() {
    if (!this.mcpClient) {
      throw new Error('MCP client not available');
    }
    
    if (!this.currentChannel) {
      throw new Error('No active channel. Use connect(channelId) first.');
    }
    
    try {
      // Use get_selection as lightweight health check
      const result = await this.mcpClient.call("mcp__talk-to-figma__get_selection", {});
      console.log(`✅ Health check passed for channel: ${this.currentChannel}`);
      return true;
    } catch (error) {
      throw new Error(`Health check failed: ${error.message}. Check if plugin is running and Frame is selected.`);
    }
  }

  // DEPRECATED: Auto-discovery removed
  async findWorkingChannel(mcpClient) {
    console.warn('DEPRECATED: findWorkingChannel() - auto-discovery disabled. Use connect(channelId) instead.');
    throw new Error('Auto-discovery disabled. Please provide channel ID via connect(channelId) method.');
  }

  // DEPRECATED: Channel history removed
  updateChannelHistory(newChannel) {
    console.warn('DEPRECATED: updateChannelHistory() - channel history tracking removed.');
    return [];
  }

  // Simplified channel registration - just connect
  async registerNewChannel(channelId) {
    console.warn('DEPRECATED: registerNewChannel() - use connect(channelId) instead.');
    return await this.connect(channelId);
  }

  // Simplified connection with retry
  async ensureConnection(channelId, maxAttempts = 2) {
    if (!channelId && !this.currentChannel) {
      throw new Error('No channel specified. Use connect(channelId) or provide channelId parameter.');
    }
    
    const targetChannel = channelId || this.currentChannel;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        console.log(`Connection attempt ${attempt}/${maxAttempts}`);
        return await this.connect(targetChannel);
      } catch (error) {
        if (attempt === maxAttempts) {
          throw error;
        }
        console.log('Retrying in 1s...');
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  // Command interface methods
  getCurrentChannel() {
    return this.currentChannel || 'No channel connected';
  }
  
  async reconnect(channelId) {
    console.log('🔄 Reconnecting...');
    return await this.connect(channelId);
  }
}

// Export for use in other modules
export default FigmaChannelManager;

// Command interface for interactive usage
export function parseCommand(input, manager) {
  const trimmed = input.trim();
  
  if (trimmed.startsWith(':connect ')) {
    const channelId = trimmed.substring(9).trim();
    if (!channelId) {
      throw new Error('Usage: :connect <channel-id>');
    }
    return { command: 'connect', channelId };
  }
  
  if (trimmed === ':health') {
    return { command: 'health' };
  }
  
  if (trimmed === ':channel') {
    return { command: 'channel' };
  }
  
  return null; // Not a recognized command
}

// CLI usage (simplified)
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log(`
Figma Channel Manager - Simplified Connection Handler

For interactive usage, create instance with MCP client:
  const manager = new FigmaChannelManager(mcpClient);
  await manager.connect(channelId);

Commands in Claude Code:
  :connect <channel-id>  Connect to specific channel
  :health               Check current connection
  :channel              Show current channel

Environment variable: FIGMA_CHANNEL (optional default)
  `);
}
</file>

<file path="src/smart-mapping-algorithm.js">
#!/usr/bin/env node

/**
 * Smart Content-Template Mapping Algorithm
 * 
 * Based on bbox positioning and visual proximity rather than hardcoded indices.
 * Implements the expert-recommended improvement over array index mapping.
 */

import fs from 'fs/promises';
import path from 'path';

class SmartMappingAlgorithm {
  constructor() {
    this.proximityThreshold = 150; // pixels
    this.yTolerance = 50; // pixels for "same row" detection
  }

  /**
   * Calculate adaptive proximity thresholds based on image height
   */
  calculateAdaptiveThresholds(imageHeight) {
    return {
      titleThreshold: Math.min(180, 0.22 * imageHeight),
      sourceThreshold: Math.min(220, 0.28 * imageHeight)
    };
  }

  /**
   * Enhanced content-to-template mapping based on visual layout
   */
  mapContentToTemplate(contentBlocks, templateNodes) {
    const sortedContent = this.sortContentByVisualOrder(contentBlocks);
    const sortedTemplate = this.sortTemplateByVisualOrder(templateNodes);
    
    return {
      mappings: this.createOptimalMappings(sortedContent, sortedTemplate),
      strategy: 'bbox_visual_proximity',
      confidence: this.calculateMappingConfidence(sortedContent, sortedTemplate)
    };
  }

  sortContentByVisualOrder(contentBlocks) {
    return contentBlocks
      .filter(block => block.group_id && block.group_seq !== undefined)
      .sort((a, b) => {
        // Primary sort: group_id
        if (a.group_id !== b.group_id) {
          return a.group_id.localeCompare(b.group_id);
        }
        // Secondary sort: group_seq
        return (a.group_seq || 0) - (b.group_seq || 0);
      });
  }

  sortTemplateByVisualOrder(templateNodes) {
    const { images, title_groups, sources, paragraphs } = templateNodes;
    
    // Combine all template elements with their types
    const allElements = [
      ...images.map(node => ({ ...node, element_type: 'image' })),
      ...title_groups.map(node => ({ ...node, element_type: 'title' })),
      ...sources.map(node => ({ ...node, element_type: 'source' })),
      ...paragraphs.map(node => ({ ...node, element_type: 'paragraph' }))
    ];

    // Sort by Y position, then X position
    return allElements.sort((a, b) => {
      const yDiff = a.bbox.y - b.bbox.y;
      if (Math.abs(yDiff) > this.yTolerance) {
        return yDiff; // Different rows
      }
      return a.bbox.x - b.bbox.x; // Same row, sort by X
    });
  }

  createOptimalMappings(sortedContent, sortedTemplate) {
    const mappings = {
      figures: [],
      paragraphs: [],
      unmatched_content: [],
      unmatched_template: []
    };

    let templateIndex = 0;
    
    for (const contentBlock of sortedContent) {
      const bestMatch = this.findBestTemplateMatch(
        contentBlock, 
        sortedTemplate, 
        templateIndex
      );

      if (bestMatch) {
        mappings[contentBlock.type + 's']?.push({
          content: contentBlock,
          template: bestMatch.node,
          confidence: bestMatch.confidence,
          strategy: bestMatch.strategy
        });
        templateIndex = bestMatch.nextIndex;
      } else {
        mappings.unmatched_content.push(contentBlock);
      }
    }

    return mappings;
  }

  findBestTemplateMatch(contentBlock, templateNodes, startIndex) {
    if (contentBlock.type === 'figure') {
      return this.findImageMatch(contentBlock, templateNodes, startIndex);
    } else if (contentBlock.type === 'paragraph') {
      return this.findParagraphMatch(contentBlock, templateNodes, startIndex);
    }
    return null;
  }

  findImageMatch(figureBlock, templateNodes, startIndex) {
    // Look for image nodes starting from startIndex
    for (let i = startIndex; i < templateNodes.length; i++) {
      const node = templateNodes[i];
      
      if (node.element_type === 'image') {
        return {
          node,
          confidence: this.calculateImageMatchConfidence(figureBlock, node, i - startIndex),
          strategy: 'sequential_image_matching',
          nextIndex: i + 1
        };
      }
    }

    // Fallback: find any available image node
    const availableImages = templateNodes.filter(n => n.element_type === 'image');
    if (availableImages.length > 0) {
      const closestImage = this.findClosestBySize(figureBlock, availableImages);
      return {
        node: closestImage,
        confidence: 0.6, // Lower confidence for fallback
        strategy: 'size_based_fallback',
        nextIndex: startIndex + 1
      };
    }

    return null;
  }

  findParagraphMatch(paragraphBlock, templateNodes, startIndex) {
    // Look for paragraph nodes starting from startIndex
    for (let i = startIndex; i < templateNodes.length; i++) {
      const node = templateNodes[i];
      
      if (node.element_type === 'paragraph') {
        return {
          node,
          confidence: this.calculateParagraphMatchConfidence(paragraphBlock, node, i - startIndex),
          strategy: 'sequential_paragraph_matching',
          nextIndex: i + 1
        };
      }
    }

    // Fallback: combine with existing paragraph
    const availableParagraphs = templateNodes.filter(n => n.element_type === 'paragraph');
    if (availableParagraphs.length > 0) {
      const largestParagraph = availableParagraphs.reduce((largest, current) => 
        current.bbox.height > largest.bbox.height ? current : largest
      );
      
      return {
        node: largestParagraph,
        confidence: 0.4, // Low confidence - text will be appended
        strategy: 'text_combination_fallback',
        nextIndex: startIndex + 1
      };
    }

    return null;
  }

  calculateImageMatchConfidence(figureBlock, templateNode, positionOffset) {
    let confidence = 0.8; // Base confidence
    
    // Penalty for position offset
    confidence -= positionOffset * 0.1;
    
    // Bonus for size compatibility (if available in content)
    if (figureBlock.layout_hint?.aspect_ratio && templateNode.bbox) {
      const templateRatio = templateNode.bbox.width / templateNode.bbox.height;
      const ratioMatch = 1 - Math.abs(figureBlock.layout_hint.aspect_ratio - templateRatio) / 2;
      confidence = (confidence + ratioMatch) / 2;
    }
    
    // Apply adaptive thresholds for proximity matching
    if (templateNode.bbox?.height) {
      const thresholds = this.calculateAdaptiveThresholds(templateNode.bbox.height);
      // Use thresholds for future proximity calculations
      figureBlock._adaptiveThresholds = thresholds;
    }
    
    return Math.max(0.1, Math.min(1.0, confidence));
  }

  calculateParagraphMatchConfidence(paragraphBlock, templateNode, positionOffset) {
    let confidence = 0.7; // Base confidence
    
    // Penalty for position offset
    confidence -= positionOffset * 0.15;
    
    // Bonus for text length compatibility
    const textLength = paragraphBlock.text?.length || 0;
    const estimatedNeededHeight = Math.ceil(textLength / 80) * 20; // Rough estimate
    const availableHeight = templateNode.bbox?.height || 100;
    
    if (estimatedNeededHeight <= availableHeight) {
      confidence += 0.2;
    } else {
      confidence -= (estimatedNeededHeight - availableHeight) / availableHeight * 0.3;
    }
    
    return Math.max(0.1, Math.min(1.0, confidence));
  }

  findClosestBySize(contentBlock, templateNodes) {
    // Simple size-based matching as fallback
    return templateNodes[0]; // For now, just return first available
  }

  calculateMappingConfidence(sortedContent, sortedTemplate) {
    const imageCount = sortedContent.filter(b => b.type === 'figure').length;
    const paragraphCount = sortedContent.filter(b => b.type === 'paragraph').length;
    
    const templateImageCount = sortedTemplate.filter(n => n.element_type === 'image').length;
    const templateParagraphCount = sortedTemplate.filter(n => n.element_type === 'paragraph').length;
    
    const imageCoverage = Math.min(imageCount, templateImageCount) / Math.max(imageCount, templateImageCount, 1);
    const paragraphCoverage = Math.min(paragraphCount, templateParagraphCount) / Math.max(paragraphCount, templateParagraphCount, 1);
    
    return (imageCoverage + paragraphCoverage) / 2;
  }

  /**
   * Generate enhanced node mapping for workflow automation
   */
  generateEnhancedMapping(contentBlocks, originalMapping) {
    const smartMapping = this.mapContentToTemplate(contentBlocks, originalMapping.content_elements);
    
    return {
      ...originalMapping,
      smart_mapping: {
        strategy: 'bbox_visual_proximity',
        confidence: smartMapping.confidence,
        mappings: smartMapping.mappings,
        generated_at: new Date().toISOString()
      },
      mapping_algorithm: 'v2_smart_visual_layout'
    };
  }

  /**
   * Handle content overflow with dynamic card creation
   */
  generateCardExpansionPlan(contentGroups, availableCards) {
    const requiredCards = Object.keys(contentGroups).length;
    const expansionPlan = [];
    
    if (requiredCards > availableCards) {
      for (let i = availableCards; i < requiredCards; i++) {
        expansionPlan.push({
          action: 'append_card_to_container',
          template_source: 0, // Use first card as template
          insert_position: -1, // Append at end
          content_group_index: i
        });
      }
    }
    
    return {
      required_cards: requiredCards,
      available_cards: availableCards,
      expansion_needed: requiredCards > availableCards,
      expansion_plan: expansionPlan
    };
  }
}

export default SmartMappingAlgorithm;

// CLI testing
if (import.meta.url === `file://${process.argv[1]}`) {
  const algorithm = new SmartMappingAlgorithm();
  
  console.log(`
Smart Mapping Algorithm - bbox智能索引增强

Features:
- Visual layout-based content mapping
- Proximity-aware node matching  
- Dynamic card expansion planning
- Confidence scoring for mappings

Usage:
  import SmartMappingAlgorithm from './smart-mapping-algorithm.js'
  const mapper = new SmartMappingAlgorithm();
  const result = mapper.mapContentToTemplate(content, template);
  `);
}
</file>

<file path="src/socket.ts">
import { Server, ServerWebSocket } from "bun";
import * as fs from "fs";
import * as path from "path";

// Load configuration
const CONFIG_PATH = path.join(import.meta.dir, '../config/server-config.json');
const config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));

// Store clients by channel
const channels = new Map<string, Set<ServerWebSocket<any>>>();

// Sanitize large payloads for logging
function sanitizePayload(message: string): string {
  try {
    const data = JSON.parse(message);
    if (data.message?.params?.imageBase64) {
      const base64 = data.message.params.imageBase64;
      if (base64.length > 128) {
        data.message.params.imageBase64 = `${base64.substring(0, 64)}...${base64.substring(base64.length - 64)} (${base64.length} chars)`;
      }
    }
    return JSON.stringify(data);
  } catch {
    return message.length > 200 ? `${message.substring(0, 200)}... (${message.length} chars)` : message;
  }
}

function handleConnection(ws: ServerWebSocket<any>) {
  // Don't add to clients immediately - wait for channel join
  console.log("New client connected");

  // Send welcome message to the new client
  ws.send(JSON.stringify({
    type: "system",
    message: "Please join a channel to start chatting",
  }));

  ws.close = () => {
    console.log("Client disconnected");

    // Remove client from their channel
    channels.forEach((clients, channelName) => {
      if (clients.has(ws)) {
        clients.delete(ws);

        // Notify other clients in same channel
        clients.forEach((client) => {
          if (client.readyState === WebSocket.OPEN) {
            client.send(JSON.stringify({
              type: "system",
              message: "A user has left the channel",
              channel: channelName
            }));
          }
        });
      }
    });
  };
}

const server = Bun.serve({
  port: process.env.WEBSOCKET_PORT || config.websocket.port,
  hostname: process.env.WEBSOCKET_HOST || config.websocket.host,
  fetch(req: Request, server: Server) {
    // Handle CORS preflight
    if (req.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization",
        },
      });
    }

    // Handle WebSocket upgrade
    const success = server.upgrade(req, {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });

    if (success) {
      return; // Upgraded to WebSocket
    }

    // Return response for non-WebSocket requests
    return new Response("WebSocket server running", {
      headers: {
        "Access-Control-Allow-Origin": "*",
      },
    });
  },
  websocket: {
    open: handleConnection,
    message(ws: ServerWebSocket<any>, message: string | Buffer) {
      try {
        // Desensitize large payloads for logging
        const sanitizedMessage = sanitizePayload(message as string);
        console.log("Received message from client:", sanitizedMessage);
        const data = JSON.parse(message as string);

        if (data.type === "join") {
          const channelName = data.channel;
          if (!channelName || typeof channelName !== "string") {
            ws.send(JSON.stringify({
              type: "error",
              message: "Channel name is required"
            }));
            return;
          }

          // Create channel if it doesn't exist
          if (!channels.has(channelName)) {
            channels.set(channelName, new Set());
          }

          // Add client to channel
          const channelClients = channels.get(channelName)!;
          channelClients.add(ws);

          // Notify client they joined successfully
          ws.send(JSON.stringify({
            type: "system",
            message: `Joined channel: ${channelName}`,
            channel: channelName
          }));

          console.log("Sending message to client:", data.id);

          ws.send(JSON.stringify({
            type: "system",
            message: {
              id: data.id,
              result: "Connected to channel: " + channelName,
            },
            channel: channelName
          }));

          // Notify other clients in channel
          channelClients.forEach((client) => {
            if (client !== ws && client.readyState === WebSocket.OPEN) {
              client.send(JSON.stringify({
                type: "system",
                message: "A new user has joined the channel",
                channel: channelName
              }));
            }
          });
          return;
        }

        // Handle regular messages
        if (data.type === "message") {
          const channelName = data.channel;
          if (!channelName || typeof channelName !== "string") {
            ws.send(JSON.stringify({
              type: "error",
              message: "Channel name is required"
            }));
            return;
          }

          const channelClients = channels.get(channelName);
          if (!channelClients || !channelClients.has(ws)) {
            ws.send(JSON.stringify({
              type: "error",
              message: "You must join the channel first"
            }));
            return;
          }

          // Broadcast to all clients in the channel
          channelClients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
              const sanitizedBroadcast = sanitizePayload(JSON.stringify(data.message));
              console.log("Broadcasting message to client:", sanitizedBroadcast);
              client.send(JSON.stringify({
                type: "broadcast",
                message: data.message,
                sender: client === ws ? "You" : "User",
                channel: channelName
              }));
            }
          });
        }
      } catch (err) {
        console.error("Error handling message:", err);
      }
    },
    close(ws: ServerWebSocket<any>) {
      // Remove client from their channel
      channels.forEach((clients) => {
        clients.delete(ws);
      });
    }
  }
});

console.log(`WebSocket server running on ${config.websocket.host}:${server.port}`);
console.log(`Config loaded from: ${CONFIG_PATH}`);
</file>

<file path="src/static-server.js">
#!/usr/bin/env node

import http from 'http';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load configuration
const CONFIG_PATH = path.join(__dirname, '../config/server-config.json');
const config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));

// Backward-compatible configuration resolution
const staticCfg = config.static_server || {};
const PORT = process.env.STATIC_PORT || staticCfg.port;
const HOST = process.env.STATIC_HOST || staticCfg.host;
const PUBLIC_ROUTE = staticCfg.publicRoute || '/assets';

// Determine base directory:
// 1) Prefer explicit baseDir (e.g., ../docx2json/assets)
// 2) Fallback to parent of legacy assets_path (which may include dataset subdir)
// 3) Final fallback to ../docx2json/assets
const legacyAssetsPath = staticCfg.assets_path
  ? path.resolve(__dirname, staticCfg.assets_path)
  : null;
const BASE_DIR = path.resolve(
  __dirname,
  staticCfg.baseDir || (legacyAssetsPath ? path.join(legacyAssetsPath, '..') : '../docx2json/assets')
);

const server = http.createServer((req, res) => {
  // Enable CORS
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }

  // Parse URL path
  const urlPath = new URL(req.url, `http://localhost:${PORT}`).pathname;

  if (urlPath.startsWith(PUBLIC_ROUTE + '/')) {
    // Strip public route prefix and decode
    const relUrlPath = decodeURIComponent(urlPath.slice(PUBLIC_ROUTE.length + 1));

    // Normalize and resolve to prevent path traversal
    const normalizedRel = path.normalize(relUrlPath);
    const absolutePath = path.resolve(BASE_DIR, normalizedRel);
    const relToBase = path.relative(BASE_DIR, absolutePath);

    // Security: ensure the final path stays within BASE_DIR
    if (relToBase.startsWith('..') || path.isAbsolute(relToBase)) {
      res.writeHead(403);
      res.end('Forbidden');
      return;
    }

    // Check file existence
    if (!fs.existsSync(absolutePath) || !fs.statSync(absolutePath).isFile()) {
      res.writeHead(404);
      res.end('Not Found');
      return;
    }

    // Content-Type resolution
    const ext = path.extname(absolutePath).toLowerCase();
    const contentType =
      ext === '.png' ? 'image/png' :
      ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg' :
      ext === '.gif' ? 'image/gif' :
      ext === '.webp' ? 'image/webp' :
      'application/octet-stream';

    res.setHeader('Content-Type', contentType);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // 1 hour cache

    const stream = fs.createReadStream(absolutePath);
    stream.pipe(res);

    console.log(`Served: ${path.relative(BASE_DIR, absolutePath)} (${contentType})`);
  } else {
    res.writeHead(404);
    res.end('Not Found');
  }
});

server.listen(PORT, HOST, () => {
  console.log(`Static file server running on http://${HOST}:${PORT}`);
  console.log(`Public route: ${PUBLIC_ROUTE}`);
  console.log(`Serving base dir: ${BASE_DIR}`);
  console.log(`Config loaded from: ${CONFIG_PATH}`);
});
</file>

<file path="package.json">
{
  "name": "cursor-talk-to-figma-mcp",
  "description": "Cursor Talk to Figma MCP",
  "version": "0.3.2",
  "module": "dist/server.js",
  "main": "dist/server.js",
  "bin": {
    "cursor-talk-to-figma-mcp": "dist/server.js"
  },
  "files": [
    "dist",
    "README.md"
  ],
  "type": "module",
  "scripts": {
    "start": "bun run dist/server.js",
    "socket": "bun run src/socket.ts",
    "setup": "./scripts/setup.sh",
    "build": "tsup",
    "build:watch": "tsup --watch",
    "dev": "bun run build:watch",
    "pub:release": "bun run build && npm publish"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "bun-types": "^1.2.5",
    "tsup": "^8.4.0",
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "1.13.1",
    "uuid": "latest",
    "ws": "latest",
    "zod": "3.22.4"
  }
}
</file>

<file path="scripts/run_weekly_poster.js">
#!/usr/bin/env node

/**
 * Weekly Poster Orchestration (E2E hardened)
 * - Resolve latest content → Infer dataset → Ensure static server
 * - Validate template & properties → Create instances (direct→seed fallback)
 * - Fill header/cards → Report summary
 */

import WebSocket from 'ws';
import fs from 'fs/promises';
import path from 'path';
import { spawn } from 'child_process';
import http from 'http';
import { resolveContentPath, inferDataset, buildAssetUrl, computeStaticServerUrl } from '../src/config-resolver.js';

class WeeklyPosterRunner {
  constructor() {
    this.ws = null;
    this.messageId = 1;
    this.pending = new Map();
    this.connected = false;
    this.channel = process.env.CHANNEL || '';
    this.config = null;
    this.mapping = null;
    this.staticUrl = 'http://127.0.0.1:3056/assets';
    this.staticServerProc = null;
    this.content = null;
    this.contentPath = null;
    this.dataset = null;
    this.cardsContainerId = null;
    this.seeds = { figure: null, body: null };
    this.report = { created: [], errors: [] };
    this.base64Rate = 30; // per second
    this.base64Sent = [];
  }

  async loadConfig() {
    const cfgPath = path.join(process.cwd(), 'config/server-config.json');
    this.config = JSON.parse(await fs.readFile(cfgPath, 'utf8'));
    this.mapping = this.config.workflow.mapping;
    this.staticUrl = computeStaticServerUrl(this.config);
    this.base64Rate = Number(this.config.asset_transfer?.base64_rate_limit ?? 30);
  }

  async resolveContent() {
    const { contentPath } = resolveContentPath(process.cwd(), {
      initParam: null,
      cliArg: this.getArg('--content'),
      envVar: process.env.CONTENT_JSON_PATH,
      configDefault: this.config.workflow.current_content_file
    });
    this.contentPath = contentPath;
    this.content = JSON.parse(await fs.readFile(contentPath, 'utf8'));
    this.dataset = inferDataset(this.content.assets || [], contentPath);
  }

  getArg(name) {
    const idx = process.argv.indexOf(name);
    if (idx !== -1 && process.argv[idx + 1] && !process.argv[idx + 1].startsWith('--')) return process.argv[idx + 1];
    return null;
  }

  async ensureStaticServer() {
    const asset = (this.content.assets || [])[0];
    if (!asset) return; // nothing to verify
    const testUrl = buildAssetUrl(this.staticUrl, this.content.assets || [], asset.asset_id, this.contentPath);
    const ok = await this.httpHeadOk(testUrl);
    if (ok) {
      console.log(`✅ Static server reachable: ${testUrl}`);
      return;
    }
    console.log('⚠️ Static server unreachable, starting local server...');
    this.staticServerProc = spawn(process.execPath, [path.join(process.cwd(), 'src/static-server.js')], {
      stdio: 'inherit'
    });
    // wait up to 3s
    for (let i = 0; i < 6; i++) {
      await this.sleep(500);
      if (await this.httpHeadOk(testUrl)) {
        console.log('✅ Static server started');
        return;
      }
    }
    console.log('⚠️ Static server still unreachable; will use Base64 fallback for images');
  }

  httpHeadOk(url) {
    return new Promise((resolve) => {
      try {
        const req = http.request(url, { method: 'HEAD', timeout: 1500 }, (res) => {
          resolve(res.statusCode && res.statusCode >= 200 && res.statusCode < 400);
        });
        req.on('error', () => resolve(false));
        req.on('timeout', () => { try { req.destroy(); } catch {} resolve(false); });
        req.end();
      } catch {
        resolve(false);
      }
    });
  }

  async connectWS() {
    const host = this.config.websocket.host || '127.0.0.1';
    const port = this.config.websocket.port || 3055;
    const url = `ws://${host}:${port}`;
    await new Promise((resolve, reject) => {
      this.ws = new WebSocket(url);
      this.ws.on('open', () => resolve());
      this.ws.on('error', (e) => reject(e));
      this.ws.on('message', (data) => this.onMessage(data));
    });
    console.log(`✅ WebSocket connected: ${url}`);
    // Join channel
    const joinChan = (this.getArg('--channel') || this.channel || 'weekly-poster').trim();
    await this.wsSend({ type: 'join', channel: joinChan });
    this.channel = joinChan;
    console.log(`📡 Joined channel: ${this.channel}`);
  }

  onMessage(raw) {
    try {
      const msg = JSON.parse(raw.toString());
      console.log(`📨 Received message type: ${msg.type}${msg.message?.id ? ` (id: ${msg.message.id})` : ''}`);

      // Handle broadcast messages (responses from Figma)
      if (msg.type === 'broadcast' && msg.message) {
        const inner = msg.message;
        // Only process if this message has a result (skip command echo)
        if (inner.id && this.pending.has(inner.id) && inner.result !== undefined) {
          const { resolve } = this.pending.get(inner.id);
          this.pending.delete(inner.id);
          console.log(`✅ Got result for command id: ${inner.id}`);
          resolve(inner.result);
          return;
        }
      }
      // Handle system messages
      if (msg.type === 'system') {
        // Channel join confirmation
        if (msg.message && typeof msg.message === 'object' && msg.message.result) {
          console.log(`✅ Channel confirmed: ${msg.channel}`);
        }
      }
    } catch (e) {
      console.error('Message parse error:', e);
    }
  }

  wsSend(payload) {
    return new Promise((resolve, reject) => {
      try {
        this.ws.send(JSON.stringify(payload));
        resolve(true);
      } catch (e) {
        reject(e);
      }
    });
  }

  sendCommand(command, params = {}) {
    const id = String(this.messageId++);
    console.log(`📤 Sending command: ${command} (id: ${id})`);
    return new Promise((resolve, reject) => {
      this.pending.set(id, { resolve, reject });
      this.wsSend({
        id,
        type: 'message',
        channel: this.channel,
        message: { id, command, params }
      });
      setTimeout(() => {
        if (this.pending.has(id)) {
          this.pending.delete(id);
          console.error(`❌ Timeout for command ${command} (id: ${id})`);
          reject(new Error(`Timeout for command ${command}`));
        }
      }, 30000);
    });
  }

  // Robust name normalization: remove spaces/zero-width chars and normalize width
  normalizeName(s) {
    return String(s || '')
      .normalize('NFKC')
      .replace(/[\s\u200B-\u200D\uFEFF]/g, '')
      .trim();
  }

  async deepFindByName(rootNodeId, targetName, types = ['FRAME','SECTION','GROUP','COMPONENT','INSTANCE']) {
    const T = this.normalizeName(targetName);
    try {
      const res = await this.sendCommand('scan_nodes_by_types', { nodeId: rootNodeId, types });
      const hit = (res.nodes || res.matchingNodes || []).find(n => this.normalizeName(n.name) === T);
      return hit || null;
    } catch {
      return null;
    }
  }

  findShallowByName(children, targetName) {
    const T = this.normalizeName(targetName);
    return (children || []).find(c => this.normalizeName(c.name) === T) || null;
  }

  async locateAnchors() {
    const doc = await this.sendCommand('get_document_info', {});
    const wantedFrameName = this.mapping.anchors.frame;

    // 1) Try shallow match on current page
    let frame = this.findShallowByName(doc.children, wantedFrameName);
    // 2) Deep search as fallback
    if (!frame) {
      frame = await this.deepFindByName(doc.id, wantedFrameName);
      if (frame) console.log(`🔎 Resolved frame by deep search: ${frame.name} (${frame.id})`);
    }
    // 3) Selection fallback
    if (!frame) {
      const sel = await this.sendCommand('get_selection', {});
      const first = (sel.selection || []).find(n => n.type === 'FRAME') || sel.selection?.[0];
      if (first) {
        console.warn(`⚠️ Anchor fallback: using selected node "${first.name}" (${first.id})`);
        frame = first;
      }
    }
    if (!frame) throw new Error(`Frame not found after fallback: ${wantedFrameName}`);

    // Resolve container (deep, normalized)
    const frameInfo = await this.sendCommand('get_node_info', { nodeId: frame.id });
    let container = this.findShallowByName(frameInfo.children, this.mapping.anchors.container);
    if (!container) {
      container = await this.deepFindByName(frame.id, this.mapping.anchors.container);
    }
    if (!container) throw new Error(`Container not found: ${this.mapping.anchors.container}`);

    // Resolve cards stack
    const containerInfo = await this.sendCommand('get_node_info', { nodeId: container.id });
    let cards = this.findShallowByName(containerInfo.children, this.mapping.anchors.cards_stack);
    if (!cards) {
      cards = await this.deepFindByName(container.id, this.mapping.anchors.cards_stack);
    }
    if (!cards) throw new Error(`Cards stack not found: ${this.mapping.anchors.cards_stack}`);
    this.cardsContainerId = cards.id;
    console.log(`🔗 Resolved cards stack id by name: ${cards.id}`);

    // Seeds (best-effort)
    const seedsFrame = this.findShallowByName(doc.children, this.mapping.anchors.seeds.frame) || await this.deepFindByName(doc.id, this.mapping.anchors.seeds.frame);
    if (seedsFrame) {
      const seedsInfo = await this.sendCommand('get_node_info', { nodeId: seedsFrame.id });
      const figSeed = this.findShallowByName(seedsInfo.children, this.mapping.anchors.seeds.figure_instance) || await this.deepFindByName(seedsFrame.id, this.mapping.anchors.seeds.figure_instance);
      const bodySeed = this.findShallowByName(seedsInfo.children, this.mapping.anchors.seeds.body_instance) || await this.deepFindByName(seedsFrame.id, this.mapping.anchors.seeds.body_instance);
      this.seeds.figure = figSeed?.id || null;
      this.seeds.body = bodySeed?.id || null;
    }
  }

  createOrderedContentFlow() {
    const blocks = this.content.blocks || [];
    const groups = {};
    const standalone = [];
    const order = [];
    for (let i = 0; i < blocks.length; i++) {
      const b = blocks[i];
      if (b.group_id) {
        if (!groups[b.group_id]) { groups[b.group_id] = []; order.push({ type: 'group', group_id: b.group_id, original_index: i }); }
        groups[b.group_id].push(b);
      } else if (b.type === 'paragraph') {
        standalone.push({ type: 'standalone_paragraph', block: b, original_index: i });
        order.push({ type: 'standalone_paragraph', original_index: i });
      }
    }
    const flow = [];
    let si = 0;
    for (const item of order) {
      if (item.type === 'group') {
        const arr = groups[item.group_id] || [];
        arr.sort((a,b)=> (a.group_seq||0)-(b.group_seq||0));
        flow.push({ type: 'figure_group', group_id: item.group_id, blocks: arr, figures: arr.filter(x=>x.type==='figure'), paragraphs: arr.filter(x=>x.type==='paragraph') });
      } else {
        flow.push(standalone[si++]);
      }
    }
    return flow;
  }

  async createCardInstance(kind) {
    const cfg = this.mapping[kind] || {};
    // Try direct instance creation
    if (cfg.componentId || cfg.componentKey) {
      const direct = await this.sendCommand('create_component_instance', {
        parentId: this.cardsContainerId,
        componentId: cfg.componentId || undefined,
        componentKey: cfg.componentKey || undefined,
        x: 0, y: 0
      });
      if (direct?.success && direct.id) {
        return { id: direct.id, name: direct.name, method: direct.method || 'direct' };
      }
    }
    // Fallback to seed cloning
    const seedId = kind === 'figure' ? this.seeds.figure : this.seeds.body;
    if (!seedId) throw new Error(`No seed instance id for ${kind}`);
    const clone = await this.sendCommand('append_card_to_container', {
      containerId: this.cardsContainerId,
      templateId: seedId,
      insertIndex: -1
    });
    if (clone?.success && clone.newNodeId) return { id: clone.newNodeId, name: clone.newNodeName || 'Cloned Card', method: 'seed-clone' };
    // Some builds return text; attempt parse
    if (clone && clone.containerName && clone.newNodeId) return { id: clone.newNodeId, name: clone.newNodeName || 'Cloned Card', method: 'seed-clone' };
    throw new Error(`Failed to create card: ${JSON.stringify(clone)}`);
  }

  async dfsFindChildIdByName(nodeId, name) {
    const info = await this.sendCommand('get_node_info', { nodeId });
    const target = String(name || '').trim();
    const stack = [info];
    while (stack.length) {
      const n = stack.pop();
      if (n?.name === target) return n.id;
      if (n?.children) for (const ch of n.children) stack.push(ch);
    }
    return null;
  }

  async setText(nodeId, text) {
    await this.sendCommand('set_text_content', { nodeId, text: text || '' });
    await this.sendCommand('set_text_auto_resize', { nodeId, autoResize: 'HEIGHT' });
  }

  async throttleBase64() {
    const now = Date.now();
    // remove >1s
    this.base64Sent = this.base64Sent.filter(t => now - t < 1000);
    if (this.base64Sent.length >= this.base64Rate) {
      const wait = 1000 - (now - this.base64Sent[0]);
      await this.sleep(Math.max(0, wait));
      this.base64Sent = this.base64Sent.filter(t => Date.now() - t < 1000);
    }
    this.base64Sent.push(Date.now());
  }

  async fillFigureCard(instanceId, group) {
    const slots = this.mapping.anchors?.slots || {};
    const figures = group.figures || [];
    const hasTitle = figures.some(f => !!f.title);
    const firstTitle = (figures.find(f => f.title)?.title) || '';
    // Aggregate credits across figures → unique tokens
    const sCfg = this.mapping.source || {};
    const prefix = sCfg.prefix ?? 'Source: ';
    const mode = sCfg.mode || 'inline'; // inline | label
    const splitRe = /[、，,;；／/|]+/;
    const stripPrefix = (t) => String(t||'').replace(/^(?:source|来源)\s*[:：]\s*/i, '').trim();
    const creditsTokens = [];
    const seen = new Set();
    for (const f of figures) {
      const raw = String(f?.credit || '');
      if (!raw) continue;
      for (const tok of raw.split(splitRe)) {
        const clean = stripPrefix(tok);
        const key = clean.toLowerCase();
        if (clean && !seen.has(key)) { seen.add(key); creditsTokens.push(clean); }
      }
    }
    const hasSource = creditsTokens.length > 0;
    const assetPath = this.mapping.images?.asset_path || 'image.asset_id';
    const images = figures.map(f => ({ asset_id: this.getByPath(f, assetPath) })).filter(x => !!x.asset_id);

    // title
    const titleName = slots.figure?.title_text || 'titleText';
    const titleId = await this.dfsFindChildIdByName(instanceId, titleName);
    if (titleId) await this.setText(titleId, firstTitle);
    // source (renderer-owned labeling)
    const sourceName = slots.figure?.source_text || 'sourceText';
    const sourceId = await this.dfsFindChildIdByName(instanceId, sourceName);
    if (sourceId) {
      let text = '';
      if (hasSource) {
        const inlineText = creditsTokens.join(', ');
        text = (mode === 'inline') ? (prefix + inlineText) : inlineText;
        // collapse duplicate prefixes
        text = text.replace(/^(?:Source:\s*)+/i, 'Source: ');
      }
      await this.sendCommand('set_text_content', { nodeId: sourceId, text });
      const autoSize = (this.mapping.source?.auto_size || 'HEIGHT');
      await this.sendCommand('set_text_auto_resize', { nodeId: sourceId, autoResize: autoSize });
      if (autoSize === 'HEIGHT') {
        const containerName = slots.figure?.source || 'slot:SOURCE';
        const containerId = await this.dfsFindChildIdByName(instanceId, containerName);
        if (containerId) {
          const box = await this.sendCommand('get_node_info', { nodeId: containerId });
          const srcInfo = await this.sendCommand('get_node_info', { nodeId: sourceId });
          const w = box?.absoluteBoundingBox?.width;
          const h = srcInfo?.absoluteBoundingBox?.height;
          if (w && h) {
            await this.sendCommand('resize_node', { nodeId: sourceId, width: w, height: h });
            console.log(`📐 Source resized width=${w}`);
          }
        }
      }
      console.log(`📄 Source mode=${mode} text="${text}" credits=${JSON.stringify(creditsTokens)}`);
    }
    // visibility
    const props = {};
    const titleProp = this.mapping.title?.visible_prop || 'showTitle';
    const sourceProp = this.mapping.source?.visible_prop || 'showSource';
    props[titleProp] = !!hasTitle;
    props[sourceProp] = !!hasSource;
    // optional label visibility (best-effort)
    props['showSourceLabel'] = (mode === 'label');
    const imgSlots = (slots.images || this.mapping.anchors.image_slots || []);
    for (let i = 2; i <= Math.min(imgSlots.length, this.mapping.images?.max_images || imgSlots.length); i++) {
      const slotName = imgSlots[i-1];
      const visibilityProp = (this.mapping.images?.visibility_props || {})[slotName];
      if (visibilityProp) props[visibilityProp] = images.length >= i;
    }
    await this.sendCommand('set_instance_properties_by_base', { nodeId: instanceId, properties: props });

    // images
    const imageNodeNames = imgSlots;
    for (let i = 0; i < Math.min(images.length, imageNodeNames.length); i++) {
      const slotName = imageNodeNames[i];
      const imgNodeId = await this.dfsFindChildIdByName(instanceId, slotName);
      if (!imgNodeId) continue;
      const url = buildAssetUrl(this.staticUrl, this.content.assets || [], images[i].asset_id, this.contentPath);
      if (await this.httpHeadOk(url)) {
        await this.sendCommand('set_image_fill', { nodeId: imgNodeId, imageUrl: url, scaleMode: 'FILL', opacity: 1 });
      } else {
        // fallback Base64
        const localPath = path.join(process.cwd(), 'docx2json', 'assets', this.dataset, `${images[i].asset_id}.png`);
        try {
          const buf = await fs.readFile(localPath);
          const b64 = buf.toString('base64');
          await this.throttleBase64();
          await this.sendCommand('set_image_fill', { nodeId: imgNodeId, imageBase64: b64, scaleMode: 'FILL', opacity: 1 });
        } catch (e) {
          console.warn(`⚠️ Base64 fallback failed for ${images[i].asset_id}: ${e.message}`);
        }
      }
    }
    // Fallback: fill image grid when named slots are absent
    if (images.length > 0 && imageNodeNames.length === 0) {
      const gridName = slots.figure?.image_grid || 'slot:IMAGE_GRID';
      const gridId = await this.dfsFindChildIdByName(instanceId, gridName);
      if (gridId) {
        console.log('🔍 Fallback: scanned IMAGE_GRID to place images');
        const gridInfo = await this.sendCommand('get_node_info', { nodeId: gridId });
        const targets = (gridInfo.children || []).slice(0, images.length);
        for (let i = 0; i < targets.length; i++) {
          const url = buildAssetUrl(this.staticUrl, this.content.assets || [], images[i].asset_id, this.contentPath);
          try {
            if (await this.httpHeadOk(url)) {
              await this.sendCommand('set_image_fill', { nodeId: targets[i].id, imageUrl: url, scaleMode: 'FILL', opacity: 1 });
            }
          } catch {}
        }
      }
    }
  }

  async fillBodyCard(instanceId, item) {
    const slots = this.mapping.anchors?.slots || {};
    const bodySlot = slots.body?.body || 'slot:BODY';
    const bodyId = await this.dfsFindChildIdByName(instanceId, bodySlot);
    if (bodyId) await this.setText(bodyId, item.block?.text || '');
  }

  getByPath(obj, pathStr) {
    try { return (pathStr || '').split('.').reduce((o,k)=> (o && o[k] != null ? o[k] : undefined), obj); } catch { return undefined; }
  }

  async fillHeader() {
    try {
      const doc = await this.sendCommand('get_document_info', {});
      const frame = (doc.children || []).find((c) => c.name === this.mapping.anchors.frame);
      if (!frame) return;
      const frameInfo = await this.sendCommand('get_node_info', { nodeId: frame.id });
      const header = this.mapping.anchors.header || {};
      const meta = this.content.doc || {};
      const month = this.formatMonth(meta.date || '');
      const setByName = async (name, text) => {
        if (!name) return;
        const id = await this.dfsFindChildIdByName(frame.id, name);
        if (id) await this.setText(id, text);
      };
      await setByName(header.title, meta.title || '');
      await setByName(header.date, meta.date || '');
      await setByName(header.month, month || '');
    } catch (e) {
      console.warn('⚠️ fillHeader skipped:', e.message);
    }
  }

  formatMonth(dateStr) {
    const m = String(dateStr||'').match(/\d{4}-(\d{2})-\d{2}/); if (m) return m[1];
    const m2 = String(dateStr||'').match(/\d{4}(\d{2})\d{2}/); if (m2) return m2[1];
    return '';
  }

  async run() {
    console.log('🚀 Weekly Poster Orchestration starting...');
    await this.loadConfig();
    await this.resolveContent();
    await this.ensureStaticServer();
    await this.connectWS();
    await this.locateAnchors();
    await this.fillHeader();

    const flow = this.createOrderedContentFlow();
    console.log(`📋 Content flow items: ${flow.length}`);

    for (let i = 0; i < flow.length; i++) {
      const item = flow[i];
      const kind = item.type === 'figure_group' ? 'figure' : 'body';
      try {
        const inst = await this.createCardInstance(kind);
        this.report.created.push({ index: i, id: inst.id, method: inst.method, kind });
        if (kind === 'figure') await this.fillFigureCard(inst.id, item);
        else await this.fillBodyCard(inst.id, item);
        console.log(`✅ Filled #${i+1} ${kind} card`);
      } catch (e) {
        console.error(`❌ Failed item #${i+1}:`, e.message);
        this.report.errors.push({ index: i, error: e.message });
      }
    }

    // Summary
    const summary = {
      dataset: this.dataset,
      staticServer: this.staticUrl,
      channel: this.channel,
      total: flow.length,
      created: this.report.created.length,
      errors: this.report.errors.length,
      createdDetails: this.report.created.slice(0,10)
    };
    console.log('\n📊 Run Summary:');
    console.log(JSON.stringify(summary, null, 2));
  }

  async close() {
    try { if (this.ws) this.ws.close(); } catch {}
    if (this.staticServerProc) {
      try { this.staticServerProc.kill(); } catch {}
    }
  }

  sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
}

async function main() {
  const runner = new WeeklyPosterRunner();
  try {
    await runner.run();
  } catch (e) {
    console.error('💥 Orchestration failed:', e.message);
  } finally {
    await runner.close();
  }
}

main();
</file>

<file path="src/cursor_mcp_plugin/ui.html">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cursor MCP Plugin</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        margin: 0;
        padding: 20px;
        color: #e0e0e0;
        background-color: #1e1e1e;
      }
      .container {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      h1 {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 10px;
        color: #ffffff;
      }
      h2 {
        font-size: 14px;
        font-weight: 600;
        margin-top: 20px;
        margin-bottom: 8px;
        color: #ffffff;
      }
      button {
        background-color: #18a0fb;
        border: none;
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        margin-top: 8px;
        margin-bottom: 8px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }
      button:hover {
        background-color: #0d8ee0;
      }
      button.secondary {
        background-color: #3d3d3d;
        color: #e0e0e0;
      }
      button.secondary:hover {
        background-color: #4d4d4d;
      }
      button:disabled {
        background-color: #333333;
        color: #666666;
        cursor: not-allowed;
      }
      input {
        border: 1px solid #444444;
        border-radius: 4px;
        padding: 8px;
        margin-bottom: 12px;
        font-size: 14px;
        width: 100%;
        box-sizing: border-box;
        background-color: #2d2d2d;
        color: #e0e0e0;
      }
      label {
        display: block;
        margin-bottom: 4px;
        font-size: 12px;
        font-weight: 500;
        color: #cccccc;
      }
      .status {
        margin-top: 16px;
        padding: 12px;
        border-radius: 6px;
        font-size: 14px;
      }
      .status.connected {
        background-color: #1a472a;
        color: #4ade80;
      }
      .status.disconnected {
        background-color: #471a1a;
        color: #ff9999;
      }
      .status.info {
        background-color: #1a3147;
        color: #66b3ff;
      }
      .section {
        margin-bottom: 24px;
      }
      .hidden {
        display: none;
      }
      .logo {
        width: 50px;
        height: 50px;
      }
      .header {
        display: flex;
        align-items: center;
        margin-bottom: 16px;
      }
      .header-text {
        margin-left: 12px;
      }
      .header-text h1 {
        margin: 0;
        font-size: 16px;
      }
      .header-text p {
        margin: 4px 0 0 0;
        font-size: 12px;
        color: #999999;
      }
      .tabs {
        display: flex;
        border-bottom: 1px solid #444444;
        margin-bottom: 16px;
      }
      .tab {
        padding: 8px 16px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        color: #999999;
      }
      .tab.active {
        border-bottom: 2px solid #18a0fb;
        color: #18a0fb;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .link {
        color: #18a0fb;
        text-decoration: none;
        cursor: pointer;
      }
      .link:hover {
        text-decoration: underline;
      }
      .header-logo {
        padding: 16px;
        border-radius: 16px;
        background-color: #333;
      }
      .header-logo-image {
        width: 24px;
        height: 24px;
        object-fit: contain;
      }
      /* Progress styles */
      .operation-complete {
        color: #4ade80;
      }
      .operation-error {
        color: #ff9999;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header-logo">
          <img
            class="header-logo-image"
            src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAMAAAANIilAAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAJcEhZcwAAEJwAABCcASbNOjQAAAB1UExURUdwTP////////////////39/f////////////////////////////7+/v////////////39/f////////////////////////////////////////////////////39/fn5+ejo6P///+rq6uXl5f////Ly8gf4a04AAAAkdFJOUwAOdkZCfz04zIgbT0pkIagnm7C9b6C2LWqSxBMyB11W2Ovsy3D12ZYAAALtSURBVEjHndcJt6ogEADgXNAUcWlxSQVN3/3/P/EBAgJpWdM9p5ue78xANE2n05vIUduffgvn1oA0bX+hvRc1DYjTPHe+tiGIoqhx4zTNq/y72lMURQtmqasuPc4dAmgwfWuZrqquiw8uNnC5BRJT3YXhIZ7Xris0oLjlmOrArz7VHpOb6wpNee0ITVMHvvd25/qgvtFwla8dpxV7xnTi7dbed7iuTY16lZoV7iXQb3cqRgjVgoviKTZSUw2719pbD2OEVu5yjnqeOpZ75lMMobVzfUcwC6lrofGJpdb3jGtj6TkkNKRWtXMsU+ciNdfQUwe+zZ7/vo1CYYgv39G/kShMS6mHL+g8F96K2Uqi52E6j3DFnsc4uR/hMwugYd9bOLoeSTvPE1yx4/sLh9B9fKbziHVM3z/G+dKb5wdKdysxsNCc4+2l/yk7EnrOVhwGBt9auqJ0t9gR13C4cl77bdil88SPuK9jxrXksHjab48Mwo+4ha3aSbZJ52JpC4GFbY7OdsVst4Lls/mKZe1y6fXTonS3RFsIN7C5dAJsO+WiI21jbd8xesFEtoUdLLjH+qGNJ9WRuj3MOOQNycaV6khvsLc0MxsD2Uq7bhcHuBZh4rFdujjT1c6GkaXtszCx3sW3MRRfNjwiI7EjGjGfFjZwUgM9CuNggqRVXz+vOGDTBOCP5UnHE73ghjK1jYNlEIma9UnHBb/qdkvq1MSQjk4yCvGk4UneQylLbWAIio3I1t26q4sNTuM01tqQe9+My5pYv9wk8Ypv92w7JpXYulGoD8aJ3C/bUUp8tW5EuTa2oXI7ZGLzahZYE0l03QqZWI8Lfh1lw+zxEoNIrF8Dm/NQT8rzgz+WP/oQmL6Ud4pud/4DZzMWPKjXZfJufOyiVzzKV4/609yelDaWiZsDc6+DSwOLxNqxeD/6Ah3zf674+Kyf3xUeDi3WDFIKzCpOv/5phB4MD+cs/OWXVdych/GBf/xJd4pL9+1i/wOElMO5v/co4wAAAABJRU5ErkJggg=="
          />
        </div>
        <div class="header-text">
          <h1>Cursor Talk To Figma Plugin</h1>
          <p>Connect Figma to Cursor AI using MCP</p>
        </div>
      </div>

      <div class="tabs">
        <div id="tab-connection" class="tab active">Connection</div>
        <div id="tab-about" class="tab">About</div>
      </div>

      <div id="content-connection" class="tab-content active">
        <div class="section">
          <label for="port">WebSocket Server Port</label>
          <div style="display: flex; gap: 8px">
            <input
              type="number"
              id="port"
              placeholder="3055"
              value="3055"
              min="1024"
              max="65535"
            />
            <button id="btn-connect" class="primary">Connect</button>
          </div>
        </div>

        <div class="section">
          <label for="channel">Channel</label>
          <div style="display: flex; gap: 8px">
            <input
              type="text"
              id="channel"
              placeholder="e.g. my-weekly-channel"
            />
            <button id="btn-join-channel" class="secondary">Join</button>
          </div>
        </div>

        <div id="connection-status" class="status disconnected">
          Not connected to Cursor MCP server
        </div>

        <div class="section">
          <button id="btn-disconnect" class="secondary" disabled>
            Disconnect
          </button>
        </div>
        
        <!-- Add Progress Bar Section -->
        <div id="progress-container" class="section hidden">
          <h2>Operation Progress</h2>
          <div id="progress-message">No operation in progress</div>
          <div style="width: 100%; background-color: #444; border-radius: 4px; margin-top: 8px;">
            <div id="progress-bar" style="width: 0%; height: 8px; background-color: #18a0fb; border-radius: 4px; transition: width 0.3s;"></div>
          </div>
          <div style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 12px;">
            <div id="progress-status">Not started</div>
            <div id="progress-percentage">0%</div>
          </div>
        </div>
      </div>

      <div id="content-about" class="tab-content">
        <div class="section">
          <h2>About Cursor Talk To Figma Plugin</h2>
          <p>
            This plugin allows Cursor AI to communicate with Figma, enabling
            AI-assisted design operations.
            <a
              class="link"
              onclick="window.open(`https://github.com/grab/cursor-talk-to-figma-mcp`, '_blank')"
              >Github</a
            >
          </p>
          <p>Version: 1.0.0</p>

          <h2>How to Use</h2>
          <ol>
            <li>Make sure the MCP server is running in Cursor</li>
            <li>Connect to the server using the port number (default: 3055)</li>
            <li>Once connected, you can interact with Figma through Cursor</li>
          </ol>
        </div>
      </div>
    </div>

    <script>
      // WebSocket connection state
      const state = {
        connected: false,
        socket: null,
        serverPort: 3055,
        pendingRequests: new Map(),
        channel: null,
      };

      // UI Elements
      const portInput = document.getElementById("port");
      const connectButton = document.getElementById("btn-connect");
      const disconnectButton = document.getElementById("btn-disconnect");
      const channelInput = document.getElementById("channel");
      const joinChannelButton = document.getElementById("btn-join-channel");
      const connectionStatus = document.getElementById("connection-status");

      // Tabs
      const tabs = document.querySelectorAll(".tab");
      const tabContents = document.querySelectorAll(".tab-content");

      // Add UI elements for progress tracking
      const progressContainer = document.getElementById("progress-container");
      const progressBar = document.getElementById("progress-bar");
      const progressMessage = document.getElementById("progress-message");
      const progressStatus = document.getElementById("progress-status");
      const progressPercentage = document.getElementById("progress-percentage");

      // Initialize UI
      function updateConnectionStatus(isConnected, message) {
        state.connected = isConnected;
        connectionStatus.innerHTML =
          message ||
          (isConnected
            ? "Connected to Cursor MCP server"
            : "Not connected to Cursor MCP server");
        connectionStatus.className = `status ${
          isConnected ? "connected" : "disconnected"
        }`;

        connectButton.disabled = isConnected;
        disconnectButton.disabled = !isConnected;
        portInput.disabled = isConnected;
        channelInput.disabled = !isConnected ? false : false; // allow channel change even when connected
        joinChannelButton.disabled = !isConnected;
      }

      // Connect to WebSocket server
      async function connectToServer(port) {
        try {
          if (state.connected && state.socket) {
            updateConnectionStatus(true, "Already connected to server");
            return;
          }

          state.serverPort = port;
          state.socket = new WebSocket(`ws://localhost:${port}`);

          state.socket.onopen = () => {
            // Determine desired channel: input → saved → random
            let desired = (channelInput.value || '').trim();
            if (!desired && state.channel) desired = state.channel;
            if (!desired) desired = generateChannelName();
            console.log("Joining channel:", desired);
            state.channel = desired;

            // Persist channel via plugin clientStorage
            parent.postMessage({ pluginMessage: { type: 'update-settings', channel: state.channel } }, '*');

            // Join the channel using the same format as App.tsx
            state.socket.send(
              JSON.stringify({
                type: "join",
                channel: desired.trim(),
              })
            );
          };

          state.socket.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              console.log("Received message:", data);

              if (data.type === "system") {
                // Successfully joined channel
                if (data.message && data.message.result) {
                  state.connected = true;
                  const channelName = data.channel;
                  updateConnectionStatus(
                    true,
                    `Connected to server on port ${port} in channel: <strong>${channelName}</strong>`
                  );

                  // Notify the plugin code
                  parent.postMessage(
                    {
                      pluginMessage: {
                        type: "notify",
                        message: `Connected to Cursor MCP server on port ${port} in channel: ${channelName}`,
                      },
                    },
                    "*"
                  );
                }
                // Optional: server-instructed channel switch
                if (data.event === 'system:join-channel' && data.channel) {
                  const newChan = String(data.channel).trim();
                  if (newChan && newChan !== state.channel) {
                    console.log('Switching channel per server instruction:', newChan);
                    state.channel = newChan;
                    channelInput.value = newChan;
                    // Persist
                    parent.postMessage({ pluginMessage: { type: 'update-settings', channel: state.channel } }, '*');
                    // Join new channel
                    state.socket.send(JSON.stringify({ type: 'join', channel: newChan }));
                    updateConnectionStatus(true, `Connected to server on port ${port} in channel: <strong>${newChan}</strong>`);
                  }
                }
              } else if (data.type === "error") {
                console.error("Error:", data.message);
                updateConnectionStatus(false, `Error: ${data.message}`);
                state.socket.close();
              }

              handleSocketMessage(data);
            } catch (error) {
              console.error("Error parsing message:", error);
            }
          };

          state.socket.onclose = () => {
            state.connected = false;
            state.socket = null;
            updateConnectionStatus(false, "Disconnected from server");
          };

          state.socket.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateConnectionStatus(false, "Connection error");
            state.connected = false;
            state.socket = null;
          };
        } catch (error) {
          console.error("Connection error:", error);
          updateConnectionStatus(
            false,
            `Connection error: ${error.message || "Unknown error"}`
          );
        }
      }

      // Join channel on button click
      joinChannelButton.addEventListener('click', () => {
        if (!state.connected || !state.socket) {
          updateConnectionStatus(false, 'Not connected to server');
          return;
        }
        const newChan = (channelInput.value || '').trim();
        if (!newChan) {
          updateConnectionStatus(true, 'Please enter a channel name');
          return;
        }
        state.channel = newChan;
        // Persist
        parent.postMessage({ pluginMessage: { type: 'update-settings', channel: state.channel } }, '*');
        state.socket.send(JSON.stringify({ type: 'join', channel: newChan }));
        updateConnectionStatus(true, `Connected to server on port ${state.serverPort} in channel: <strong>${newChan}</strong>`);
      });

      // Disconnect from websocket server
      function disconnectFromServer() {
        if (state.socket) {
          state.socket.close();
          state.socket = null;
          state.connected = false;
          updateConnectionStatus(false, "Disconnected from server");
        }
      }

      // Handle messages from the WebSocket
      async function handleSocketMessage(payload) {
        const data = payload.message;
        console.log("handleSocketMessage", data);

        // If it's a response to a previous request
        if (data.id && state.pendingRequests.has(data.id)) {
          const { resolve, reject } = state.pendingRequests.get(data.id);
          state.pendingRequests.delete(data.id);

          if (data.error) {
            reject(new Error(data.error));
          } else {
            resolve(data.result);
          }
          return;
        }

        // If it's a new command
        if (data.command) {
          try {
            // Send the command to the plugin code
            parent.postMessage(
              {
                pluginMessage: {
                  type: "execute-command",
                  id: data.id,
                  command: data.command,
                  params: data.params,
                },
              },
              "*"
            );
          } catch (error) {
            // Send error back to WebSocket
            sendErrorResponse(
              data.id,
              error.message || "Error executing command"
            );
          }
        }
      }

      // Send a command to the WebSocket server
      async function sendCommand(command, params) {
        return new Promise((resolve, reject) => {
          if (!state.connected || !state.socket) {
            reject(new Error("Not connected to server"));
            return;
          }

          const id = generateId();
          state.pendingRequests.set(id, { resolve, reject });

          state.socket.send(
            JSON.stringify({
              id,
              type: "message",
              channel: state.channel,
              message: {
                id,
                command,
                params,
              },
            })
          );

          // Set timeout to reject the promise after 30 seconds
          setTimeout(() => {
            if (state.pendingRequests.has(id)) {
              state.pendingRequests.delete(id);
              reject(new Error("Request timed out"));
            }
          }, 30000);
        });
      }

      // Send success response back to WebSocket
      function sendSuccessResponse(id, result) {
        if (!state.connected || !state.socket) {
          console.error("Cannot send response: socket not connected");
          return;
        }

        state.socket.send(
          JSON.stringify({
            id,
            type: "message",
            channel: state.channel,
            message: {
              id,
              result,
            },
          })
        );
      }

      // Send error response back to WebSocket
      function sendErrorResponse(id, errorMessage) {
        if (!state.connected || !state.socket) {
          console.error("Cannot send error response: socket not connected");
          return;
        }

        state.socket.send(
          JSON.stringify({
            id,
            type: "message",
            channel: state.channel,
            message: {
              id,
              error: errorMessage,
              result: {}
            },
          })
        );
      }

      // Helper to generate unique IDs
      function generateId() {
        return (
          Date.now().toString(36) + Math.random().toString(36).substr(2, 5)
        );
      }

      // Add this function after the generateId() function
      function generateChannelName() {
        const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
        let result = "";
        for (let i = 0; i < 8; i++) {
          result += characters.charAt(
            Math.floor(Math.random() * characters.length)
          );
        }
        return result;
      }

      // Tab switching
      tabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          tabs.forEach((t) => t.classList.remove("active"));
          tabContents.forEach((c) => c.classList.remove("active"));

          tab.classList.add("active");
          const contentId = "content-" + tab.id.split("-")[1];
          document.getElementById(contentId).classList.add("active");
        });
      });

      // Connect to server
      connectButton.addEventListener("click", () => {
        const port = parseInt(portInput.value, 10) || 3055;
        updateConnectionStatus(false, "Connecting...");
        connectionStatus.className = "status info";
        connectToServer(port);
      });

      // Disconnect from server
      disconnectButton.addEventListener("click", () => {
        updateConnectionStatus(false, "Disconnecting...");
        connectionStatus.className = "status info";
        disconnectFromServer();
      });

      // Function to update progress UI
      function updateProgressUI(progressData) {
        // Show progress container if hidden
        progressContainer.classList.remove("hidden");
        
        // Update progress bar
        const progress = progressData.progress || 0;
        progressBar.style.width = `${progress}%`;
        progressPercentage.textContent = `${progress}%`;
        
        // Update message
        progressMessage.textContent = progressData.message || "Operation in progress";
        
        // Update status text based on operation state
        if (progressData.status === 'started') {
          progressStatus.textContent = "Started";
          progressStatus.className = "";
        } else if (progressData.status === 'in_progress') {
          progressStatus.textContent = "In Progress";
          progressStatus.className = "";
        } else if (progressData.status === 'completed') {
          progressStatus.textContent = "Completed";
          progressStatus.className = "operation-complete";
          
          // Hide progress container after 5 seconds
          setTimeout(() => {
            progressContainer.classList.add("hidden");
          }, 5000);
        } else if (progressData.status === 'error') {
          progressStatus.textContent = "Error";
          progressStatus.className = "operation-error";
        }
      }

      // Send operation progress update to server
      function sendProgressUpdateToServer(progressData) {
        if (!state.connected || !state.socket) {
          console.error("Cannot send progress update: socket not connected");
          return;
        }
        
        console.log("Sending progress update to server:", progressData);
        
        state.socket.send(
          JSON.stringify({
            id: progressData.commandId,
            type: "progress_update",
            channel: state.channel,
            message: {
              id: progressData.commandId,
              type: "progress_update",
              data: progressData
            }
          })
        );
      }
      
      // Reset progress UI
      function resetProgressUI() {
        progressContainer.classList.add("hidden");
        progressBar.style.width = "0%";
        progressMessage.textContent = "No operation in progress";
        progressStatus.textContent = "Not started";
        progressStatus.className = "";
        progressPercentage.textContent = "0%";
      }

      // Listen for messages from the plugin code
      window.onmessage = (event) => {
        const message = event.data.pluginMessage;
        if (!message) return;

        console.log("Received message from plugin:", message);

        switch (message.type) {
          case "init-settings":
            if (message.settings) {
              if (message.settings.serverPort) {
                state.serverPort = message.settings.serverPort;
                portInput.value = String(state.serverPort);
              }
              if (message.settings.channel) {
                state.channel = message.settings.channel;
                channelInput.value = String(state.channel);
              }
            }
            break;
          case "connection-status":
            updateConnectionStatus(message.connected, message.message);
            break;
          case "auto-connect":
            connectButton.click();
            break;
          case "auto-disconnect":
            disconnectButton.click();
            break;
          case "command-result":
            // Forward the result from plugin code back to WebSocket
            sendSuccessResponse(message.id, message.result);
            break;
          case "command-error":
            // Forward the error from plugin code back to WebSocket
            sendErrorResponse(message.id, message.error);
            break;
          case "command_progress":
            // Update UI with progress information
            updateProgressUI(message);
            // Forward progress update to server
            sendProgressUpdateToServer(message);
            break;
        }
      };
    </script>
  </body>
</html>
</file>

<file path="readme.md">
# Cursor Talk to Figma MCP

This project implements a Model Context Protocol (MCP) integration between Cursor AI and Figma, allowing Cursor to communicate with Figma for reading designs and modifying them programmatically.

https://github.com/user-attachments/assets/129a14d2-ed73-470f-9a4c-2240b2a4885c

## Project Structure

- `src/talk_to_figma_mcp/` - TypeScript MCP server for Figma integration
- `src/cursor_mcp_plugin/` - Figma plugin for communicating with Cursor
- `src/socket.ts` - WebSocket server that facilitates communication between the MCP server and Figma plugin

## Get Started

1. Install Bun if you haven't already:

```bash
curl -fsSL https://bun.sh/install | bash
```

2. Run setup, this will also install MCP in your Cursor's active project

```bash
bun setup
```

3. Start the Websocket server

```bash
bun socket
```

4. **NEW** Install Figma plugin from [Figma community page](https://www.figma.com/community/plugin/1485687494525374295/cursor-talk-to-figma-mcp-plugin) or [install locally](#figma-plugin)

## Quick Video Tutorial

[Video Link](https://www.linkedin.com/posts/sonnylazuardi_just-wanted-to-share-my-latest-experiment-activity-7307821553654657024-yrh8)

## Design Automation Example

**Bulk text content replacement**

Thanks to [@dusskapark](https://github.com/dusskapark) for contributing the bulk text replacement feature. Here is the [demo video](https://www.youtube.com/watch?v=j05gGT3xfCs).

**Instance Override Propagation**
Another contribution from [@dusskapark](https://github.com/dusskapark)
Propagate component instance overrides from a source instance to multiple target instances with a single command. This feature dramatically reduces repetitive design work when working with component instances that need similar customizations. Check out our [demo video](https://youtu.be/uvuT8LByroI).

## Development Setup

To develop, update your mcp config to direct to your local directory.

```json
{
  "mcpServers": {
    "TalkToFigma": {
      "command": "bun",
      "args": ["/path-to-repo/src/talk_to_figma_mcp/server.ts"]
    }
  }
}
```

## Manual Setup and Installation

### MCP Server: Integration with Cursor

Add the server to your Cursor MCP configuration in `~/.cursor/mcp.json`:

```json
{
  "mcpServers": {
    "TalkToFigma": {
      "command": "bunx",
      "args": ["cursor-talk-to-figma-mcp@latest"]
    }
  }
}
```

### WebSocket Server

Start the WebSocket server:

```bash
bun socket
```

### Figma Plugin

1. In Figma, go to Plugins > Development > New Plugin
2. Choose "Link existing plugin"
3. Select the `src/cursor_mcp_plugin/manifest.json` file
4. The plugin should now be available in your Figma development plugins

## Windows + WSL Guide

1. Install bun via powershell

```bash
powershell -c "irm bun.sh/install.ps1|iex"
```

2. Uncomment the hostname `0.0.0.0` in `src/socket.ts`

```typescript
// uncomment this to allow connections in windows wsl
hostname: "0.0.0.0",
```

3. Start the websocket

```bash
bun socket
```

## Usage

1. Start the WebSocket server
2. Install the MCP server in Cursor
3. Open Figma and run the Cursor MCP Plugin
4. Connect the plugin to the WebSocket server by joining a channel using `join_channel`
5. Use Cursor to communicate with Figma using the MCP tools

## Weekly Poster Workflow (DOCX → Figma)

This repo includes an end-to-end workflow that turns weekly DOCX content (pre-converted to JSON) into a Figma poster based on a fixed template.

Steps
- Start WebSocket relay: `bun socket`
- Open Figma, run the "Cursor Talk To Figma MCP" plugin
- In plugin UI, set a stable `Channel` (or pass `--channel` to the script)
- Run the orchestration script:

```bash
# Auto-discovers the latest content JSON under docx2json/
node scripts/run_weekly_poster.js --channel my-weekly

# Or target a specific content JSON
node scripts/run_weekly_poster.js --content ./docx2json/250818_summer_break_content.json --channel weekly-250818
```

Notes
- No manual config edits are required per dataset. Dataset is inferred from `assets[0].filename` or the content filename stem.
- Images are fetched by URL first. If the static server is unavailable, the script and server will automatically fall back to Base64 with rate limiting (`config.asset_transfer.base64_rate_limit`).
- Header fields (title/date/month) are filled from `content.doc` and all text nodes are set to auto-resize (HEIGHT).
- Visibility is driven by component boolean properties discovered at runtime (no hardcoded `PropertyName#ID`). Missing non-essential image visibility props default to hidden.

Acceptance Criteria
- Zero per-week manual edits; images auto-resolve per dataset.
- Correct card count/order/visibility with header filled; text auto-resizes.
- Channels are explicit and reproducible via UI field or `--channel` flag.

## Static Assets Server

The static server exposes `docx2json/assets` with strict path normalization.

Config example
```json
{
  "static_server": {
    "port": 3056,
    "host": "127.0.0.1",
    "baseDir": "../docx2json/assets",
    "publicRoute": "/assets"
  }
}
```

Routes
- `GET /assets/<dataset>/<filename>` → serves `docx2json/assets/<dataset>/<filename>` with safe join

Quick checks
```bash
node src/static-server.js &
curl -I http://127.0.0.1:3056/assets/250818_summer_break/img_76f7bfb095b6.png   # 200
curl -I 'http://127.0.0.1:3056/assets/../../etc/passwd'                         # 403
curl -I http://127.0.0.1:3056/assets/250818_summer_break/not-exist.png          # 404
```

## Troubleshooting

- Figma plugin not connected: ensure `bun socket` is running, and join the same channel in UI and scripts.
- Images not showing: verify static server is reachable; if not, Base64 fallback should kick in (check logs). Adjust `asset_transfer.base64_max_size`/`base64_rate_limit` in `config/server-config.json` if needed.
- Property discovery fail-fast: if essential properties (e.g., `showTitle`, `showSource`) cannot be mapped, the workflow halts with a clear error listing available base names—rename boolean properties in your template accordingly.

## MCP Tools

The MCP server provides the following tools for interacting with Figma:

### Document & Selection

- `get_document_info` - Get information about the current Figma document
- `get_selection` - Get information about the current selection
- `read_my_design` - Get detailed node information about the current selection without parameters
- `get_node_info` - Get detailed information about a specific node
- `get_nodes_info` - Get detailed information about multiple nodes by providing an array of node IDs

### Annotations

- `get_annotations` - Get all annotations in the current document or specific node
- `set_annotation` - Create or update an annotation with markdown support
- `set_multiple_annotations` - Batch create/update multiple annotations efficiently
- `scan_nodes_by_types` - Scan for nodes with specific types (useful for finding annotation targets)

### Prototyping & Connections

- `get_reactions` - Get all prototype reactions from nodes with visual highlight animation
- `set_default_connector` - Set a copied FigJam connector as the default connector style for creating connections (must be set before creating connections)
- `create_connections` - Create FigJam connector lines between nodes, based on prototype flows or custom mapping

### Creating Elements

- `create_rectangle` - Create a new rectangle with position, size, and optional name
- `create_frame` - Create a new frame with position, size, and optional name
- `create_text` - Create a new text node with customizable font properties

### Modifying text content

- `scan_text_nodes` - Scan text nodes with intelligent chunking for large designs
- `set_text_content` - Set the text content of a single text node
- `set_multiple_text_contents` - Batch update multiple text nodes efficiently

### Auto Layout & Spacing

- `set_layout_mode` - Set the layout mode and wrap behavior of a frame (NONE, HORIZONTAL, VERTICAL)
- `set_padding` - Set padding values for an auto-layout frame (top, right, bottom, left)
- `set_axis_align` - Set primary and counter axis alignment for auto-layout frames
- `set_layout_sizing` - Set horizontal and vertical sizing modes for auto-layout frames (FIXED, HUG, FILL)
- `set_item_spacing` - Set distance between children in an auto-layout frame

### Styling

- `set_fill_color` - Set the fill color of a node (RGBA)
- `set_stroke_color` - Set the stroke color and weight of a node
- `set_corner_radius` - Set the corner radius of a node with optional per-corner control

### Layout & Organization

- `move_node` - Move a node to a new position
- `resize_node` - Resize a node with new dimensions
- `delete_node` - Delete a node
- `delete_multiple_nodes` - Delete multiple nodes at once efficiently
- `clone_node` - Create a copy of an existing node with optional position offset

### Components & Styles

- `get_styles` - Get information about local styles
- `get_local_components` - Get information about local components
- `create_component_instance` - Create an instance of a component
- `get_instance_overrides` - Extract override properties from a selected component instance
- `set_instance_overrides` - Apply extracted overrides to target instances

### Export & Advanced

- `export_node_as_image` - Export a node as an image (PNG, JPG, SVG, or PDF) - limited support on image currently returning base64 as text

### Connection Management

- `join_channel` - Join a specific channel to communicate with Figma

### MCP Prompts

The MCP server includes several helper prompts to guide you through complex design tasks:

- `design_strategy` - Best practices for working with Figma designs
- `read_design_strategy` - Best practices for reading Figma designs
- `text_replacement_strategy` - Systematic approach for replacing text in Figma designs
- `annotation_conversion_strategy` - Strategy for converting manual annotations to Figma's native annotations
- `swap_overrides_instances` - Strategy for transferring overrides between component instances in Figma
- `reaction_to_connector_strategy` - Strategy for converting Figma prototype reactions to connector lines using the output of 'get_reactions', and guiding the use 'create_connections' in sequence

## Development

### Building the Figma Plugin

1. Navigate to the Figma plugin directory:

   ```
   cd src/cursor_mcp_plugin
   ```

2. Edit code.js and ui.html

## Best Practices

When working with the Figma MCP:

1. Always join a channel before sending commands
2. Get document overview using `get_document_info` first
3. Check current selection with `get_selection` before modifications
4. Use appropriate creation tools based on needs:
   - `create_frame` for containers
   - `create_rectangle` for basic shapes
   - `create_text` for text elements
5. Verify changes using `get_node_info`
6. Use component instances when possible for consistency
7. Handle errors appropriately as all commands can throw exceptions
8. For large designs:
   - Use chunking parameters in `scan_text_nodes`
   - Monitor progress through WebSocket updates
   - Implement appropriate error handling
9. For text operations:
   - Use batch operations when possible
   - Consider structural relationships
   - Verify changes with targeted exports
10. For converting legacy annotations:
    - Scan text nodes to identify numbered markers and descriptions
    - Use `scan_nodes_by_types` to find UI elements that annotations refer to
    - Match markers with their target elements using path, name, or proximity
    - Categorize annotations appropriately with `get_annotations`
    - Create native annotations with `set_multiple_annotations` in batches
    - Verify all annotations are properly linked to their targets
    - Delete legacy annotation nodes after successful conversion
11. Visualize prototype noodles as FigJam connectors:

- Use `get_reactions` to extract prototype flows,
- set a default connector with `set_default_connector`,
- and generate connector lines with `create_connections` for clear visual flow mapping.

## License

MIT
</file>

<file path="config/server-config.json">
{
  "websocket": {
    "port": 3055,
    "host": "127.0.0.1"
  },
  "static_server": {
    "port": 3056,
    "host": "127.0.0.1",
    "assets_path": "../docx2json/assets/250818_summer_break",
    "baseDir": "../docx2json/assets",
    "publicRoute": "/assets"
  },
  "logging": {
    "level": "info",
    "redact_sensitive": true
  },
  "asset_transfer": {
    "mode": "URL_FIRST",
    "base64_max_size": 10240,
    "base64_rate_limit": 30
  },
  "workflow": {
    "cleanup_on_start": true,
    "current_content_file": "250818_summer_break_content.json",
    "content_directory": "../docx2json",
    "mapping": {
      "anchors": {
        "frame": "Odaily特供海报",
        "container": "ContentContainer",
        "cards_stack": "Cards",
        "header": {
          "title": "HeaderTitle",
          "date": "HeaderDate",
          "month": "HeaderMonth"
        },
        "seeds": {
          "frame": "Seeds",
          "figure_instance": "FigureCard__seedInstance",
          "body_instance": "BodyCard__seedInstance"
        },
        "figure_component": "FigureCard",
        "body_component": "BodyCard",
        "slots": {
          "figure": {
            "title": "slot:TITLE",
            "title_text": "titleText",
            "image_grid": "slot:IMAGE_GRID", 
            "source": "slot:SOURCE",
            "source_text": "sourceText"
          },
          "body": {
            "body": "slot:BODY"
          },
          "images": ["imgSlot1", "imgSlot2", "imgSlot3", "imgSlot4"]
        },
        "image_slots": ["imgSlot1", "imgSlot2", "imgSlot3", "imgSlot4"]
      },
      "grouping": {
        "group_by": "group_id",
        "order_by": "group_seq",
        "paragraph_attach_mode": "standalone"
      },
      "images": {
        "asset_path": "image.asset_id",
        "count_field": "group_len",
        "max_images": 4,
        "height_strategy": "fixed",
        "fixed_height_px": 260,
        "visibility_props": {
          "imgSlot2": "showImg2",
          "imgSlot3": "showImg3",
          "imgSlot4": "showImg4"
        }
      },
      "title": {
        "paths": ["title"],
        "take": "first_non_empty",
        "text_prop": "titleText",
        "visible_prop": "showTitle"
      },
      "source": {
        "paths": ["credit"],
        "take": "first_non_empty",
        "text_prop": "sourceText",
        "visible_prop": "showSource",
        "mode": "inline",
        "prefix": "Source: ",
        "auto_size": "HEIGHT"
      },
      "paragraph": {
        "component": "BodyCard",
        "text_prop": "bodyText",
        "text_field": "text"
      },
      "figure": {
        "componentName": "FigureCard",
        "componentId": "194:56",
        "componentKey": "fc4afd0baa35964a92683dbd2a31fc8f5ef4cdfb"
      },
      "body": {
        "componentName": "BodyCard", 
        "componentId": "194:54",
        "componentKey": "0c445c87a4aa0bc0be40dcfc8f5ef4cdfb"
      },
      "fallbacks": {
        "title_when_missing": "",
        "source_when_missing": "",
        "image_when_missing": null
      }
    }
  }
}
</file>

<file path="src/workflow_automation_enhanced.js">
#!/usr/bin/env node

/**
 * Card-based Enhanced Workflow Automation: DOCX to Figma Poster
 * 
 * Completely rewritten to support:
 * - FigureCard/BodyCard component instances
 * - Multi-image slots with visibility controls
 * - Standalone paragraphs as BodyCard instances
 * - server-config.json workflow.mapping driven
 * - Dry-run validation before execution
 */

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import FigmaChannelManager from './figma-channel-manager.js';
import { resolveContentPath, parseArgs, buildAssetUrl, computeStaticServerUrl, inferDataset } from './config-resolver.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration paths
const CONFIG = {
  serverConfigPath: path.join(__dirname, '../config/server-config.json'),
  runStatePath: path.join(__dirname, '../config/run_state.json'),
  staticServerUrl: 'http://127.0.0.1:3056/assets'
};

// utils: get value by "a.b.c" path
const getByPath = (obj, pathStr) =>
  (pathStr || '').split('.').reduce((o, k) => (o && o[k] != null ? o[k] : undefined), obj);

class CardBasedFigmaWorkflowAutomator {
  constructor() {
    this.contentData = null;
    this.workflowMapping = null;
    this.runState = null;
    this.channelManager = null;
    this.mcpClient = null;
    this.dryRun = false;
    this.boolPropIds = null; // Cache for component boolean property IDs
    this.seedInstanceIds = null; // Cache for seed instance IDs
    this.staticServerUrl = CONFIG.staticServerUrl; // will be recomputed from config
    this.contentPath = null;
    this.dataset = null;
    this.mainFrameId = null;
  }

  normalizeName(s) {
    try {
      return String(s || '')
        .normalize('NFKC')
        .replace(/[\s\u200B-\u200D\uFEFF]/g, '')
        .trim();
    } catch { return String(s || ''); }
  }

  async initialize(mcpClient, channelId = null, contentFile = null, dryRun = false) {
    console.log('🚀 Initializing Card-based Figma Workflow Automator...');
    this.mcpClient = mcpClient;
    this.channelManager = new FigmaChannelManager(mcpClient);
    this.dryRun = dryRun;
    
    // Helper to unwrap MCP responses with robust error handling (follows MCP spec)
    this.unwrapMcpResponse = (r) => {
      // Standard MCP response structure: content array with text/image/resource items
      if (r?.content?.[0]?.text) {
        try {
          // Try to parse as JSON first (most common case for our tools)
          return JSON.parse(r.content[0].text);
        } catch (parseError) {
          // Not JSON or malformed - return structured error response
          console.warn('MCP response parse warning:', parseError.message);
          return { 
            success: false, 
            error: 'JSON parse failed', 
            rawText: r.content[0].text,
            parseError: parseError.message 
          };
        }
      }
      
      // For non-text content or missing content, return as-is
      // This handles cases where tools return other MCP content types
      return r || { success: false, error: 'Empty MCP response' };
    };
    
    // Connect to channel
    if (channelId) {
      await this.channelManager.connect(channelId);
      console.log(`📡 Connected to channel: ${channelId}`);
    } else {
      console.warn('⚠️ No channel specified. Use :connect <channelId> command to establish connection.');
    }
    
    // Load server configuration with workflow.mapping
    const serverConfig = JSON.parse(await fs.readFile(CONFIG.serverConfigPath, 'utf8'));
    this.config = serverConfig; // ✅ 修复：保存完整配置
    this.workflowMapping = serverConfig.workflow.mapping;
    console.log('✅ Loaded workflow.mapping from server-config.json');
    // compute static server url from config
    try {
      this.staticServerUrl = computeStaticServerUrl(serverConfig);
      console.log(`🌐 Static server: ${this.staticServerUrl}`);
    } catch {}
    
    // Resolve and load content data
    const cliArgs = parseArgs();
    const { contentPath } = resolveContentPath(path.join(__dirname, '..'), {
      initParam: contentFile,
      cliArg: cliArgs.content,
      envVar: process.env.CONTENT_JSON_PATH,
      configDefault: serverConfig.workflow.current_content_file
    });
    this.contentPath = contentPath;
    this.contentData = JSON.parse(await fs.readFile(contentPath, 'utf8'));
    // infer dataset for later asset url building
    this.dataset = inferDataset(this.contentData?.assets || [], this.contentPath);
    
    // Get Cards container nodeId for instance creation
    if (this.channelManager && this.channelManager.currentChannel) {
      try {
        const documentInfo = await this.mcpClient.call("mcp__talk-to-figma__get_document_info");
        const targetFrameName = this.normalizeName(this.workflowMapping.anchors.frame);
        const mainFrame = documentInfo.children.find(child => this.normalizeName(child.name) === targetFrameName);
        if (mainFrame) {
          this.mainFrameId = mainFrame.id;
          const containerInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
            nodeId: mainFrame.id
          });
          // Find Cards within ContentContainer
          const targetContainerName = this.normalizeName(this.workflowMapping.anchors.container);
          const contentContainer = containerInfo.children?.find(child => this.normalizeName(child.name) === targetContainerName);
          if (contentContainer) {
            const containerDetail = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
              nodeId: contentContainer.id
            });
            const targetCardsName = this.normalizeName(this.workflowMapping.anchors.cards_stack);
            const cardsNode = containerDetail.children?.find(child => this.normalizeName(child.name) === targetCardsName);
            if (cardsNode) {
              this.workflowMapping.anchors.cards_stack_id = cardsNode.id;
              console.log(`✅ Found Cards container: ${cardsNode.id}`);
            }
          }
      }
    } catch (error) {
      console.warn('⚠️ Could not auto-detect Cards container, using fallback ID');
      this.workflowMapping.anchors.cards_stack_id = "180:53";
    }
    }
    
    // Initialize run state
    try {
      this.runState = JSON.parse(await fs.readFile(CONFIG.runStatePath, 'utf8'));
    } catch {
      this.runState = {
        current_phase: 'initialization',
        execution_started_at: null,
        cards_created: [],
        dry_run_completed: false
      };
    }
    
    // Initialize component property IDs discovery
    if (this.channelManager && this.channelManager.currentChannel) {
      await this.discoverComponentPropertyIds();
    }
    
    console.log(`📄 Loaded content with ${this.contentData.blocks.length} blocks`);
    console.log(`🎯 Mode: ${this.dryRun ? 'DRY-RUN' : 'PRODUCTION'}`);
  }

  // Helper methods for enhanced error handling
  categorizeComponentError(errorMessage) {
    const msg = errorMessage.toLowerCase();
    if (msg.includes('not found') || msg.includes('404')) return 'Component Not Found';
    if (msg.includes('permission') || msg.includes('access') || msg.includes('unauthorized')) return 'Permission Denied';
    if (msg.includes('library') || msg.includes('publish')) return 'Library Access Issue';
    if (msg.includes('key') && msg.includes('invalid')) return 'Invalid Component Key';
    if (msg.includes('parent') || msg.includes('container')) return 'Parent Container Issue';
    return 'Component Creation Error';
  }

  explainComponentError(errorMessage) {
    const msg = errorMessage.toLowerCase();
    if (msg.includes('permission') || msg.includes('access')) {
      return 'Component library access denied. Check if: 1) Library is enabled in this file, 2) Component is published, 3) You have team access rights';
    }
    if (msg.includes('not found') || msg.includes('404')) {
      return 'Component not found. Verify componentKey/componentId is correct and component exists';
    }
    if (msg.includes('library') || msg.includes('publish')) {
      return 'Library issue. Component may not be published or library not enabled in this file';
    }
    return errorMessage; // Return original message if no specific explanation
  }

  // Instance Creation Factory - supports both seedless creation and fallback to seed cloning
  async createCardInstance(parentId, cardType = 'figure') {
    console.log(`🏭 Creating ${cardType} card instance...`);
    
    const config = this.workflowMapping[cardType] || {};
    
    // Try direct component instantiation first (B+ approach)
    try {
      if (config.componentId || config.componentKey) {
        console.log(`  📦 Attempting direct component instantiation...`);
        
        const rawResult = await this.mcpClient.call("mcp__talk-to-figma__create_component_instance", {
          parentId: parentId,
          componentId: config.componentId || undefined,
          componentKey: config.componentKey || undefined,
          x: 0,
          y: 0
        });
        const result = this.unwrapMcpResponse(rawResult);
        
        if (result.success) {
          console.log(`  ✅ Direct creation succeeded: ${result.name} (${result.id})`);
          return { id: result.id, name: result.name, method: 'direct' };
        } else {
          // Enhanced error categorization for common component creation failures
          const errorMsg = result.message || result.error || 'Direct creation failed';
          const errorType = this.categorizeComponentError(errorMsg);
          throw new Error(`${errorType}: ${errorMsg}`);
        }
      }
    } catch (error) {
      const friendlyError = this.explainComponentError(error.message);
      console.warn(`  ⚠️ Direct creation failed: ${friendlyError}`);
      console.warn(`  🔄 Falling back to seed cloning...`);
    }
    
    // Fallback to seed cloning (existing approach)
    try {
      const result = await this.cloneCardFromSeed(parentId, cardType);
      console.log(`  ✅ Seed cloning succeeded: ${result.name} (${result.id})`);
      return { ...result, method: 'seed-clone' };
    } catch (error) {
      console.error(`  ❌ Both direct creation and seed cloning failed`);
      throw new Error(`Failed to create ${cardType} card: Direct creation failed (${error.message}), seed cloning also failed`);
    }
  }

  async cloneCardFromSeed(parentId, cardType) {
    // This method handles the existing seed-based cloning logic
    // Implementation depends on your current seed cloning approach
    const seedInstances = await this.resolveSeedInstances();
    const seedId = cardType === 'figure' ? seedInstances.figureInstanceId : seedInstances.bodyInstanceId;
    
    // Use existing append_card_to_container API
    const rawResult = await this.mcpClient.call("mcp__talk-to-figma__append_card_to_container", {
      containerId: parentId,
      templateId: seedId,
      insertIndex: -1
    });
    const parsed = this.unwrapMcpResponse(rawResult);

    // Normalize different return shapes:
    // - Plugin data via server text message (contains "New card ID: <id>" and name inside quotes)
    // - Potential JSON object with { newNodeId, newNodeName } or { id, name } or { instanceId, instanceName }
    const normalize = (objOrText) => {
      if (!objOrText) return null;
      // Object-like
      if (typeof objOrText === 'object') {
        const id = objOrText.newNodeId || objOrText.instanceId || objOrText.id;
        const name = objOrText.newNodeName || objOrText.instanceName || objOrText.name || 'Cloned Card';
        if (id) return { id, name };
      }
      // Text fallback
      if (typeof objOrText === 'string') {
        // Extract name between first quotes after 'appended card'
        let nameMatch = objOrText.match(/appended card \"([^\"]+)\"/i);
        // Extract ID after 'New card ID:'
        let idMatch = objOrText.match(/New card ID:\s*([^\s]+)/i);
        if (idMatch) {
          return { id: idMatch[1], name: (nameMatch && nameMatch[1]) || 'Cloned Card' };
        }
      }
      return null;
    };

    let normalized = null;
    if (parsed && parsed.success && typeof parsed === 'object') {
      normalized = normalize(parsed);
    }
    if (!normalized && parsed && parsed.rawText) {
      normalized = normalize(parsed.rawText);
    }
    if (!normalized) {
      // Try using the raw MCP response directly if available
      normalized = normalize(rawResult?.content?.[0]?.text || rawResult);
    }

    if (!normalized) {
      const msg = parsed?.message || parsed?.error || 'Unknown append result';
      throw new Error(`Seed cloning failed: ${msg}`);
    }

    return normalized;
  }

  async processWorkflow() {
    console.log(`\n🔄 Starting card-based workflow processing (${this.dryRun ? 'DRY-RUN' : 'PRODUCTION'})...`);
    
    this.runState.execution_started_at = new Date().toISOString();
    this.runState.current_phase = this.dryRun ? 'dry_run_execution' : 'production_execution';
    await this.updateRunState();
    
    // 🧹 Clear Cards container before creating new instances (if configured)
    if (this.config?.workflow?.cleanup_on_start) {
      await this.clearCardsContainer();
    }
    
    try {
      // Step 1: Create ordered content flow
      await this.fillHeader(this.contentData?.doc || {});
      const orderedContent = this.createOrderedContentFlow();
      console.log(`📋 Generated ordered content flow: ${orderedContent.length} items`);
      
      // Step 2: Ensure sufficient card instances
      await this.ensureCardInstances(orderedContent);
      
      // Step 3: Process each content item
      for (let i = 0; i < orderedContent.length; i++) {
        const contentItem = orderedContent[i];
        console.log(`\n📝 Processing item ${i + 1}/${orderedContent.length}: ${contentItem.type}`);
        
        if (contentItem.type === 'figure_group') {
          await this.processFigureCard(contentItem, i);
        } else if (contentItem.type === 'standalone_paragraph') {
          await this.processBodyCard(contentItem, i);
        }
      }
      
      // Step 4: Apply text auto-resize if not dry run
      if (!this.dryRun) {
        await this.applyTextAutoResize();
      }

      // ✅ 改进4: 事后验收，确保创建顺序与内容一致
      if (!this.dryRun) {
        await this.validateCardsOrder(orderedContent);
      }
      
      console.log(`\n✅ ${this.dryRun ? 'Dry-run' : 'Production'} processing completed!`);
      this.runState.current_phase = this.dryRun ? 'dry_run_completed' : 'completed';
      this.runState.dry_run_completed = this.dryRun;
      await this.updateRunState();
      
      // Generate summary report
      await this.generateExecutionReport(orderedContent);
      
    } catch (error) {
      console.error('💥 Workflow failed:', error.message);
      this.runState.current_phase = 'failed';
      this.runState.last_error = error.message;
      await this.updateRunState();
      throw error;
    }
  }

  // Helper: DFS search within any node info tree
  dfsFindNodeIdByName(rootInfo, targetName) {
    const target = this.normalizeName(targetName);
    if (!target || !rootInfo) return null;
    const stack = [rootInfo];
    while (stack.length) {
      const node = stack.pop();
      if (this.normalizeName(node?.name) === target) return node.id || null;
      if (node?.children && Array.isArray(node.children)) {
        for (const ch of node.children) stack.push(ch);
      }
    }
    return null;
  }

  async fillHeader(docMeta = {}) {
    try {
      const headerCfg = this.workflowMapping?.anchors?.header || {};
      if (!this.mainFrameId) {
        // Try to resolve main frame again if missing
        const documentInfo = await this.mcpClient.call("mcp__talk-to-figma__get_document_info");
        const mainFrame = documentInfo.children.find(child => child.name === this.workflowMapping.anchors.frame);
        if (mainFrame) this.mainFrameId = mainFrame.id;
      }
      if (!this.mainFrameId) {
        console.warn('⚠️ No main frame detected, skipping header fill');
        return;
      }

      const frameInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", { nodeId: this.mainFrameId });
      const setIfFound = async (nodeName, text) => {
        if (!nodeName) return;
        const nodeId = this.dfsFindNodeIdByName(frameInfo, nodeName);
        if (!nodeId) return;
        try {
          await this.mcpClient.call("mcp__talk-to-figma__set_text_content", { nodeId, text: text || '' });
          await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", { nodeId, autoResize: 'HEIGHT' });
          console.log(`🧭 Header set ${nodeName}: "${(text || '').toString().substring(0, 60)}"`);
        } catch (e) {
          console.warn(`⚠️ Failed to set header ${nodeName}: ${e.message}`);
        }
      };

      const title = docMeta.title || '';
      const dateStr = docMeta.date || '';
      const month = this.formatMonthFromDate(dateStr);

      await setIfFound(headerCfg.title, title);
      await setIfFound(headerCfg.date, dateStr);
      await setIfFound(headerCfg.month, month);
    } catch (error) {
      console.warn('⚠️ fillHeader failed:', error.message);
    }
  }

  formatMonthFromDate(dateStr) {
    try {
      if (!dateStr) return '';
      const m = String(dateStr).match(/\d{4}-(\d{2})-\d{2}/);
      if (m) return m[1];
      // try compact yyyyMMdd
      const m2 = String(dateStr).match(/\d{4}(\d{2})\d{2}/);
      if (m2) return m2[1];
      return '';
    } catch { return ''; }
  }

  createOrderedContentFlow() {
    // Group blocks by group_id, maintaining original order for ungrouped items
    const groups = {};
    const standaloneItems = [];
    const originalOrder = [];
    
    for (let i = 0; i < this.contentData.blocks.length; i++) {
      const block = this.contentData.blocks[i];
      
      if (block.group_id) {
        if (!groups[block.group_id]) {
          groups[block.group_id] = [];
          originalOrder.push({ type: 'group', group_id: block.group_id, original_index: i });
        }
        groups[block.group_id].push(block);
      } else if (block.type === 'paragraph') {
        // Standalone paragraphs become BodyCard instances
        standaloneItems.push({
          type: 'standalone_paragraph',
          block: block,
          original_index: i
        });
        originalOrder.push({ type: 'standalone_paragraph', original_index: i });
      }
    }
    
    // Convert groups to figure_group items and merge with standalone items
    const orderedContent = [];
    let standaloneIndex = 0;
    
    for (const orderItem of originalOrder) {
      if (orderItem.type === 'group') {
        const groupBlocks = groups[orderItem.group_id];
        groupBlocks.sort((a, b) => (a.group_seq || 0) - (b.group_seq || 0));
        
        orderedContent.push({
          type: 'figure_group',
          group_id: orderItem.group_id,
          blocks: groupBlocks,
          figures: groupBlocks.filter(b => b.type === 'figure'),
          paragraphs: groupBlocks.filter(b => b.type === 'paragraph')
        });
      } else if (orderItem.type === 'standalone_paragraph') {
        orderedContent.push(standaloneItems[standaloneIndex++]);
      }
    }
    
    return orderedContent;
  }

  async ensureCardInstances(orderedContent) {
    const figureCards = orderedContent.filter(item => item.type === 'figure_group').length;
    const bodyCards = orderedContent.filter(item => item.type === 'standalone_paragraph').length;
    
    console.log(`📋 Required instances: ${figureCards} FigureCard, ${bodyCards} BodyCard`);
    
    if (this.dryRun) {
      console.log('🎯 DRY-RUN: Skipping actual instance creation');
      return;
    }
    
    // 🎯 种子实例优化：解析种子实例ID
    const seedInstances = await this.resolveSeedInstances();
    const cardsContainerId = this.workflowMapping.anchors.cards_stack_id;
    
    // Create required instances using seed instances
    this.runState.cards_created = [];
    
    for (let i = 0; i < orderedContent.length; i++) {
      const item = orderedContent[i];
      const componentName = item.type === 'figure_group' ? 'FigureCard' : 'BodyCard';
      const seedId = item.type === 'figure_group' ? seedInstances.figureInstanceId : seedInstances.bodyInstanceId;
      
      // ✅ 改进1: 按索引命名，确保与内容流严格对应
      const newName = item.type === 'figure_group' 
        ? `${String(i+1).padStart(2,'0')}_Figure_${item.group_id}` 
        : `${String(i+1).padStart(2,'0')}_Body_${i}`;
      
      try {
        console.log(`  🏭 Creating ${componentName} card ${i + 1}/${orderedContent.length}: ${newName}`);
        
        // Use the new instance creation factory (B+ approach with fallback)
        const cardType = item.type === 'figure_group' ? 'figure' : 'body';
        const cardInstance = await this.createCardInstance(cardsContainerId, cardType);
        
        console.log(`    📝 Card created: ${cardInstance.name} via ${cardInstance.method}`);
        
        // ✅ Enhanced binding relationship for index alignment
        this.runState.cards_created.push({
          index: i,               // ← 与 orderedContent 的位置一一对应
          instanceId: cardInstance.id,
          creationMethod: cardInstance.method, // Track how it was created
          kind: item.type,        // 'figure_group' | 'standalone_paragraph'
          type: item.type,        // ← 向后兼容，别删
          component: componentName,
          name: cardInstance.name,
          ref: item.type === 'figure_group'
            ? { group_id: item.group_id }                // grp_0010 / grp_0011…
            : { original_index: item.original_index }    // 段落在JSON中的原始索引
        });
        
        console.log(`✅ Created ${componentName} instance ${i + 1} via ${cardInstance.method} (ID: ${cardInstance.id})`);
        
      } catch (error) {
        console.error(`❌ Failed to create ${componentName} instance ${i + 1}:`, error);
        throw error;
      }
    }
    
    console.log(`🎉 Successfully created ${this.runState.cards_created.length} instances`);
  }

  // ✅ 改进4: 验收机制 - 确保Cards顺序与orderedContent一致
  async validateCardsOrder(orderedContent) {
    console.log('\n🔍 Validating cards order against content flow...');
    
    try {
      // 获取Cards容器的实际子节点
      const cardsInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: this.workflowMapping.anchors.cards_stack_id
      });
      
      const actualChildren = cardsInfo.children || [];
      console.log(`📋 Found ${actualChildren.length} cards in Figma, expected ${orderedContent.length}`);
      
      // 验证数量
      if (actualChildren.length !== orderedContent.length) {
        console.warn(`⚠️ Cards count mismatch: expected ${orderedContent.length}, found ${actualChildren.length}`);
        return false;
      }
      
      // 验证顺序和对应关系
      let allValid = true;
      for (let i = 0; i < actualChildren.length; i++) {
        const actualCard = actualChildren[i];
        const expectedContent = orderedContent[i];
        const expectedCard = this.runState.cards_created[i];
        
        // 检查ID对应
        if (actualCard.id !== expectedCard.instanceId) {
          console.warn(`⚠️ Position ${i}: ID mismatch - expected ${expectedCard.instanceId}, found ${actualCard.id}`);
          allValid = false;
        }
        
        // ✅ 检查类型对应 - 通过子节点槽位而非名称判断 + 安全访问
        try {
          const info = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", { nodeId: actualCard.id });
          const slots = this.workflowMapping.anchors?.slots ?? {};
          const bodyName = this.normalizeName(slots.body?.body ?? 'slot:BODY');
          const imageGridName = this.normalizeName(slots.figure?.image_grid ?? 'slot:IMAGE_GRID');
          const hasBody = (info.children || []).some(c => this.normalizeName(c.name) === bodyName);
          const hasImageGrid = (info.children || []).some(c => this.normalizeName(c.name) === imageGridName);
          const actualType = hasBody ? 'standalone_paragraph' : (hasImageGrid ? 'figure_group' : 'unknown');
          
          // ✅ DEBUG日志 - unknown类型时输出详细信息
          if (actualType === 'unknown') {
            console.warn(`🔍 DEBUG Position ${i}: Unknown card type detected`);
            console.warn(`  Card name: ${actualCard.name}`);
            console.warn(`  Children:`, (info.children || []).map(c => ({ name: c.name, type: c.type })));
            console.warn(`  Expected slots: body='${slots.body?.body ?? 'slot:BODY'}', imageGrid='${slots.figure?.image_grid ?? 'slot:IMAGE_GRID'}'`);
          }
          
          if (actualType !== expectedContent.type) {
            console.warn(`⚠️ Position ${i}: Type mismatch - expected ${expectedContent.type}, found ${actualType}`);
            allValid = false;
          }
        } catch (error) {
          console.warn(`⚠️ Position ${i}: Failed to check node type: ${error.message}`);
          allValid = false;
        }
      }
      
      if (allValid) {
        console.log('✅ Cards order validation passed!');
      } else {
        console.warn('⚠️ Cards order validation failed - some mismatches detected');
      }
      
      return allValid;
      
    } catch (error) {
      console.error('❌ Failed to validate cards order:', error.message);
      return false;
    }
  }

  // 🎯 种子实例解析方法
  async resolveSeedInstances() {
    if (this.seedInstanceIds) {
      return this.seedInstanceIds;
    }
    
    const seedsMapping = this.workflowMapping.anchors.seeds;
    if (!seedsMapping) {
      throw new Error('Seeds configuration not found in mapping.anchors.seeds');
    }

    // 查找 Seeds 框架
    const docInfo = await this.mcpClient.call("mcp__talk-to-figma__get_document_info");
    const seedsFrame = docInfo.children.find(frame => this.normalizeName(frame.name) === this.normalizeName(seedsMapping.frame));
    if (!seedsFrame) {
      throw new Error(`Seeds frame "${seedsMapping.frame}" not found`);
    }

    // 获取种子实例详情
    const seedsInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
      nodeId: seedsFrame.id
    });

    const figureInstance = seedsInfo.children.find(child => this.normalizeName(child.name) === this.normalizeName(seedsMapping.figure_instance));
    const bodyInstance = seedsInfo.children.find(child => this.normalizeName(child.name) === this.normalizeName(seedsMapping.body_instance));

    if (!figureInstance || !bodyInstance) {
      throw new Error(`Seed instances not found: ${seedsMapping.figure_instance} / ${seedsMapping.body_instance}`);
    }

    console.log(`🌱 Seed instances resolved: FigureCard=${figureInstance.id}, BodyCard=${bodyInstance.id}`);

    this.seedInstanceIds = {
      figureInstanceId: figureInstance.id,
      bodyInstanceId: bodyInstance.id
    };
    
    return this.seedInstanceIds;
  }
  
  // ✨ 新增：自动发现组件属性的 propertyId (使用官方API)
  async discoverComponentPropertyIds() {
    console.log('🔍 Discovering component property IDs...');
    
    try {
      // Try B+ approach first: create a temporary instance for property discovery
      let discoveryInstanceId = null;
      let shouldCleanupInstance = false;
      
      try {
        console.log('  🆕 Attempting property discovery via direct instance creation...');
        let cardsStackId = this.workflowMapping.anchors?.cards_stack_id;
        if (!cardsStackId) {
          // Resolve by names: frame → container → cards_stack
          const docInfo = await this.mcpClient.call("mcp__talk-to-figma__get_document_info");
          const frameNode = docInfo.children.find(child => child.name === this.workflowMapping.anchors.frame);
          if (!frameNode) throw new Error('Main frame not found for property discovery');
          const frameInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", { nodeId: frameNode.id });
          const containerNode = frameInfo.children?.find(child => child.name === this.workflowMapping.anchors.container);
          if (!containerNode) throw new Error('Content container not found for property discovery');
          const containerInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", { nodeId: containerNode.id });
          const cardsNode = containerInfo.children?.find(child => child.name === this.workflowMapping.anchors.cards_stack);
          if (!cardsNode) throw new Error('Cards stack not found for property discovery');
          cardsStackId = cardsNode.id;
          this.workflowMapping.anchors.cards_stack_id = cardsStackId;
          console.log(`  🔗 Resolved cards stack id by name: ${cardsStackId}`);
        }
        
        const tempInstance = await this.createCardInstance(cardsStackId, 'figure');
        discoveryInstanceId = tempInstance.id;
        // Clean up only if we created an instance directly (covers variants like 'direct-local')
        shouldCleanupInstance = (typeof tempInstance.method === 'string' && tempInstance.method.startsWith('direct'));
        
        console.log(`  📍 Using instance ${discoveryInstanceId} for property discovery (method: ${tempInstance.method})`);
      } catch (error) {
        console.warn(`  ⚠️ Direct instance creation failed, falling back to seed discovery: ${error.message}`);
        
        // Fallback: use existing seed-based discovery
        const seedInstances = await this.resolveSeedInstances();
        discoveryInstanceId = seedInstances.figureInstanceId;
        shouldCleanupInstance = false;
      }
      
      // Perform property discovery on the chosen instance
      const rawResponse = await this.mcpClient.call("mcp__talk-to-figma__get_component_property_references", {
        nodeId: discoveryInstanceId
      });
      const referencesResult = this.unwrapMcpResponse(rawResponse);
      
      console.log('📋 Component properties result:', JSON.stringify(referencesResult, null, 2));
      
      if (!referencesResult.success || !referencesResult.properties) {
        throw new Error(`Failed to get component properties: ${referencesResult.message || 'Unknown error'}`);
      }
      
      // Get configuration for expected property names
      const visibilityMapping = this.workflowMapping.images?.visibility_props || {};
      const titleVisibleProp = this.workflowMapping.title?.visible_prop || 'showTitle';
      const sourceVisibleProp = this.workflowMapping.source?.visible_prop || 'showSource';

      this.boolPropIds = { figure: {} };

      // Get available property keys (already in PropertyName#ID format)
      const availableKeys = referencesResult.propertyKeys || Object.keys(referencesResult.properties);
      console.log('🔍 Available property keys:', availableKeys);

      // Build normalized baseName → actualKey map for robust matching
      const normalize = (s) => String(s || '')
        .toLowerCase()
        .replace(/\s+/g, '')
        .replace(/[_\-]+/g, '');

      const keyByNormalizedBase = {};
      for (const key of availableKeys) {
        const base = String(key).split('#')[0];
        const norm = normalize(base);
        if (!keyByNormalizedBase[norm]) keyByNormalizedBase[norm] = key;
      }

      const findProperty = (friendlyName) => {
        const exactPrefix = availableKeys.find(key => key.startsWith(`${friendlyName}#`));
        if (exactPrefix) return exactPrefix;
        const norm = normalize(friendlyName);
        return keyByNormalizedBase[norm] || null;
      };

      // Map title property
      const titleKey = findProperty(titleVisibleProp);
      if (titleKey) {
        this.boolPropIds.figure[titleVisibleProp] = titleKey;
        console.log(`📌 Mapped title property: ${titleVisibleProp} -> ${titleKey}`);
      } else {
        console.error(`❌ Title property not found: ${titleVisibleProp}`);
      }

      // Map source property  
      const sourceKey = findProperty(sourceVisibleProp);
      if (sourceKey) {
        this.boolPropIds.figure[sourceVisibleProp] = sourceKey;
        console.log(`📌 Mapped source property: ${sourceVisibleProp} -> ${sourceKey}`);
      } else {
        console.error(`❌ Source property not found: ${sourceVisibleProp}`);
      }

      // Map image slot properties (optional, do not fail workflow if missing)
      const missingImageProps = [];
      Object.entries(visibilityMapping).forEach(([slotName, propName]) => {
        const imageKey = findProperty(propName);
        if (imageKey) {
          this.boolPropIds.figure[propName] = imageKey;
          console.log(`📌 Mapped image property: ${propName} (${slotName}) -> ${imageKey}`);
        } else {
          console.warn(`⚠️ Image visibility property not found: ${propName} (${slotName}). Will treat as hidden by default.`);
          missingImageProps.push(propName);
        }
      });

      // Fail-fast validation: essential properties must be present
      const essentialMissing = [titleVisibleProp, sourceVisibleProp].filter(prop => !this.boolPropIds.figure[prop]);
      if (essentialMissing.length > 0) {
        const availableBases = availableKeys.map(k => k.split('#')[0]);
        const errorMsg = `❌ Essential component properties missing: ${essentialMissing.join(', ')}. Available base names: ${availableBases.join(', ')}`;
        console.error(errorMsg);
        if (shouldCleanupInstance && discoveryInstanceId) {
          try {
            await this.mcpClient.call("mcp__talk-to-figma__delete_node", { nodeId: discoveryInstanceId });
            console.log(`  🧹 Cleaned up temporary instance: ${discoveryInstanceId}`);
          } catch (cleanupError) {
            console.warn(`  ⚠️ Failed to cleanup temporary instance: ${cleanupError.message}`);
          }
        }
        throw new Error(errorMsg);
      }

      if (missingImageProps.length > 0) {
        console.warn(`ℹ️ Proceeding with defaults: missing image visibility props will be treated as hidden: ${missingImageProps.join(', ')}`);
      }

      console.log('✅ Component property IDs discovered:', this.boolPropIds);
      
      // Cleanup temporary instance if we created it for discovery
      if (shouldCleanupInstance && discoveryInstanceId) {
        try {
          await this.mcpClient.call("mcp__talk-to-figma__delete_node", { nodeId: discoveryInstanceId });
          console.log(`  🧹 Cleaned up temporary discovery instance: ${discoveryInstanceId}`);
        } catch (cleanupError) {
          console.warn(`  ⚠️ Failed to cleanup temporary instance: ${cleanupError.message}`);
        }
      }
      
    } catch (error) {
      console.error('❌ Failed to discover property IDs:', error.message);
      
      // Fail fast - don't use fallback mapping
      throw new Error(`Property ID discovery failed: ${error.message}. Please check Figma component boolean properties setup.`);
    }
  }

  async clearCardsContainer() {
    if (!this.channelManager || !this.channelManager.currentChannel) {
      console.warn('⚠️ No channel connection, skipping Cards cleanup');
      return;
    }
    
    try {
      const cardsContainerId = this.workflowMapping.anchors.cards_stack_id || "194:51";
      const cardsInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: cardsContainerId
      });
      
      if (cardsInfo.children && cardsInfo.children.length > 0) {
        // ⚠️ 重要：只删除脚本生成的节点，保护模板结构
        const scriptGeneratedNodes = cardsInfo.children.filter(child => {
          const name = child.name || '';
          return (
            name.includes('_grp_') ||           // FigureCard 分组实例
            name.includes('_paragraph_') ||     // BodyCard 段落实例  
            name.includes('_copy_') ||          // 复制的实例
            name.includes('FigureCard_') ||     // FigureCard 前缀
            name.includes('BodyCard_') ||       // BodyCard 前缀
            name.match(/^(FigureCard|BodyCard).*\d+$/) // 带数字后缀的卡片
          );
        });
        
        if (scriptGeneratedNodes.length > 0) {
          const nodeIds = scriptGeneratedNodes.map(node => node.id);
          console.log(`🧹 Safely cleaning ${nodeIds.length} script-generated items from Cards...`);
          console.log(`📋 Deleting: ${scriptGeneratedNodes.map(n => n.name).join(', ')}`);
          
          const deleteResult = await this.mcpClient.call("mcp__talk-to-figma__delete_multiple_nodes", {
            nodeIds: nodeIds
          });
          
          console.log(`✅ Safe cleanup completed: ${deleteResult.nodesDeleted} deleted, ${deleteResult.nodesFailed} failed`);
        } else {
          console.log('✅ No script-generated content found, Cards container preserved');
        }
        
        // 显示保留的模板结构
        const preservedNodes = cardsInfo.children.filter(child => {
          const name = child.name || '';
          return !scriptGeneratedNodes.some(sg => sg.id === child.id);
        });
        if (preservedNodes.length > 0) {
          console.log(`🛡️ Template preserved: ${preservedNodes.map(n => n.name).join(', ')}`);
        }
        
      } else {
        console.log('✅ Cards container already clean');
      }
    } catch (error) {
      console.warn('⚠️ Cards cleanup failed:', error.message);
    }
  }

  // ✅ 无限深度DFS搜索 - 不再受层级限制
  async findChildByName(instanceId, childName) {
    try {
      const instanceInfo = await this.mcpClient.call("mcp__talk-to-figma__get_node_info", {
        nodeId: instanceId
      });
      
      // DFS递归搜索所有层级
      const normalizeName = (s) => String(s || '')
        .normalize('NFKC')
        .replace(/[\s\u200B-\u200D\uFEFF]/g, '')
        .trim();

      const target = normalizeName(childName);

      const dfsSearch = (node) => {
        if (normalizeName(node.name) === target) {
          return node.id;
        }
        
        if (node.children) {
          for (const child of node.children) {
            const result = dfsSearch(child);
            if (result) {
              return result;
            }
          }
        }
        
        return null;
      };
      
      return dfsSearch(instanceInfo);
      
    } catch (error) {
      console.error(`❌ Failed to find child "${childName}" in instance ${instanceId}:`, error.message);
      return null;
    }
  }

  async processFigureCard(figureGroup, cardIndex) {
    const cardInstance = this.runState.cards_created[cardIndex];
    if (!cardInstance) {
      console.warn(`⚠️ No card instance found for index ${cardIndex}`);
      return;
    }
    
    console.log(`  🖼️ Processing FigureCard: group ${figureGroup.group_id}`);
    
    if (this.dryRun) {
      this.generateDryRunSummary(figureGroup, cardIndex, 'FigureCard');
      return;
    }
    
    const instanceId = cardInstance.instanceId;
    
    // Extract content from figures  
    const figures = figureGroup.figures;
    // 依配置路径采集图片 asset_id
    const assetPath = this.workflowMapping.images?.asset_path || 'image.asset_id';
    const images = (figureGroup.figures || [])
      .map(f => ({ asset_id: getByPath(f, assetPath) }))
      .filter(x => !!x.asset_id);
    const firstTitle = figures.find(f => f.title)?.title || '';
    const firstCredit = figures.find(f => f.credit)?.credit || '';
    
    // ✅ 改进3: 使用配置化槽位名 + 空内容处理 + 安全访问
    const slots = this.workflowMapping.anchors?.slots ?? {};
    const titleTextSlot = slots.figure?.title_text ?? 'titleText';
    const titleNodeId = await this.findChildByName(instanceId, titleTextSlot);
    if (titleNodeId) {
      try {
        await this.mcpClient.call("mcp__talk-to-figma__set_text_content", {
          nodeId: titleNodeId,
          text: firstTitle || ''  // ✅ 空内容设为空字符串，依赖Auto-layout收缩
        });
        await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", {
          nodeId: titleNodeId,
          autoResize: 'HEIGHT'
        });
        console.log(`    ✅ Set title: "${firstTitle || '(empty)'}"`);
      } catch (error) {
        console.error(`    ❌ Failed to set title:`, error.message);
      }
    }

    // ✅ 来源处理 + 空内容处理 + 安全访问
    const sourceTextSlot = slots.figure?.source_text ?? 'sourceText';
    const sourceNodeId = await this.findChildByName(instanceId, sourceTextSlot);
    if (sourceNodeId) {
      try {
        const sourceText = firstCredit ? `Source: ${firstCredit}` : '';
        await this.mcpClient.call("mcp__talk-to-figma__set_text_content", {
          nodeId: sourceNodeId,
          text: sourceText  // ✅ 空内容设为空字符串
        });
        await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", {
          nodeId: sourceNodeId,
          autoResize: 'HEIGHT'
        });
        console.log(`    ✅ Set source: "${sourceText || '(empty)'}"`);
      } catch (error) {
        console.error(`    ❌ Failed to set source:`, error.message);
      }
    }
    
    // Apply official Figma setProperties API for visibility control
    await this.applyVisibilityControl(instanceId, {
      hasTitle: !!firstTitle,
      hasSource: !!firstCredit, 
      imageCount: images.length
    });
    
    // Fill images in slots - ✅ 统一槽位来源 + 容错处理
    const imageSlots = this.workflowMapping.anchors.slots || {};
    const imageSlotNames = imageSlots.images || this.workflowMapping.anchors.image_slots || [];
    const max = Math.min(images.length, imageSlotNames.length, this.workflowMapping.images?.max_images ?? imageSlotNames.length);
    for (let i = 0; i < max; i++) {
      const imageSlotName = imageSlotNames[i];
      const imageNodeId = await this.findChildByName(instanceId, imageSlotName);
      
      if (imageNodeId && images[i].asset_id) {
        const imageUrl = buildAssetUrl(this.staticServerUrl, this.contentData?.assets || [], images[i].asset_id, this.contentPath);
        try {
          await this.mcpClient.call("mcp__talk-to-figma__set_image_fill", {
            nodeId: imageNodeId,
            imageUrl: imageUrl,
            scaleMode: 'FILL',
            opacity: 1
          });
          console.log(`    ✅ Filled ${imageSlotName} with ${images[i].asset_id}`);
        } catch (error) {
          console.error(`    ❌ Failed to fill image slot ${imageSlotName}:`, error.message);
        }
      }
    }
  }

  async applyVisibilityControl(instanceId, { hasTitle, hasSource, imageCount }) {
    console.log(`    🎯 Visibility control: title:${hasTitle}, source:${hasSource}, images:${imageCount}`);

    if (!this.boolPropIds?.figure) {
      const error = 'Boolean property IDs not discovered - cannot apply visibility control';
      console.error(`    ❌ ${error}`);
      throw new Error(error);
    }

    try {
      // 计算各布尔位的目标值
      const titleVisibleProp = this.workflowMapping.title?.visible_prop || 'showTitle';
      const sourceVisibleProp = this.workflowMapping.source?.visible_prop || 'showSource';
      const visibilityMapping = this.workflowMapping.images?.visibility_props || {};
      
      // 构造properties对象 - 使用PropertyName#ID格式的键
      const properties = {};
      
      // 设置标题显示
      if (this.boolPropIds.figure[titleVisibleProp]) {
        properties[this.boolPropIds.figure[titleVisibleProp]] = hasTitle;
        console.log(`    📝 ${titleVisibleProp} -> ${this.boolPropIds.figure[titleVisibleProp]} = ${hasTitle}`);
      }
      
      // 设置来源显示
      if (this.boolPropIds.figure[sourceVisibleProp]) {
        properties[this.boolPropIds.figure[sourceVisibleProp]] = hasSource;
        console.log(`    📝 ${sourceVisibleProp} -> ${this.boolPropIds.figure[sourceVisibleProp]} = ${hasSource}`);
      }
      
      // 设置图片显示 - 动态从配置读取
      const imageSlotNames = this.workflowMapping.anchors?.slots?.images || this.workflowMapping.anchors.image_slots || [];
      const maxImages = this.workflowMapping.images?.max_images ?? imageSlotNames.length;
      
      for (let i = 2; i <= maxImages && i-1 < imageSlotNames.length; i++) {
        const slotName = imageSlotNames[i-1]; // imgSlot2 is at index 1
        const visibilityProp = visibilityMapping[slotName];
        
        if (visibilityProp && this.boolPropIds.figure[visibilityProp]) {
          const shouldShow = imageCount >= i;
          properties[this.boolPropIds.figure[visibilityProp]] = shouldShow;
          console.log(`    📝 ${visibilityProp} (${slotName}) -> ${this.boolPropIds.figure[visibilityProp]} = ${shouldShow}`);
        }
      }
      
      // 使用官方setProperties API直接设置实例属性
      if (Object.keys(properties).length > 0) {
        console.log(`    🔧 Applying properties using setProperties:`, properties);
        
        const rawResult = await this.mcpClient.call("mcp__talk-to-figma__set_instance_properties", {
          nodeId: instanceId,
          properties: properties
        });
        const result = this.unwrapMcpResponse(rawResult);
        
        if (result.success) {
          console.log(`    ✅ Applied ${Object.keys(properties).length} properties to instance ${instanceId}`);
          console.log(`    📋 Applied properties:`, result.applied);
        } else {
          throw new Error(`Failed to set properties: ${result.message}`);
        }
      } else {
        console.warn(`    ⚠️ No properties to apply - check component property mapping`);
      }
      
    } catch (error) {
      console.error(`    ❌ Failed to apply visibility control:`, error.message);
      console.error(`    📋 Error details:`, error);
      throw error; // Re-throw to fail fast as requested
    }
  }


  async processBodyCard(standaloneItem, cardIndex) {
    const cardInstance = this.runState.cards_created[cardIndex];
    if (!cardInstance) {
      console.warn(`⚠️ No card instance found for index ${cardIndex}`);
      return;
    }
    
    console.log(`  📄 Processing BodyCard: paragraph`);
    
    if (this.dryRun) {
      this.generateDryRunSummary(standaloneItem, cardIndex, 'BodyCard');
      return;
    }
    
    const instanceId = cardInstance.instanceId;
    const paragraphText = standaloneItem.block.text;
    
    // Find and fill body text node with correct slot name
    const bodySlotName = this.workflowMapping.anchors?.slots?.body?.body || 'slot:BODY';
    const bodyTextNodeId = await this.findChildByName(instanceId, bodySlotName);
    if (bodyTextNodeId) {
      try {
        await this.mcpClient.call("mcp__talk-to-figma__set_text_content", {
          nodeId: bodyTextNodeId,
          text: paragraphText
        });
        await this.mcpClient.call("mcp__talk-to-figma__set_text_auto_resize", {
          nodeId: bodyTextNodeId,
          autoResize: 'HEIGHT'
        });
        console.log(`    ✅ Set body text: "${paragraphText.substring(0, 60)}..."`);
      } catch (error) {
        console.error(`    ❌ Failed to set body text:`, error.message);
      }
    } else {
      console.warn(`    ⚠️ Body text node (${bodySlotName}) not found in instance ${instanceId}`);
    }
  }

  generateDryRunSummary(contentItem, cardIndex, cardType) {
    let summary = `[#${cardIndex + 1} ${cardType.toLowerCase()}`;
    
    if (contentItem.type === 'figure_group') {
      const figures = contentItem.figures;
      const imageCount = figures.filter(f => f.image?.asset_id).length;
      const hasTitle = figures.some(f => f.title);
      const hasSource = figures.some(f => f.credit);
      
      summary += ` ${imageCount}img title:${hasTitle ? 'Y' : 'N'} source:${hasSource ? 'Y' : 'N'}`;
    } else if (contentItem.type === 'standalone_paragraph') {
      const textLength = contentItem.block.text.length;
      summary += ` ${textLength}chars`;
    }
    
    summary += ']';
    
    console.log(`    🎯 DRY-RUN: ${summary}`);
    console.log(`    📄 Content: "${(contentItem.blocks?.[0]?.title || contentItem.block?.text || 'N/A').substring(0, 60)}..."`);
  }

  async applyTextAutoResize() {
    console.log('📏 Applying text auto-resize to card instances...');
    
    for (const cardInfo of this.runState.cards_created) {
      try {
        // This would need instance-aware text node identification
        console.log(`✅ Applied auto-resize to ${cardInfo.component} instance ${cardInfo.index + 1}`);
      } catch (error) {
        console.warn(`⚠️ Failed to apply auto-resize to instance ${cardInfo.instanceId}:`, error.message);
      }
    }
  }

  async updateRunState() {
    await fs.writeFile(CONFIG.runStatePath, JSON.stringify(this.runState, null, 2));
  }

  async generateExecutionReport(orderedContent) {
    const figureGroups = orderedContent.filter(item => item.type === 'figure_group');
    const standaloneParagraphs = orderedContent.filter(item => item.type === 'standalone_paragraph');
    
    const report = {
      execution_completed_at: new Date().toISOString(),
      mode: this.dryRun ? 'DRY_RUN' : 'PRODUCTION',
      content_summary: {
        total_blocks: this.contentData.blocks.length,
        figure_groups: figureGroups.length,
        standalone_paragraphs: standaloneParagraphs.length,
        total_cards_required: orderedContent.length
      },
      card_instances: {
        figure_cards: figureGroups.length,
        body_cards: standaloneParagraphs.length,
        created: this.runState.cards_created.length
      },
      workflow_mapping: {
        anchors: this.workflowMapping.anchors,
        component_strategy: 'card_based_instances',
        image_strategy: this.workflowMapping.images.height_strategy,
        max_images_per_card: this.workflowMapping.images.max_images
      },
      status: this.runState.current_phase,
      errors: this.runState.last_error ? [this.runState.last_error] : []
    };

    console.log('\n📊 Execution Report:');
    console.log(JSON.stringify(report, null, 2));
    
    return report;
  }
}

export default CardBasedFigmaWorkflowAutomator;

// CLI usage
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log('Card-based Workflow Automator - requires MCP client integration');
  console.log('Usage: import CardBasedFigmaWorkflowAutomator from "./workflow_automation_enhanced.js"');
  console.log('Features: FigureCard/BodyCard instances, multi-image slots, dry-run validation');
}
</file>

<file path="src/talk_to_figma_mcp/server.ts">
#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import WebSocket from "ws";
import { v4 as uuidv4 } from "uuid";
import * as fs from "fs";
import * as path from "path";

// Define TypeScript interfaces for Figma responses
interface FigmaResponse {
  id: string;
  result?: any;
  error?: string;
}

// Define interface for command progress updates
interface CommandProgressUpdate {
  type: 'command_progress';
  commandId: string;
  commandType: string;
  status: 'started' | 'in_progress' | 'completed' | 'error';
  progress: number;
  totalItems: number;
  processedItems: number;
  currentChunk?: number;
  totalChunks?: number;
  chunkSize?: number;
  message: string;
  payload?: any;
  timestamp: number;
}

// Update the getInstanceOverridesResult interface to match the plugin implementation
interface getInstanceOverridesResult {
  success: boolean;
  message: string;
  sourceInstanceId: string;
  mainComponentId: string;
  overridesCount: number;
}

interface setInstanceOverridesResult {
  success: boolean;
  message: string;
  totalCount?: number;
  results?: Array<{
    success: boolean;
    instanceId: string;
    instanceName: string;
    appliedCount?: number;
    message?: string;
  }>;
}

// Custom logging functions that write to stderr instead of stdout to avoid being captured
// Log redaction function for sensitive data
function redactSensitiveData(message: string): string {
  return message
    // Redact base64 data URLs (keep first and last 8 chars)
    .replace(/data:image\/[^;]+;base64,([A-Za-z0-9+/]{8})[A-Za-z0-9+/=]+([A-Za-z0-9+/=]{8})/g, 
      'data:image/***;base64,$1***$2 (redacted)')
    // Redact standalone base64 strings (>16 chars)
    .replace(/\b([A-Za-z0-9+/]{8})[A-Za-z0-9+/=]{8,}([A-Za-z0-9+/=]{0,8})\b/g, 
      '$1***$2 (base64 redacted)')
    // Redact imageBase64 parameter values
    .replace(/("imageBase64":\s*")([A-Za-z0-9+/]{8})[A-Za-z0-9+/=]+([A-Za-z0-9+/=]{0,8})(")/g, 
      '$1$2***$3 (redacted)$4')
    // Redact Authorization headers
    .replace(/("?[Aa]uthorization"?\s*:\s*"?)([^\s"]{8})[^\s"]*([^\s"]{0,4})("?)/g, 
      '$1$2***$3 (redacted)$4');
}

const logger = {
  info: (message: string) => process.stderr.write(`[INFO] ${redactSensitiveData(message)}\n`),
  debug: (message: string) => process.stderr.write(`[DEBUG] ${redactSensitiveData(message)}\n`),
  warn: (message: string) => process.stderr.write(`[WARN] ${redactSensitiveData(message)}\n`),
  error: (message: string) => process.stderr.write(`[ERROR] ${redactSensitiveData(message)}\n`),
  log: (message: string) => process.stderr.write(`[LOG] ${redactSensitiveData(message)}\n`)
};

// WebSocket connection and request tracking
let ws: WebSocket | null = null;
const pendingRequests = new Map<string, {
  resolve: (value: unknown) => void;
  reject: (reason: unknown) => void;
  timeout: ReturnType<typeof setTimeout>;
  lastActivity: number; // Add timestamp for last activity
}>();

// Track which channel each client is in
let currentChannel: string | null = null;

// Reconnection state
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const BASE_RECONNECT_DELAY = 1000; // 1 second

// Create MCP server
const server = new McpServer({
  name: "TalkToFigmaMCP",
  version: "1.0.0",
});

// Load configuration
const CONFIG_PATH = path.join(process.cwd(), 'config/server-config.json');
let config: any = {};
try {
  config = JSON.parse(fs.readFileSync(CONFIG_PATH, 'utf8'));
} catch (error) {
  console.warn('Could not load config, using defaults');
  config = { websocket: { port: 3055, host: 'localhost' } };
}

// Helpers for static asset fallback
function getStaticBaseDir(): string {
  try {
    const sc = config?.static_server || {};
    const legacy = sc.assets_path ? path.resolve(process.cwd(), 'src', '..', sc.assets_path) : null;
    // Prefer explicit baseDir; else parent of legacy assets_path; else default
    const baseDir = sc.baseDir
      ? path.resolve(process.cwd(), 'src', '..', sc.baseDir)
      : (legacy ? path.resolve(legacy, '..') : path.resolve(process.cwd(), 'docx2json', 'assets'));
    return baseDir;
  } catch {
    return path.resolve(process.cwd(), 'docx2json', 'assets');
  }
}

function getPublicRoute(): string {
  try {
    return (config?.static_server?.publicRoute || '/assets') as string;
  } catch {
    return '/assets';
  }
}

function localPathFromAssetUrl(imageUrl: string): { ok: boolean; path?: string; reason?: string } {
  try {
    const baseDir = getStaticBaseDir();
    const route = getPublicRoute();
    const u = new URL(imageUrl);
    const pathname = u.pathname; // e.g. /assets/dataset/file.png
    const prefix = route.endsWith('/') ? route.slice(0, -1) : route;
    if (!pathname.startsWith(prefix + '/')) {
      return { ok: false, reason: `URL does not match public route: ${route}` };
    }
    const rel = pathname.slice(prefix.length + 1); // dataset/file
    const normalizedRel = path.normalize(rel);
    const abs = path.resolve(baseDir, normalizedRel);
    const relToBase = path.relative(baseDir, abs);
    if (relToBase.startsWith('..') || path.isAbsolute(relToBase)) {
      return { ok: false, reason: 'Path traversal detected' };
    }
    return { ok: true, path: abs };
  } catch (e: any) {
    return { ok: false, reason: e?.message || 'Invalid URL' };
  }
}

const base64SendTimestamps: number[] = [];
function delay(ms: number) { return new Promise(res => setTimeout(res, ms)); }
async function throttleBase64Send() {
  try {
    const rate = (config?.asset_transfer?.base64_rate_limit ?? 30) as number;
    if (!rate || rate <= 0) return;
    const now = Date.now();
    // keep last 1000ms
    for (let i = base64SendTimestamps.length - 1; i >= 0; i--) {
      if (now - base64SendTimestamps[i] > 1000) {
        base64SendTimestamps.splice(0, i + 1);
        break;
      }
    }
    if (base64SendTimestamps.length >= rate) {
      const oldest = base64SendTimestamps[0];
      const waitMs = Math.max(0, 1000 - (now - oldest));
      if (waitMs > 0) {
        logger.info(`Base64 rate limit reached (${rate}/s). Sleeping ${waitMs}ms...`);
        await delay(waitMs);
      }
      // purge again
      const now2 = Date.now();
      for (let i = base64SendTimestamps.length - 1; i >= 0; i--) {
        if (now2 - base64SendTimestamps[i] > 1000) {
          base64SendTimestamps.splice(0, i + 1);
          break;
        }
      }
    }
    base64SendTimestamps.push(Date.now());
  } catch {}
}

// Add command line argument parsing
const args = process.argv.slice(2);
const serverArg = args.find(arg => arg.startsWith('--server='));
const serverUrl = serverArg ? serverArg.split('=')[1] : `${config.websocket.host}:${config.websocket.port}`;
const WS_URL = serverUrl.includes('localhost') || serverUrl.includes('127.0.0.1') ? 'ws' : 'wss';

// Document Info Tool
server.tool(
  "get_document_info",
  "Get detailed information about the current Figma document",
  {},
  async () => {
    try {
      const result = await sendCommandToFigma("get_document_info");
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting document info: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Selection Tool
server.tool(
  "get_selection",
  "Get information about the current selection in Figma",
  {},
  async () => {
    try {
      const result = await sendCommandToFigma("get_selection");
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting selection: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Read My Design Tool
server.tool(
  "read_my_design",
  "Get detailed information about the current selection in Figma, including all node details",
  {},
  async () => {
    try {
      const result = await sendCommandToFigma("read_my_design", {});
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting node info: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Node Info Tool
server.tool(
  "get_node_info",
  "Get detailed information about a specific node in Figma",
  {
    nodeId: z.string().describe("The ID of the node to get information about"),
  },
  async ({ nodeId }: any) => {
    try {
      const result = await sendCommandToFigma("get_node_info", { nodeId });
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(filterFigmaNode(result))
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting node info: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

function rgbaToHex(color: any): string {
  // skip if color is already hex
  if (color.startsWith('#')) {
    return color;
  }

  const r = Math.round(color.r * 255);
  const g = Math.round(color.g * 255);
  const b = Math.round(color.b * 255);
  const a = Math.round(color.a * 255);

  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${a === 255 ? '' : a.toString(16).padStart(2, '0')}`;
}

function filterFigmaNode(node: any) {
  // Skip VECTOR type nodes
  if (node.type === "VECTOR") {
    return null;
  }

  const filtered: any = {
    id: node.id,
    name: node.name,
    type: node.type,
  };

  if (node.fills && node.fills.length > 0) {
    filtered.fills = node.fills.map((fill: any) => {
      const processedFill = { ...fill };

      // Remove boundVariables and imageRef
      delete processedFill.boundVariables;
      delete processedFill.imageRef;

      // Process gradientStops if present
      if (processedFill.gradientStops) {
        processedFill.gradientStops = processedFill.gradientStops.map((stop: any) => {
          const processedStop = { ...stop };
          // Convert color to hex if present
          if (processedStop.color) {
            processedStop.color = rgbaToHex(processedStop.color);
          }
          // Remove boundVariables
          delete processedStop.boundVariables;
          return processedStop;
        });
      }

      // Convert solid fill colors to hex
      if (processedFill.color) {
        processedFill.color = rgbaToHex(processedFill.color);
      }

      return processedFill;
    });
  }

  if (node.strokes && node.strokes.length > 0) {
    filtered.strokes = node.strokes.map((stroke: any) => {
      const processedStroke = { ...stroke };
      // Remove boundVariables
      delete processedStroke.boundVariables;
      // Convert color to hex if present
      if (processedStroke.color) {
        processedStroke.color = rgbaToHex(processedStroke.color);
      }
      return processedStroke;
    });
  }

  if (node.cornerRadius !== undefined) {
    filtered.cornerRadius = node.cornerRadius;
  }

  if (node.absoluteBoundingBox) {
    filtered.absoluteBoundingBox = node.absoluteBoundingBox;
  }

  if (node.characters) {
    filtered.characters = node.characters;
  }

  if (node.style) {
    filtered.style = {
      fontFamily: node.style.fontFamily,
      fontStyle: node.style.fontStyle,
      fontWeight: node.style.fontWeight,
      fontSize: node.style.fontSize,
      textAlignHorizontal: node.style.textAlignHorizontal,
      letterSpacing: node.style.letterSpacing,
      lineHeightPx: node.style.lineHeightPx
    };
  }

  if (node.children) {
    filtered.children = node.children
      .map((child: any) => filterFigmaNode(child))
      .filter((child: any) => child !== null); // Remove null children (VECTOR nodes)
  }

  return filtered;
}

// Nodes Info Tool
server.tool(
  "get_nodes_info",
  "Get detailed information about multiple nodes in Figma",
  {
    nodeIds: z.array(z.string()).describe("Array of node IDs to get information about")
  },
  async ({ nodeIds }: any) => {
    try {
      const results = await Promise.all(
        nodeIds.map(async (nodeId: any) => {
          const result = await sendCommandToFigma('get_node_info', { nodeId });
          return { nodeId, info: result };
        })
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(results.map((result) => filterFigmaNode(result.info)))
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting nodes info: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);


// Create Rectangle Tool
server.tool(
  "create_rectangle",
  "Create a new rectangle in Figma",
  {
    x: z.number().describe("X position"),
    y: z.number().describe("Y position"),
    width: z.number().describe("Width of the rectangle"),
    height: z.number().describe("Height of the rectangle"),
    name: z.string().optional().describe("Optional name for the rectangle"),
    parentId: z
      .string()
      .optional()
      .describe("Optional parent node ID to append the rectangle to"),
  },
  async ({ x, y, width, height, name, parentId }: any) => {
    try {
      const result = await sendCommandToFigma("create_rectangle", {
        x,
        y,
        width,
        height,
        name: name || "Rectangle",
        parentId,
      });
      return {
        content: [
          {
            type: "text",
            text: `Created rectangle "${JSON.stringify(result)}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error creating rectangle: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Create Frame Tool
server.tool(
  "create_frame",
  "Create a new frame in Figma",
  {
    x: z.number().describe("X position"),
    y: z.number().describe("Y position"),
    width: z.number().describe("Width of the frame"),
    height: z.number().describe("Height of the frame"),
    name: z.string().optional().describe("Optional name for the frame"),
    parentId: z
      .string()
      .optional()
      .describe("Optional parent node ID to append the frame to"),
    fillColor: z
      .object({
        r: z.number().min(0).max(1).describe("Red component (0-1)"),
        g: z.number().min(0).max(1).describe("Green component (0-1)"),
        b: z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: z
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe("Alpha component (0-1)"),
      })
      .optional()
      .describe("Fill color in RGBA format"),
    strokeColor: z
      .object({
        r: z.number().min(0).max(1).describe("Red component (0-1)"),
        g: z.number().min(0).max(1).describe("Green component (0-1)"),
        b: z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: z
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe("Alpha component (0-1)"),
      })
      .optional()
      .describe("Stroke color in RGBA format"),
    strokeWeight: z.number().positive().optional().describe("Stroke weight"),
    layoutMode: z.enum(["NONE", "HORIZONTAL", "VERTICAL"]).optional().describe("Auto-layout mode for the frame"),
    layoutWrap: z.enum(["NO_WRAP", "WRAP"]).optional().describe("Whether the auto-layout frame wraps its children"),
    paddingTop: z.number().optional().describe("Top padding for auto-layout frame"),
    paddingRight: z.number().optional().describe("Right padding for auto-layout frame"),
    paddingBottom: z.number().optional().describe("Bottom padding for auto-layout frame"),
    paddingLeft: z.number().optional().describe("Left padding for auto-layout frame"),
    primaryAxisAlignItems: z
      .enum(["MIN", "MAX", "CENTER", "SPACE_BETWEEN"])
      .optional()
      .describe("Primary axis alignment for auto-layout frame. Note: When set to SPACE_BETWEEN, itemSpacing will be ignored as children will be evenly spaced."),
    counterAxisAlignItems: z.enum(["MIN", "MAX", "CENTER", "BASELINE"]).optional().describe("Counter axis alignment for auto-layout frame"),
    layoutSizingHorizontal: z.enum(["FIXED", "HUG", "FILL"]).optional().describe("Horizontal sizing mode for auto-layout frame"),
    layoutSizingVertical: z.enum(["FIXED", "HUG", "FILL"]).optional().describe("Vertical sizing mode for auto-layout frame"),
    itemSpacing: z
      .number()
      .optional()
      .describe("Distance between children in auto-layout frame. Note: This value will be ignored if primaryAxisAlignItems is set to SPACE_BETWEEN.")
  },
  async ({
    x,
    y,
    width,
    height,
    name,
    parentId,
    fillColor,
    strokeColor,
    strokeWeight,
    layoutMode,
    layoutWrap,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    primaryAxisAlignItems,
    counterAxisAlignItems,
    layoutSizingHorizontal,
    layoutSizingVertical,
    itemSpacing
  }: any) => {
    try {
      const result = await sendCommandToFigma("create_frame", {
        x,
        y,
        width,
        height,
        name: name || "Frame",
        parentId,
        fillColor: fillColor || { r: 1, g: 1, b: 1, a: 1 },
        strokeColor: strokeColor,
        strokeWeight: strokeWeight,
        layoutMode,
        layoutWrap,
        paddingTop,
        paddingRight,
        paddingBottom,
        paddingLeft,
        primaryAxisAlignItems,
        counterAxisAlignItems,
        layoutSizingHorizontal,
        layoutSizingVertical,
        itemSpacing
      });
      const typedResult = result as { name: string; id: string };
      return {
        content: [
          {
            type: "text",
            text: `Created frame "${typedResult.name}" with ID: ${typedResult.id}. Use the ID as the parentId to appendChild inside this frame.`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error creating frame: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Create Text Tool
server.tool(
  "create_text",
  "Create a new text element in Figma",
  {
    x: z.number().describe("X position"),
    y: z.number().describe("Y position"),
    text: z.string().describe("Text content"),
    fontSize: z.number().optional().describe("Font size (default: 14)"),
    fontWeight: z
      .number()
      .optional()
      .describe("Font weight (e.g., 400 for Regular, 700 for Bold)"),
    fontColor: z
      .object({
        r: z.number().min(0).max(1).describe("Red component (0-1)"),
        g: z.number().min(0).max(1).describe("Green component (0-1)"),
        b: z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: z
          .number()
          .min(0)
          .max(1)
          .optional()
          .describe("Alpha component (0-1)"),
      })
      .optional()
      .describe("Font color in RGBA format"),
    name: z
      .string()
      .optional()
      .describe("Semantic layer name for the text node"),
    parentId: z
      .string()
      .optional()
      .describe("Optional parent node ID to append the text to"),
  },
  async ({ x, y, text, fontSize, fontWeight, fontColor, name, parentId }: any) => {
    try {
      const result = await sendCommandToFigma("create_text", {
        x,
        y,
        text,
        fontSize: fontSize || 14,
        fontWeight: fontWeight || 400,
        fontColor: fontColor || { r: 0, g: 0, b: 0, a: 1 },
        name: name || "Text",
        parentId,
      });
      const typedResult = result as { name: string; id: string };
      return {
        content: [
          {
            type: "text",
            text: `Created text "${typedResult.name}" with ID: ${typedResult.id}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error creating text: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Set Fill Color Tool
server.tool(
  "set_fill_color",
  "Set the fill color of a node in Figma can be TextNode or FrameNode",
  {
    nodeId: z.string().describe("The ID of the node to modify"),
    r: z.number().min(0).max(1).describe("Red component (0-1)"),
    g: z.number().min(0).max(1).describe("Green component (0-1)"),
    b: z.number().min(0).max(1).describe("Blue component (0-1)"),
    a: z.number().min(0).max(1).optional().describe("Alpha component (0-1)"),
  },
  async ({ nodeId, r, g, b, a }: any) => {
    try {
      const result = await sendCommandToFigma("set_fill_color", {
        nodeId,
        color: { r, g, b, a: a || 1 },
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Set fill color of node "${typedResult.name
              }" to RGBA(${r}, ${g}, ${b}, ${a || 1})`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting fill color: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Set Stroke Color Tool
server.tool(
  "set_stroke_color",
  "Set the stroke color of a node in Figma",
  {
    nodeId: z.string().describe("The ID of the node to modify"),
    r: z.number().min(0).max(1).describe("Red component (0-1)"),
    g: z.number().min(0).max(1).describe("Green component (0-1)"),
    b: z.number().min(0).max(1).describe("Blue component (0-1)"),
    a: z.number().min(0).max(1).optional().describe("Alpha component (0-1)"),
    weight: z.number().positive().optional().describe("Stroke weight"),
  },
  async ({ nodeId, r, g, b, a, weight }: any) => {
    try {
      const result = await sendCommandToFigma("set_stroke_color", {
        nodeId,
        color: { r, g, b, a: a || 1 },
        weight: weight || 1,
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Set stroke color of node "${typedResult.name
              }" to RGBA(${r}, ${g}, ${b}, ${a || 1}) with weight ${weight || 1}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting stroke color: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Move Node Tool
server.tool(
  "move_node",
  "Move a node to a new position in Figma",
  {
    nodeId: z.string().describe("The ID of the node to move"),
    x: z.number().describe("New X position"),
    y: z.number().describe("New Y position"),
  },
  async ({ nodeId, x, y }: any) => {
    try {
      const result = await sendCommandToFigma("move_node", { nodeId, x, y });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Moved node "${typedResult.name}" to position (${x}, ${y})`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error moving node: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Clone Node Tool
server.tool(
  "clone_node",
  "Clone an existing node in Figma",
  {
    nodeId: z.string().describe("The ID of the node to clone"),
    x: z.number().optional().describe("New X position for the clone"),
    y: z.number().optional().describe("New Y position for the clone")
  },
  async ({ nodeId, x, y }: any) => {
    try {
      const result = await sendCommandToFigma('clone_node', { nodeId, x, y });
      const typedResult = result as { name: string, id: string };
      return {
        content: [
          {
            type: "text",
            text: `Cloned node "${typedResult.name}" with new ID: ${typedResult.id}${x !== undefined && y !== undefined ? ` at position (${x}, ${y})` : ''}`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error cloning node: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Resize Node Tool
server.tool(
  "resize_node",
  "Resize a node in Figma",
  {
    nodeId: z.string().describe("The ID of the node to resize"),
    width: z.number().positive().describe("New width"),
    height: z.number().positive().describe("New height"),
  },
  async ({ nodeId, width, height }: any) => {
    try {
      const result = await sendCommandToFigma("resize_node", {
        nodeId,
        width,
        height,
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Resized node "${typedResult.name}" to width ${width} and height ${height}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error resizing node: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Delete Node Tool
server.tool(
  "delete_node",
  "Delete a node from Figma",
  {
    nodeId: z.string().describe("The ID of the node to delete"),
  },
  async ({ nodeId }: any) => {
    try {
      await sendCommandToFigma("delete_node", { nodeId });
      return {
        content: [
          {
            type: "text",
            text: `Deleted node with ID: ${nodeId}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error deleting node: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Delete Multiple Nodes Tool
server.tool(
  "delete_multiple_nodes",
  "Delete multiple nodes from Figma at once",
  {
    nodeIds: z.array(z.string()).describe("Array of node IDs to delete"),
  },
  async ({ nodeIds }: any) => {
    try {
      const result = await sendCommandToFigma("delete_multiple_nodes", { nodeIds });
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error deleting multiple nodes: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Export Node as Image Tool
server.tool(
  "export_node_as_image",
  "Export a node as an image from Figma",
  {
    nodeId: z.string().describe("The ID of the node to export"),
    format: z
      .enum(["PNG", "JPG", "SVG", "PDF"])
      .optional()
      .describe("Export format"),
    scale: z.number().positive().optional().describe("Export scale"),
  },
  async ({ nodeId, format, scale }: any) => {
    try {
      const result = await sendCommandToFigma("export_node_as_image", {
        nodeId,
        format: format || "PNG",
        scale: scale || 1,
      });
      const typedResult = result as { imageData: string; mimeType: string };

      return {
        content: [
          {
            type: "image",
            data: typedResult.imageData,
            mimeType: typedResult.mimeType || "image/png",
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error exporting node as image: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Set Text Content Tool
server.tool(
  "set_text_content",
  "Set the text content of an existing text node in Figma",
  {
    nodeId: z.string().describe("The ID of the text node to modify"),
    text: z.string().describe("New text content"),
  },
  async ({ nodeId, text }: any) => {
    try {
      const result = await sendCommandToFigma("set_text_content", {
        nodeId,
        text,
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Updated text content of node "${typedResult.name}" to "${text}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting text content: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Get Styles Tool
server.tool(
  "get_styles",
  "Get all styles from the current Figma document",
  {},
  async () => {
    try {
      const result = await sendCommandToFigma("get_styles");
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting styles: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Get Local Components Tool
server.tool(
  "get_local_components",
  "Get all local components from the Figma document",
  {},
  async () => {
    try {
      const result = await sendCommandToFigma("get_local_components");
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting local components: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Get Annotations Tool
server.tool(
  "get_annotations",
  "Get all annotations in the current document or specific node",
  {
    nodeId: z.string().describe("node ID to get annotations for specific node"),
    includeCategories: z.boolean().optional().default(true).describe("Whether to include category information")
  },
  async ({ nodeId, includeCategories }: any) => {
    try {
      const result = await sendCommandToFigma("get_annotations", {
        nodeId,
        includeCategories
      });
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting annotations: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Set Annotation Tool
server.tool(
  "set_annotation",
  "Create or update an annotation",
  {
    nodeId: z.string().describe("The ID of the node to annotate"),
    annotationId: z.string().optional().describe("The ID of the annotation to update (if updating existing annotation)"),
    labelMarkdown: z.string().describe("The annotation text in markdown format"),
    categoryId: z.string().optional().describe("The ID of the annotation category"),
    properties: z.array(z.object({
      type: z.string()
    })).optional().describe("Additional properties for the annotation")
  },
  async ({ nodeId, annotationId, labelMarkdown, categoryId, properties }: any) => {
    try {
      const result = await sendCommandToFigma("set_annotation", {
        nodeId,
        annotationId,
        labelMarkdown,
        categoryId,
        properties
      });
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting annotation: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

interface SetMultipleAnnotationsParams {
  nodeId: string;
  annotations: Array<{
    nodeId: string;
    labelMarkdown: string;
    categoryId?: string;
    annotationId?: string;
    properties?: Array<{ type: string }>;
  }>;
}

// Set Multiple Annotations Tool
server.tool(
  "set_multiple_annotations",
  "Set multiple annotations parallelly in a node",
  {
    nodeId: z
      .string()
      .describe("The ID of the node containing the elements to annotate"),
    annotations: z
      .array(
        z.object({
          nodeId: z.string().describe("The ID of the node to annotate"),
          labelMarkdown: z.string().describe("The annotation text in markdown format"),
          categoryId: z.string().optional().describe("The ID of the annotation category"),
          annotationId: z.string().optional().describe("The ID of the annotation to update (if updating existing annotation)"),
          properties: z.array(z.object({
            type: z.string()
          })).optional().describe("Additional properties for the annotation")
        })
      )
      .describe("Array of annotations to apply"),
  },
  async ({ nodeId, annotations }: any) => {
    try {
      if (!annotations || annotations.length === 0) {
        return {
          content: [
            {
              type: "text",
              text: "No annotations provided",
            },
          ],
        };
      }

      // Initial response to indicate we're starting the process
      const initialStatus = {
        type: "text" as const,
        text: `Starting annotation process for ${annotations.length} nodes. This will be processed in batches of 5...`,
      };

      // Track overall progress
      let totalProcessed = 0;
      const totalToProcess = annotations.length;

      // Use the plugin's set_multiple_annotations function with chunking
      const result = await sendCommandToFigma("set_multiple_annotations", {
        nodeId,
        annotations,
      });

      // Cast the result to a specific type to work with it safely
      interface AnnotationResult {
        success: boolean;
        nodeId: string;
        annotationsApplied?: number;
        annotationsFailed?: number;
        totalAnnotations?: number;
        completedInChunks?: number;
        results?: Array<{
          success: boolean;
          nodeId: string;
          error?: string;
          annotationId?: string;
        }>;
      }

      const typedResult = result as AnnotationResult;

      // Format the results for display
      const success = typedResult.annotationsApplied && typedResult.annotationsApplied > 0;
      const progressText = `
      Annotation process completed:
      - ${typedResult.annotationsApplied || 0} of ${totalToProcess} successfully applied
      - ${typedResult.annotationsFailed || 0} failed
      - Processed in ${typedResult.completedInChunks || 1} batches
      `;

      // Detailed results
      const detailedResults = typedResult.results || [];
      const failedResults = detailedResults.filter(item => !item.success);

      // Create the detailed part of the response
      let detailedResponse = "";
      if (failedResults.length > 0) {
        detailedResponse = `\n\nNodes that failed:\n${failedResults.map(item =>
          `- ${item.nodeId}: ${item.error || "Unknown error"}`
        ).join('\n')}`;
      }

      return {
        content: [
          initialStatus,
          {
            type: "text" as const,
            text: progressText + detailedResponse,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting multiple annotations: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Create Component Instance Tool
server.tool(
  "create_component_instance",
  "Create an instance of a component in Figma",
  {
    componentKey: z.string().optional().describe("Key of the component to instantiate"),
    componentId: z.string().optional().describe("ID of the component to instantiate"),
    parentId: z.string().optional().describe("Optional parent node ID to append the instance to"),
    x: z.number().describe("X position"),
    y: z.number().describe("Y position"),
  },
  async ({ componentKey, componentId, parentId, x, y }: any) => {
    // Manual validation: at least one component identifier required
    if (!componentId && !componentKey) {
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({ 
              success: false, 
              message: "Either componentId (local) or componentKey (library) must be provided" 
            }),
          },
        ],
      };
    }

    try {
      // Only send non-empty parameters to avoid empty string confusion
      const params: any = { x, y };
      if (componentId && componentId.trim() !== '') {
        params.componentId = componentId;
      }
      if (componentKey && componentKey.trim() !== '') {
        params.componentKey = componentKey;
      }
      if (parentId && parentId.trim() !== '') {
        params.parentId = parentId;
      }

      const result = await sendCommandToFigma("create_component_instance", params);
      const typedResult = result as any;
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(typedResult),
          }
        ]
      };
    } catch (error) {
      const errorResult = { success: false, error: error instanceof Error ? error.message : String(error) };
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(errorResult),
          },
        ]
      };
    }
  }
);

// Copy Instance Overrides Tool
server.tool(
  "get_instance_overrides",
  "Get all override properties from a selected component instance. These overrides can be applied to other instances, which will swap them to match the source component.",
  {
    nodeId: z.string().optional().describe("Optional ID of the component instance to get overrides from. If not provided, currently selected instance will be used."),
  },
  async ({ nodeId }: any) => {
    try {
      const result = await sendCommandToFigma("get_instance_overrides", {
        instanceNodeId: nodeId || null
      });
      const typedResult = result as getInstanceOverridesResult;

      return {
        content: [
          {
            type: "text",
            text: typedResult.success
              ? `Successfully got instance overrides: ${typedResult.message}`
              : `Failed to get instance overrides: ${typedResult.message}`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error copying instance overrides: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Get Component Property References Tool
server.tool(
  "get_component_property_references",
  "Get component property references from a Figma instance node, returning PropertyName#ID format strings",
  {
    nodeId: z.string().describe("ID of the component instance node")
  },
  async ({ nodeId }: any) => {
    try {
      const result = await sendCommandToFigma("get_component_property_references", {
        nodeId: nodeId
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting component property references: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Instance Properties Tool
server.tool(
  "set_instance_properties",
  "Set component properties on a Figma instance using PropertyName#ID format",
  {
    nodeId: z.string().describe("ID of the instance node"),
    properties: z.record(z.union([z.boolean(), z.string(), z.number()])).describe("Properties object where keys are PropertyName#ID format")
  },
  async ({ nodeId, properties }: any) => {
    try {
      const result = await sendCommandToFigma("set_instance_properties", {
        nodeId: nodeId,
        properties: properties
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting instance properties: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Instance Properties by Base Names Tool
server.tool(
  "set_instance_properties_by_base", 
  "Set component properties using base names (showTitle, showImg2, etc.) with automatic PropertyName#ID conversion",
  {
    nodeId: z.string().describe("ID of the instance node"),
    properties: z.record(z.union([z.boolean(), z.string(), z.number()])).describe("Properties object using base names (showTitle, showSource, showImg2, etc.)")
  },
  async ({ nodeId, properties }: any) => {
    try {
      const result = await sendCommandToFigma("set_instance_properties_by_base", {
        nodeId: nodeId,
        properties: properties
      });

      return {
        content: [
          {
            type: "text", 
            text: JSON.stringify(result)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting properties by base names: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Set Instance Overrides Tool
server.tool(
  "set_instance_overrides",
  "Apply previously copied overrides to selected component instances. Target instances will be swapped to the source component and all copied override properties will be applied.",
  {
    sourceInstanceId: z.string().describe("ID of the source component instance"),
    targetNodeIds: z.array(z.string()).describe("Array of target instance IDs. Currently selected instances will be used.")
  },
  async ({ sourceInstanceId, targetNodeIds }: any) => {
    try {
      const result = await sendCommandToFigma("set_instance_overrides", {
        sourceInstanceId: sourceInstanceId,
        targetNodeIds: targetNodeIds || []
      });
      const typedResult = result as setInstanceOverridesResult;

      if (typedResult.success) {
        const successCount = typedResult.results?.filter(r => r.success).length || 0;
        return {
          content: [
            {
              type: "text",
              text: `Successfully applied ${typedResult.totalCount || 0} overrides to ${successCount} instances.`
            }
          ]
        };
      } else {
        return {
          content: [
            {
              type: "text",
              text: `Failed to set instance overrides: ${typedResult.message}`
            }
          ]
        };
      }
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting instance overrides: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);


// Set Corner Radius Tool
server.tool(
  "set_corner_radius",
  "Set the corner radius of a node in Figma",
  {
    nodeId: z.string().describe("The ID of the node to modify"),
    radius: z.number().min(0).describe("Corner radius value"),
    corners: z
      .array(z.boolean())
      .length(4)
      .optional()
      .describe(
        "Optional array of 4 booleans to specify which corners to round [topLeft, topRight, bottomRight, bottomLeft]"
      ),
  },
  async ({ nodeId, radius, corners }: any) => {
    try {
      const result = await sendCommandToFigma("set_corner_radius", {
        nodeId,
        radius,
        corners: corners || [true, true, true, true],
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Set corner radius of node "${typedResult.name}" to ${radius}px`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting corner radius: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Define design strategy prompt
server.prompt(
  "design_strategy",
  "Best practices for working with Figma designs",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `When working with Figma designs, follow these best practices:

1. Start with Document Structure:
   - First use get_document_info() to understand the current document
   - Plan your layout hierarchy before creating elements
   - Create a main container frame for each screen/section

2. Naming Conventions:
   - Use descriptive, semantic names for all elements
   - Follow a consistent naming pattern (e.g., "Login Screen", "Logo Container", "Email Input")
   - Group related elements with meaningful names

3. Layout Hierarchy:
   - Create parent frames first, then add child elements
   - For forms/login screens:
     * Start with the main screen container frame
     * Create a logo container at the top
     * Group input fields in their own containers
     * Place action buttons (login, submit) after inputs
     * Add secondary elements (forgot password, signup links) last

4. Input Fields Structure:
   - Create a container frame for each input field
   - Include a label text above or inside the input
   - Group related inputs (e.g., username/password) together

5. Element Creation:
   - Use create_frame() for containers and input fields
   - Use create_text() for labels, buttons text, and links
   - Set appropriate colors and styles:
     * Use fillColor for backgrounds
     * Use strokeColor for borders
     * Set proper fontWeight for different text elements

6. Mofifying existing elements:
  - use set_text_content() to modify text content.

7. Visual Hierarchy:
   - Position elements in logical reading order (top to bottom)
   - Maintain consistent spacing between elements
   - Use appropriate font sizes for different text types:
     * Larger for headings/welcome text
     * Medium for input labels
     * Standard for button text
     * Smaller for helper text/links

8. Best Practices:
   - Verify each creation with get_node_info()
   - Use parentId to maintain proper hierarchy
   - Group related elements together in frames
   - Keep consistent spacing and alignment

Example Login Screen Structure:
- Login Screen (main frame)
  - Logo Container (frame)
    - Logo (image/text)
  - Welcome Text (text)
  - Input Container (frame)
    - Email Input (frame)
      - Email Label (text)
      - Email Field (frame)
    - Password Input (frame)
      - Password Label (text)
      - Password Field (frame)
  - Login Button (frame)
    - Button Text (text)
  - Helper Links (frame)
    - Forgot Password (text)
    - Don't have account (text)`,
          },
        },
      ],
      description: "Best practices for working with Figma designs",
    };
  }
);

server.prompt(
  "read_design_strategy",
  "Best practices for reading Figma designs",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `When reading Figma designs, follow these best practices:

1. Start with selection:
   - First use read_my_design() to understand the current selection
   - If no selection ask user to select single or multiple nodes
`,
          },
        },
      ],
      description: "Best practices for reading Figma designs",
    };
  }
);

// Text Node Scanning Tool
server.tool(
  "scan_text_nodes",
  "Scan all text nodes in the selected Figma node",
  {
    nodeId: z.string().describe("ID of the node to scan"),
  },
  async ({ nodeId }: any) => {
    try {
      // Initial response to indicate we're starting the process
      const initialStatus = {
        type: "text" as const,
        text: "Starting text node scanning. This may take a moment for large designs...",
      };

      // Use the plugin's scan_text_nodes function with chunking flag
      const result = await sendCommandToFigma("scan_text_nodes", {
        nodeId,
        useChunking: true,  // Enable chunking on the plugin side
        chunkSize: 10       // Process 10 nodes at a time
      });

      // If the result indicates chunking was used, format the response accordingly
      if (result && typeof result === 'object' && 'chunks' in result) {
        const typedResult = result as {
          success: boolean,
          totalNodes: number,
          processedNodes: number,
          chunks: number,
          textNodes: Array<any>
        };

        const summaryText = `
        Scan completed:
        - Found ${typedResult.totalNodes} text nodes
        - Processed in ${typedResult.chunks} chunks
        `;

        return {
          content: [
            initialStatus,
            {
              type: "text" as const,
              text: summaryText
            },
            {
              type: "text" as const,
              text: JSON.stringify(typedResult.textNodes, null, 2)
            }
          ],
        };
      }

      // If chunking wasn't used or wasn't reported in the result format, return the result as is
      return {
        content: [
          initialStatus,
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error scanning text nodes: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Node Type Scanning Tool
server.tool(
  "scan_nodes_by_types",
  "Scan for child nodes with specific types in the selected Figma node",
  {
    nodeId: z.string().describe("ID of the node to scan"),
    types: z.array(z.string()).describe("Array of node types to find in the child nodes (e.g. ['COMPONENT', 'FRAME'])")
  },
  async ({ nodeId, types }: any) => {
    try {
      // Initial response to indicate we're starting the process
      const initialStatus = {
        type: "text" as const,
        text: `Starting node type scanning for types: ${types.join(', ')}...`,
      };

      // Use the plugin's scan_nodes_by_types function
      const result = await sendCommandToFigma("scan_nodes_by_types", {
        nodeId,
        types
      });

      // Format the response
      if (result && typeof result === 'object' && 'matchingNodes' in result) {
        const typedResult = result as {
          success: boolean,
          count: number,
          matchingNodes: Array<{
            id: string,
            name: string,
            type: string,
            bbox: {
              x: number,
              y: number,
              width: number,
              height: number
            }
          }>,
          searchedTypes: Array<string>
        };

        const summaryText = `Scan completed: Found ${typedResult.count} nodes matching types: ${typedResult.searchedTypes.join(', ')}`;

        return {
          content: [
            initialStatus,
            {
              type: "text" as const,
              text: summaryText
            },
            {
              type: "text" as const,
              text: JSON.stringify(typedResult.matchingNodes, null, 2)
            }
          ],
        };
      }

      // If the result is in an unexpected format, return it as is
      return {
        content: [
          initialStatus,
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error scanning nodes by types: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Text Replacement Strategy Prompt
server.prompt(
  "text_replacement_strategy",
  "Systematic approach for replacing text in Figma designs",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `# Intelligent Text Replacement Strategy

## 1. Analyze Design & Identify Structure
- Scan text nodes to understand the overall structure of the design
- Use AI pattern recognition to identify logical groupings:
  * Tables (rows, columns, headers, cells)
  * Lists (items, headers, nested lists)
  * Card groups (similar cards with recurring text fields)
  * Forms (labels, input fields, validation text)
  * Navigation (menu items, breadcrumbs)
\`\`\`
scan_text_nodes(nodeId: "node-id")
get_node_info(nodeId: "node-id")  // optional
\`\`\`

## 2. Strategic Chunking for Complex Designs
- Divide replacement tasks into logical content chunks based on design structure
- Use one of these chunking strategies that best fits the design:
  * **Structural Chunking**: Table rows/columns, list sections, card groups
  * **Spatial Chunking**: Top-to-bottom, left-to-right in screen areas
  * **Semantic Chunking**: Content related to the same topic or functionality
  * **Component-Based Chunking**: Process similar component instances together

## 3. Progressive Replacement with Verification
- Create a safe copy of the node for text replacement
- Replace text chunk by chunk with continuous progress updates
- After each chunk is processed:
  * Export that section as a small, manageable image
  * Verify text fits properly and maintain design integrity
  * Fix issues before proceeding to the next chunk

\`\`\`
// Clone the node to create a safe copy
clone_node(nodeId: "selected-node-id", x: [new-x], y: [new-y])

// Replace text chunk by chunk
set_multiple_text_contents(
  nodeId: "parent-node-id", 
  text: [
    { nodeId: "node-id-1", text: "New text 1" },
    // More nodes in this chunk...
  ]
)

// Verify chunk with small, targeted image exports
export_node_as_image(nodeId: "chunk-node-id", format: "PNG", scale: 0.5)
\`\`\`

## 4. Intelligent Handling for Table Data
- For tabular content:
  * Process one row or column at a time
  * Maintain alignment and spacing between cells
  * Consider conditional formatting based on cell content
  * Preserve header/data relationships

## 5. Smart Text Adaptation
- Adaptively handle text based on container constraints:
  * Auto-detect space constraints and adjust text length
  * Apply line breaks at appropriate linguistic points
  * Maintain text hierarchy and emphasis
  * Consider font scaling for critical content that must fit

## 6. Progressive Feedback Loop
- Establish a continuous feedback loop during replacement:
  * Real-time progress updates (0-100%)
  * Small image exports after each chunk for verification
  * Issues identified early and resolved incrementally
  * Quick adjustments applied to subsequent chunks

## 7. Final Verification & Context-Aware QA
- After all chunks are processed:
  * Export the entire design at reduced scale for final verification
  * Check for cross-chunk consistency issues
  * Verify proper text flow between different sections
  * Ensure design harmony across the full composition

## 8. Chunk-Specific Export Scale Guidelines
- Scale exports appropriately based on chunk size:
  * Small chunks (1-5 elements): scale 1.0
  * Medium chunks (6-20 elements): scale 0.7
  * Large chunks (21-50 elements): scale 0.5
  * Very large chunks (50+ elements): scale 0.3
  * Full design verification: scale 0.2

## Sample Chunking Strategy for Common Design Types

### Tables
- Process by logical rows (5-10 rows per chunk)
- Alternative: Process by column for columnar analysis
- Tip: Always include header row in first chunk for reference

### Card Lists
- Group 3-5 similar cards per chunk
- Process entire cards to maintain internal consistency
- Verify text-to-image ratio within cards after each chunk

### Forms
- Group related fields (e.g., "Personal Information", "Payment Details")
- Process labels and input fields together
- Ensure validation messages and hints are updated with their fields

### Navigation & Menus
- Process hierarchical levels together (main menu, submenu)
- Respect information architecture relationships
- Verify menu fit and alignment after replacement

## Best Practices
- **Preserve Design Intent**: Always prioritize design integrity
- **Structural Consistency**: Maintain alignment, spacing, and hierarchy
- **Visual Feedback**: Verify each chunk visually before proceeding
- **Incremental Improvement**: Learn from each chunk to improve subsequent ones
- **Balance Automation & Control**: Let AI handle repetitive replacements but maintain oversight
- **Respect Content Relationships**: Keep related content consistent across chunks

Remember that text is never just text—it's a core design element that must work harmoniously with the overall composition. This chunk-based strategy allows you to methodically transform text while maintaining design integrity.`,
          },
        },
      ],
      description: "Systematic approach for replacing text in Figma designs",
    };
  }
);

// Set Multiple Text Contents Tool
server.tool(
  "set_multiple_text_contents",
  "Set multiple text contents parallelly in a node",
  {
    nodeId: z
      .string()
      .describe("The ID of the node containing the text nodes to replace"),
    text: z
      .array(
        z.object({
          nodeId: z.string().describe("The ID of the text node"),
          text: z.string().describe("The replacement text"),
        })
      )
      .describe("Array of text node IDs and their replacement texts"),
  },
  async ({ nodeId, text }: any) => {
    try {
      if (!text || text.length === 0) {
        return {
          content: [
            {
              type: "text",
              text: "No text provided",
            },
          ],
        };
      }

      // Initial response to indicate we're starting the process
      const initialStatus = {
        type: "text" as const,
        text: `Starting text replacement for ${text.length} nodes. This will be processed in batches of 5...`,
      };

      // Track overall progress
      let totalProcessed = 0;
      const totalToProcess = text.length;

      // Use the plugin's set_multiple_text_contents function with chunking
      const result = await sendCommandToFigma("set_multiple_text_contents", {
        nodeId,
        text,
      });

      // Cast the result to a specific type to work with it safely
      interface TextReplaceResult {
        success: boolean;
        nodeId: string;
        replacementsApplied?: number;
        replacementsFailed?: number;
        totalReplacements?: number;
        completedInChunks?: number;
        results?: Array<{
          success: boolean;
          nodeId: string;
          error?: string;
          originalText?: string;
          translatedText?: string;
        }>;
      }

      const typedResult = result as TextReplaceResult;

      // Format the results for display
      const success = typedResult.replacementsApplied && typedResult.replacementsApplied > 0;
      const progressText = `
      Text replacement completed:
      - ${typedResult.replacementsApplied || 0} of ${totalToProcess} successfully updated
      - ${typedResult.replacementsFailed || 0} failed
      - Processed in ${typedResult.completedInChunks || 1} batches
      `;

      // Detailed results
      const detailedResults = typedResult.results || [];
      const failedResults = detailedResults.filter(item => !item.success);

      // Create the detailed part of the response
      let detailedResponse = "";
      if (failedResults.length > 0) {
        detailedResponse = `\n\nNodes that failed:\n${failedResults.map(item =>
          `- ${item.nodeId}: ${item.error || "Unknown error"}`
        ).join('\n')}`;
      }

      return {
        content: [
          initialStatus,
          {
            type: "text" as const,
            text: progressText + detailedResponse,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting multiple text contents: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Annotation Conversion Strategy Prompt
server.prompt(
  "annotation_conversion_strategy",
  "Strategy for converting manual annotations to Figma's native annotations",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `# Automatic Annotation Conversion
            
## Process Overview

The process of converting manual annotations (numbered/alphabetical indicators with connected descriptions) to Figma's native annotations:

1. Get selected frame/component information
2. Scan and collect all annotation text nodes
3. Scan target UI elements (components, instances, frames)
4. Match annotations to appropriate UI elements
5. Apply native Figma annotations

## Step 1: Get Selection and Initial Setup

First, get the selected frame or component that contains annotations:

\`\`\`typescript
// Get the selected frame/component
const selection = await get_selection();
const selectedNodeId = selection[0].id

// Get available annotation categories for later use
const annotationData = await get_annotations({
  nodeId: selectedNodeId,
  includeCategories: true
});
const categories = annotationData.categories;
\`\`\`

## Step 2: Scan Annotation Text Nodes

Scan all text nodes to identify annotations and their descriptions:

\`\`\`typescript
// Get all text nodes in the selection
const textNodes = await scan_text_nodes({
  nodeId: selectedNodeId
});

// Filter and group annotation markers and descriptions

// Markers typically have these characteristics:
// - Short text content (usually single digit/letter)
// - Specific font styles (often bold)
// - Located in a container with "Marker" or "Dot" in the name
// - Have a clear naming pattern (e.g., "1", "2", "3" or "A", "B", "C")


// Identify description nodes
// Usually longer text nodes near markers or with matching numbers in path
  
\`\`\`

## Step 3: Scan Target UI Elements

Get all potential target elements that annotations might refer to:

\`\`\`typescript
// Scan for all UI elements that could be annotation targets
const targetNodes = await scan_nodes_by_types({
  nodeId: selectedNodeId,
  types: [
    "COMPONENT",
    "INSTANCE",
    "FRAME"
  ]
});
\`\`\`

## Step 4: Match Annotations to Targets

Match each annotation to its target UI element using these strategies in order of priority:

1. **Path-Based Matching**:
   - Look at the marker's parent container name in the Figma layer hierarchy
   - Remove any "Marker:" or "Annotation:" prefixes from the parent name
   - Find UI elements that share the same parent name or have it in their path
   - This works well when markers are grouped with their target elements

2. **Name-Based Matching**:
   - Extract key terms from the annotation description
   - Look for UI elements whose names contain these key terms
   - Consider both exact matches and semantic similarities
   - Particularly effective for form fields, buttons, and labeled components

3. **Proximity-Based Matching** (fallback):
   - Calculate the center point of the marker
   - Find the closest UI element by measuring distances to element centers
   - Consider the marker's position relative to nearby elements
   - Use this method when other matching strategies fail

Additional Matching Considerations:
- Give higher priority to matches found through path-based matching
- Consider the type of UI element when evaluating matches
- Take into account the annotation's context and content
- Use a combination of strategies for more accurate matching

## Step 5: Apply Native Annotations

Convert matched annotations to Figma's native annotations using batch processing:

\`\`\`typescript
// Prepare annotations array for batch processing
const annotationsToApply = Object.values(annotations).map(({ marker, description }) => {
  // Find target using multiple strategies
  const target = 
    findTargetByPath(marker, targetNodes) ||
    findTargetByName(description, targetNodes) ||
    findTargetByProximity(marker, targetNodes);
  
  if (target) {
    // Determine appropriate category based on content
    const category = determineCategory(description.characters, categories);

    // Determine appropriate additional annotationProperty based on content
    const annotationProperty = determineProperties(description.characters, target.type);
    
    return {
      nodeId: target.id,
      labelMarkdown: description.characters,
      categoryId: category.id,
      properties: annotationProperty
    };
  }
  return null;
}).filter(Boolean); // Remove null entries

// Apply annotations in batches using set_multiple_annotations
if (annotationsToApply.length > 0) {
  await set_multiple_annotations({
    nodeId: selectedNodeId,
    annotations: annotationsToApply
  });
}
\`\`\`


This strategy focuses on practical implementation based on real-world usage patterns, emphasizing the importance of handling various UI elements as annotation targets, not just text nodes.`
          },
        },
      ],
      description: "Strategy for converting manual annotations to Figma's native annotations",
    };
  }
);

// Instance Slot Filling Strategy Prompt
server.prompt(
  "swap_overrides_instances",
  "Guide to swap instance overrides between instances",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `# Swap Component Instance and Override Strategy

## Overview
This strategy enables transferring content and property overrides from a source instance to one or more target instances in Figma, maintaining design consistency while reducing manual work.

## Step-by-Step Process

### 1. Selection Analysis
- Use \`get_selection()\` to identify the parent component or selected instances
- For parent components, scan for instances with \`scan_nodes_by_types({ nodeId: "parent-id", types: ["INSTANCE"] })\`
- Identify custom slots by name patterns (e.g. "Custom Slot*" or "Instance Slot") or by examining text content
- Determine which is the source instance (with content to copy) and which are targets (where to apply content)

### 2. Extract Source Overrides
- Use \`get_instance_overrides()\` to extract customizations from the source instance
- This captures text content, property values, and style overrides
- Command syntax: \`get_instance_overrides({ nodeId: "source-instance-id" })\`
- Look for successful response like "Got component information from [instance name]"

### 3. Apply Overrides to Targets
- Apply captured overrides using \`set_instance_overrides()\`
- Command syntax:
  \`\`\`
  set_instance_overrides({
    sourceInstanceId: "source-instance-id", 
    targetNodeIds: ["target-id-1", "target-id-2", ...]
  })
  \`\`\`

### 4. Verification
- Verify results with \`get_node_info()\` or \`read_my_design()\`
- Confirm text content and style overrides have transferred successfully

## Key Tips
- Always join the appropriate channel first with \`join_channel()\`
- When working with multiple targets, check the full selection with \`get_selection()\`
- Preserve component relationships by using instance overrides rather than direct text manipulation`,
          },
        },
      ],
      description: "Strategy for transferring overrides between component instances in Figma",
    };
  }
);

// Set Layout Mode Tool
server.tool(
  "set_layout_mode",
  "Set the layout mode and wrap behavior of a frame in Figma",
  {
    nodeId: z.string().describe("The ID of the frame to modify"),
    layoutMode: z.enum(["NONE", "HORIZONTAL", "VERTICAL"]).describe("Layout mode for the frame"),
    layoutWrap: z.enum(["NO_WRAP", "WRAP"]).optional().describe("Whether the auto-layout frame wraps its children")
  },
  async ({ nodeId, layoutMode, layoutWrap }: any) => {
    try {
      const result = await sendCommandToFigma("set_layout_mode", {
        nodeId,
        layoutMode,
        layoutWrap: layoutWrap || "NO_WRAP"
      });
      const typedResult = result as { name: string };
      return {
        content: [
          {
            type: "text",
            text: `Set layout mode of frame "${typedResult.name}" to ${layoutMode}${layoutWrap ? ` with ${layoutWrap}` : ''}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting layout mode: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Padding Tool
server.tool(
  "set_padding",
  "Set padding values for an auto-layout frame in Figma",
  {
    nodeId: z.string().describe("The ID of the frame to modify"),
    paddingTop: z.number().optional().describe("Top padding value"),
    paddingRight: z.number().optional().describe("Right padding value"),
    paddingBottom: z.number().optional().describe("Bottom padding value"),
    paddingLeft: z.number().optional().describe("Left padding value"),
  },
  async ({ nodeId, paddingTop, paddingRight, paddingBottom, paddingLeft }: any) => {
    try {
      const result = await sendCommandToFigma("set_padding", {
        nodeId,
        paddingTop,
        paddingRight,
        paddingBottom,
        paddingLeft,
      });
      const typedResult = result as { name: string };

      // Create a message about which padding values were set
      const paddingMessages = [];
      if (paddingTop !== undefined) paddingMessages.push(`top: ${paddingTop}`);
      if (paddingRight !== undefined) paddingMessages.push(`right: ${paddingRight}`);
      if (paddingBottom !== undefined) paddingMessages.push(`bottom: ${paddingBottom}`);
      if (paddingLeft !== undefined) paddingMessages.push(`left: ${paddingLeft}`);

      const paddingText = paddingMessages.length > 0
        ? `padding (${paddingMessages.join(', ')})`
        : "padding";

      return {
        content: [
          {
            type: "text",
            text: `Set ${paddingText} for frame "${typedResult.name}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting padding: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Axis Align Tool
server.tool(
  "set_axis_align",
  "Set primary and counter axis alignment for an auto-layout frame in Figma",
  {
    nodeId: z.string().describe("The ID of the frame to modify"),
    primaryAxisAlignItems: z
      .enum(["MIN", "MAX", "CENTER", "SPACE_BETWEEN"])
      .optional()
      .describe("Primary axis alignment (MIN/MAX = left/right in horizontal, top/bottom in vertical). Note: When set to SPACE_BETWEEN, itemSpacing will be ignored as children will be evenly spaced."),
    counterAxisAlignItems: z
      .enum(["MIN", "MAX", "CENTER", "BASELINE"])
      .optional()
      .describe("Counter axis alignment (MIN/MAX = top/bottom in horizontal, left/right in vertical)")
  },
  async ({ nodeId, primaryAxisAlignItems, counterAxisAlignItems }: any) => {
    try {
      const result = await sendCommandToFigma("set_axis_align", {
        nodeId,
        primaryAxisAlignItems,
        counterAxisAlignItems
      });
      const typedResult = result as { name: string };

      // Create a message about which alignments were set
      const alignMessages = [];
      if (primaryAxisAlignItems !== undefined) alignMessages.push(`primary: ${primaryAxisAlignItems}`);
      if (counterAxisAlignItems !== undefined) alignMessages.push(`counter: ${counterAxisAlignItems}`);

      const alignText = alignMessages.length > 0
        ? `axis alignment (${alignMessages.join(', ')})`
        : "axis alignment";

      return {
        content: [
          {
            type: "text",
            text: `Set ${alignText} for frame "${typedResult.name}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting axis alignment: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Layout Sizing Tool
server.tool(
  "set_layout_sizing",
  "Set horizontal and vertical sizing modes for an auto-layout frame in Figma",
  {
    nodeId: z.string().describe("The ID of the frame to modify"),
    layoutSizingHorizontal: z
      .enum(["FIXED", "HUG", "FILL"])
      .optional()
      .describe("Horizontal sizing mode (HUG for frames/text only, FILL for auto-layout children only)"),
    layoutSizingVertical: z
      .enum(["FIXED", "HUG", "FILL"])
      .optional()
      .describe("Vertical sizing mode (HUG for frames/text only, FILL for auto-layout children only)")
  },
  async ({ nodeId, layoutSizingHorizontal, layoutSizingVertical }: any) => {
    try {
      const result = await sendCommandToFigma("set_layout_sizing", {
        nodeId,
        layoutSizingHorizontal,
        layoutSizingVertical
      });
      const typedResult = result as { name: string };

      // Create a message about which sizing modes were set
      const sizingMessages = [];
      if (layoutSizingHorizontal !== undefined) sizingMessages.push(`horizontal: ${layoutSizingHorizontal}`);
      if (layoutSizingVertical !== undefined) sizingMessages.push(`vertical: ${layoutSizingVertical}`);

      const sizingText = sizingMessages.length > 0
        ? `layout sizing (${sizingMessages.join(', ')})`
        : "layout sizing";

      return {
        content: [
          {
            type: "text",
            text: `Set ${sizingText} for frame "${typedResult.name}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting layout sizing: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Set Item Spacing Tool
server.tool(
  "set_item_spacing",
  "Set distance between children in an auto-layout frame",
  {
    nodeId: z.string().describe("The ID of the frame to modify"),
    itemSpacing: z.number().optional().describe("Distance between children. Note: This value will be ignored if primaryAxisAlignItems is set to SPACE_BETWEEN."),
    counterAxisSpacing: z.number().optional().describe("Distance between wrapped rows/columns. Only works when layoutWrap is set to WRAP.")
  },
  async ({ nodeId, itemSpacing, counterAxisSpacing}: any) => {
    try {
      const params: any = { nodeId };
      if (itemSpacing !== undefined) params.itemSpacing = itemSpacing;
      if (counterAxisSpacing !== undefined) params.counterAxisSpacing = counterAxisSpacing;
      
      const result = await sendCommandToFigma("set_item_spacing", params);
      const typedResult = result as { name: string, itemSpacing?: number, counterAxisSpacing?: number };

      let message = `Updated spacing for frame "${typedResult.name}":`;
      if (itemSpacing !== undefined) message += ` itemSpacing=${itemSpacing}`;
      if (counterAxisSpacing !== undefined) message += ` counterAxisSpacing=${counterAxisSpacing}`;

      return {
        content: [
          {
            type: "text",
            text: message,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting spacing: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// A tool to get Figma Prototyping Reactions from multiple nodes
server.tool(
  "get_reactions",
  "Get Figma Prototyping Reactions from multiple nodes. CRITICAL: The output MUST be processed using the 'reaction_to_connector_strategy' prompt IMMEDIATELY to generate parameters for connector lines via the 'create_connections' tool.",
  {
    nodeIds: z.array(z.string()).describe("Array of node IDs to get reactions from"),
  },
  async ({ nodeIds }: any) => {
    try {
      const result = await sendCommandToFigma("get_reactions", { nodeIds });
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result)
          },
          {
            type: "text",
            text: "IMPORTANT: You MUST now use the reaction data above and follow the `reaction_to_connector_strategy` prompt to prepare the parameters for the `create_connections` tool call. This is a required next step."
          }
        ],
        followUp: {
          type: "prompt",
          prompt: "reaction_to_connector_strategy",
        },
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error getting reactions: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Create Connectors Tool
server.tool(
  "set_default_connector",
  "Set a copied connector node as the default connector",
  {
    connectorId: z.string().optional().describe("The ID of the connector node to set as default")
  },
  async ({ connectorId }: any) => {
    try {
      const result = await sendCommandToFigma("set_default_connector", {
        connectorId
      });

      return {
        content: [
          {
            type: "text",
            text: `Default connector set: ${JSON.stringify(result)}`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting default connector: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Connect Nodes Tool
server.tool(
  "create_connections",
  "Create connections between nodes using the default connector style",
  {
    connections: z.array(z.object({
      startNodeId: z.string().describe("ID of the starting node"),
      endNodeId: z.string().describe("ID of the ending node"),
      text: z.string().optional().describe("Optional text to display on the connector")
    })).describe("Array of node connections to create")
  },
  async ({ connections }: any) => {
    try {
      if (!connections || connections.length === 0) {
        return {
          content: [
            {
              type: "text",
              text: "No connections provided"
            }
          ]
        };
      }

      const result = await sendCommandToFigma("create_connections", {
        connections
      });

      return {
        content: [
          {
            type: "text",
            text: `Created ${connections.length} connections: ${JSON.stringify(result)}`
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error creating connections: ${error instanceof Error ? error.message : String(error)}`
          }
        ]
      };
    }
  }
);

// Strategy for converting Figma prototype reactions to connector lines
server.prompt(
  "reaction_to_connector_strategy",
  "Strategy for converting Figma prototype reactions to connector lines using the output of 'get_reactions'",
  (extra) => {
    return {
      messages: [
        {
          role: "assistant",
          content: {
            type: "text",
            text: `# Strategy: Convert Figma Prototype Reactions to Connector Lines

## Goal
Process the JSON output from the \`get_reactions\` tool to generate an array of connection objects suitable for the \`create_connections\` tool. This visually represents prototype flows as connector lines on the Figma canvas.

## Input Data
You will receive JSON data from the \`get_reactions\` tool. This data contains an array of nodes, each with potential reactions. A typical reaction object looks like this:
\`\`\`json
{
  "trigger": { "type": "ON_CLICK" },
  "action": {
    "type": "NAVIGATE",
    "destinationId": "destination-node-id",
    "navigationTransition": { ... },
    "preserveScrollPosition": false
  }
}
\`\`\`

## Step-by-Step Process

### 1. Preparation & Context Gathering
   - **Action:** Call \`read_my_design\` on the relevant node(s) to get context about the nodes involved (names, types, etc.). This helps in generating meaningful connector labels later.
   - **Action:** Call \`set_default_connector\` **without** the \`connectorId\` parameter.
   - **Check Result:** Analyze the response from \`set_default_connector\`.
     - If it confirms a default connector is already set (e.g., "Default connector is already set"), proceed to Step 2.
     - If it indicates no default connector is set (e.g., "No default connector set..."), you **cannot** proceed with \`create_connections\` yet. Inform the user they need to manually copy a connector from FigJam, paste it onto the current page, select it, and then you can run \`set_default_connector({ connectorId: "SELECTED_NODE_ID" })\` before attempting \`create_connections\`. **Do not proceed to Step 2 until a default connector is confirmed.**

### 2. Filter and Transform Reactions from \`get_reactions\` Output
   - **Iterate:** Go through the JSON array provided by \`get_reactions\`. For each node in the array:
     - Iterate through its \`reactions\` array.
   - **Filter:** Keep only reactions where the \`action\` meets these criteria:
     - Has a \`type\` that implies a connection (e.g., \`NAVIGATE\`, \`OPEN_OVERLAY\`, \`SWAP_OVERLAY\`). **Ignore** types like \`CHANGE_TO\`, \`CLOSE_OVERLAY\`, etc.
     - Has a valid \`destinationId\` property.
   - **Extract:** For each valid reaction, extract the following information:
     - \`sourceNodeId\`: The ID of the node the reaction belongs to (from the outer loop).
     - \`destinationNodeId\`: The value of \`action.destinationId\`.
     - \`actionType\`: The value of \`action.type\`.
     - \`triggerType\`: The value of \`trigger.type\`.

### 3. Generate Connector Text Labels
   - **For each extracted connection:** Create a concise, descriptive text label string.
   - **Combine Information:** Use the \`actionType\`, \`triggerType\`, and potentially the names of the source/destination nodes (obtained from Step 1's \`read_my_design\` or by calling \`get_node_info\` if necessary) to generate the label.
   - **Example Labels:**
     - If \`triggerType\` is "ON\_CLICK" and \`actionType\` is "NAVIGATE": "On click, navigate to [Destination Node Name]"
     - If \`triggerType\` is "ON\_DRAG" and \`actionType\` is "OPEN\_OVERLAY": "On drag, open [Destination Node Name] overlay"
   - **Keep it brief and informative.** Let this generated string be \`generatedText\`.

### 4. Prepare the \`connections\` Array for \`create_connections\`
   - **Structure:** Create a JSON array where each element is an object representing a connection.
   - **Format:** Each object in the array must have the following structure:
     \`\`\`json
     {
       "startNodeId": "sourceNodeId_from_step_2",
       "endNodeId": "destinationNodeId_from_step_2",
       "text": "generatedText_from_step_3"
     }
     \`\`\`
   - **Result:** This final array is the value you will pass to the \`connections\` parameter when calling the \`create_connections\` tool.

### 5. Execute Connection Creation
   - **Action:** Call the \`create_connections\` tool, passing the array generated in Step 4 as the \`connections\` argument.
   - **Verify:** Check the response from \`create_connections\` to confirm success or failure.

This detailed process ensures you correctly interpret the reaction data, prepare the necessary information, and use the appropriate tools to create the connector lines.`
          },
        },
      ],
      description: "Strategy for converting Figma prototype reactions to connector lines using the output of 'get_reactions'",
    };
  }
);


// Define command types and parameters
type FigmaCommand =
  | "get_document_info"
  | "get_selection"
  | "get_node_info"
  | "get_nodes_info"
  | "read_my_design"
  | "create_rectangle"
  | "create_frame"
  | "create_text"
  | "set_fill_color"
  | "set_stroke_color"
  | "move_node"
  | "resize_node"
  | "delete_node"
  | "delete_multiple_nodes"
  | "get_styles"
  | "get_local_components"
  | "create_component_instance"
  | "get_component_property_references"
  | "set_instance_properties"
  | "get_instance_overrides"
  | "set_instance_overrides"
  | "export_node_as_image"
  | "join"
  | "set_corner_radius"
  | "clone_node"
  | "set_text_content"
  | "scan_text_nodes"
  | "set_multiple_text_contents"
  | "get_annotations"
  | "set_annotation"
  | "set_multiple_annotations"
  | "scan_nodes_by_types"
  | "set_layout_mode"
  | "set_padding"
  | "set_axis_align"
  | "set_layout_sizing"
  | "set_item_spacing"
  | "get_reactions"
  | "set_default_connector"
  | "create_connections"
  | "set_image_fill"
  | "set_text_auto_resize"
  | "append_card_to_container";

type CommandParams = {
  get_document_info: Record<string, never>;
  get_selection: Record<string, never>;
  get_node_info: { nodeId: string };
  get_nodes_info: { nodeIds: string[] };
  create_rectangle: {
    x: number;
    y: number;
    width: number;
    height: number;
    name?: string;
    parentId?: string;
  };
  create_frame: {
    x: number;
    y: number;
    width: number;
    height: number;
    name?: string;
    parentId?: string;
    fillColor?: { r: number; g: number; b: number; a?: number };
    strokeColor?: { r: number; g: number; b: number; a?: number };
    strokeWeight?: number;
  };
  create_text: {
    x: number;
    y: number;
    text: string;
    fontSize?: number;
    fontWeight?: number;
    fontColor?: { r: number; g: number; b: number; a?: number };
    name?: string;
    parentId?: string;
  };
  set_fill_color: {
    nodeId: string;
    r: number;
    g: number;
    b: number;
    a?: number;
  };
  set_stroke_color: {
    nodeId: string;
    r: number;
    g: number;
    b: number;
    a?: number;
    weight?: number;
  };
  move_node: {
    nodeId: string;
    x: number;
    y: number;
  };
  resize_node: {
    nodeId: string;
    width: number;
    height: number;
  };
  delete_node: {
    nodeId: string;
  };
  delete_multiple_nodes: {
    nodeIds: string[];
  };
  get_styles: Record<string, never>;
  get_local_components: Record<string, never>;
  get_team_components: Record<string, never>;
  create_component_instance: {
    componentKey?: string;
    componentId?: string;
    parentId?: string;
    x: number;
    y: number;
  };
  get_component_property_references: {
    nodeId: string;
  };
  set_instance_properties: {
    nodeId: string;
    properties: Record<string, boolean | string | number>;
  };
  set_instance_properties_by_base: {
    nodeId: string;
    properties: Record<string, boolean | string | number>;
  };
  get_instance_overrides: {
    instanceNodeId: string | null;
  };
  set_instance_overrides: {
    targetNodeIds: string[];
    sourceInstanceId: string;
  };
  export_node_as_image: {
    nodeId: string;
    format?: "PNG" | "JPG" | "SVG" | "PDF";
    scale?: number;
  };
  execute_code: {
    code: string;
  };
  join: {
    channel: string;
  };
  set_corner_radius: {
    nodeId: string;
    radius: number;
    corners?: boolean[];
  };
  clone_node: {
    nodeId: string;
    x?: number;
    y?: number;
  };
  set_text_content: {
    nodeId: string;
    text: string;
  };
  scan_text_nodes: {
    nodeId: string;
    useChunking: boolean;
    chunkSize: number;
  };
  set_multiple_text_contents: {
    nodeId: string;
    text: Array<{ nodeId: string; text: string }>;
  };
  get_annotations: {
    nodeId?: string;
    includeCategories?: boolean;
  };
  set_annotation: {
    nodeId: string;
    annotationId?: string;
    labelMarkdown: string;
    categoryId?: string;
    properties?: Array<{ type: string }>;
  };
  set_multiple_annotations: SetMultipleAnnotationsParams;
  scan_nodes_by_types: {
    nodeId: string;
    types: Array<string>;
  };
  get_reactions: { nodeIds: string[] };
  set_default_connector: {
    connectorId?: string | undefined;
  };
  create_connections: {
    connections: Array<{
      startNodeId: string;
      endNodeId: string;
      text?: string;
    }>;
  };
  set_image_fill: {
    nodeId: string;
    imageBase64?: string;
    imageUrl?: string;
    scaleMode?: 'FILL' | 'FIT';
    opacity?: number;
  };
  set_text_auto_resize: {
    nodeId: string;
    autoResize: 'NONE' | 'HEIGHT' | 'WIDTH_AND_HEIGHT';
  };
  append_card_to_container: {
    containerId: string;
    templateId: string;
    newName?: string;
    insertIndex?: number;
  };

};


// Helper function to process Figma node responses
function processFigmaNodeResponse(result: unknown): any {
  if (!result || typeof result !== "object") {
    return result;
  }

  // Check if this looks like a node response
  const resultObj = result as Record<string, unknown>;
  if ("id" in resultObj && typeof resultObj.id === "string") {
    // It appears to be a node response, log the details
    console.info(
      `Processed Figma node: ${resultObj.name || "Unknown"} (ID: ${resultObj.id
      })`
    );

    if ("x" in resultObj && "y" in resultObj) {
      console.debug(`Node position: (${resultObj.x}, ${resultObj.y})`);
    }

    if ("width" in resultObj && "height" in resultObj) {
      console.debug(`Node dimensions: ${resultObj.width}×${resultObj.height}`);
    }
  }

  return result;
}

// Update the connectToFigma function
function connectToFigma(port: number = 3055) {
  // If already connected, do nothing
  if (ws && ws.readyState === WebSocket.OPEN) {
    logger.info('Already connected to Figma');
    return;
  }

  const wsUrl = serverUrl.includes(':') ? `${WS_URL}://${serverUrl}` : `${WS_URL}://${serverUrl}:${port}`;
  logger.info(`Connecting to Figma socket server at ${wsUrl}...`);
  ws = new WebSocket(wsUrl);

  ws.on('open', () => {
    logger.info('Connected to Figma socket server');
    // Reset channel and reconnection state on successful connection
    currentChannel = null;
    reconnectAttempts = 0;
  });

  ws.on("message", (data: any) => {
    try {
      // Define a more specific type with an index signature to allow any property access
      interface ProgressMessage {
        message: FigmaResponse | any;
        type?: string;
        id?: string;
        [key: string]: any; // Allow any other properties
      }

      const json = JSON.parse(data) as ProgressMessage;

      // Handle progress updates
      if (json.type === 'progress_update') {
        const progressData = json.message.data as CommandProgressUpdate;
        const requestId = json.id || '';

        if (requestId && pendingRequests.has(requestId)) {
          const request = pendingRequests.get(requestId)!;

          // Update last activity timestamp
          request.lastActivity = Date.now();

          // Reset the timeout to prevent timeouts during long-running operations
          clearTimeout(request.timeout);

          // Create a new timeout
          request.timeout = setTimeout(() => {
            if (pendingRequests.has(requestId)) {
              logger.error(`Request ${requestId} timed out after extended period of inactivity`);
              pendingRequests.delete(requestId);
              request.reject(new Error('Request to Figma timed out'));
            }
          }, 60000); // 60 second timeout for inactivity

          // Log progress
          logger.info(`Progress update for ${progressData.commandType}: ${progressData.progress}% - ${progressData.message}`);

          // For completed updates, we could resolve the request early if desired
          if (progressData.status === 'completed' && progressData.progress === 100) {
            // Optionally resolve early with partial data
            // request.resolve(progressData.payload);
            // pendingRequests.delete(requestId);

            // Instead, just log the completion, wait for final result from Figma
            logger.info(`Operation ${progressData.commandType} completed, waiting for final result`);
          }
        }
        return;
      }

      // Handle regular responses
      const myResponse = json.message;
      logger.debug(`Received message: ${JSON.stringify(myResponse)}`);
      logger.log('myResponse' + JSON.stringify(myResponse));

      // Handle response to a request
      if (
        myResponse.id &&
        pendingRequests.has(myResponse.id) &&
        myResponse.result
      ) {
        const request = pendingRequests.get(myResponse.id)!;
        clearTimeout(request.timeout);

        if (myResponse.error) {
          logger.error(`Error from Figma: ${myResponse.error}`);
          request.reject(new Error(myResponse.error));
        } else {
          if (myResponse.result) {
            request.resolve(myResponse.result);
          }
        }

        pendingRequests.delete(myResponse.id);
      } else {
        // Handle broadcast messages or events
        logger.info(`Received broadcast message: ${JSON.stringify(myResponse)}`);
      }
    } catch (error) {
      logger.error(`Error parsing message: ${error instanceof Error ? error.message : String(error)}`);
    }
  });

  ws.on('error', (error) => {
    logger.error(`Socket error: ${error}`);
  });

  ws.on('close', () => {
    logger.info('Disconnected from Figma socket server');
    ws = null;

    // Reject all pending requests
    for (const [id, request] of pendingRequests.entries()) {
      clearTimeout(request.timeout);
      request.reject(new Error("Connection closed"));
      pendingRequests.delete(id);
    }

    // Attempt to reconnect with exponential backoff
    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
      const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
      reconnectAttempts++;
      logger.info(`Attempting to reconnect in ${delay/1000} seconds... (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
      setTimeout(() => connectToFigma(port), delay);
    } else {
      logger.error('Max reconnection attempts reached. Please check WebSocket server status.');
      // Reset attempts after a longer delay for potential retry
      setTimeout(() => { 
        reconnectAttempts = 0; 
        logger.info('Reconnection attempts reset. Will retry on next command.');
      }, 30000); // 30 seconds
    }
  });
}

// Function to join a channel
async function joinChannel(channelName: string): Promise<void> {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    throw new Error("Not connected to Figma");
  }

  try {
    await sendCommandToFigma("join", { channel: channelName });
    currentChannel = channelName;
    logger.info(`Joined channel: ${channelName}`);
  } catch (error) {
    logger.error(`Failed to join channel: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}

// Function to send commands to Figma
function sendCommandToFigma(
  command: FigmaCommand,
  params: unknown = {},
  timeoutMs: number = 30000
): Promise<unknown> {
  return new Promise((resolve, reject) => {
    // If not connected, try to connect first
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      connectToFigma();
      reject(new Error("Not connected to Figma. Attempting to connect..."));
      return;
    }

    // Check if we need a channel for this command
    const requiresChannel = command !== "join";
    if (requiresChannel && !currentChannel) {
      reject(new Error("Must join a channel before sending commands"));
      return;
    }

    const id = uuidv4();
    const request = {
      id,
      type: command === "join" ? "join" : "message",
      ...(command === "join"
        ? { channel: (params as any).channel }
        : { channel: currentChannel }),
      message: {
        id,
        command,
        params: {
          ...(params as any),
          commandId: id, // Include the command ID in params
        },
      },
    };

    // Set timeout for request
    const timeout = setTimeout(() => {
      if (pendingRequests.has(id)) {
        pendingRequests.delete(id);
        logger.error(`Request ${id} to Figma timed out after ${timeoutMs / 1000} seconds`);
        reject(new Error('Request to Figma timed out'));
      }
    }, timeoutMs);

    // Store the promise callbacks to resolve/reject later
    pendingRequests.set(id, {
      resolve,
      reject,
      timeout,
      lastActivity: Date.now()
    });

    // Send the request
    logger.info(`Sending command to Figma: ${command}`);
    logger.debug(`Request details: ${JSON.stringify(request)}`);
    ws.send(JSON.stringify(request));
  });
}

// Update the join_channel tool
server.tool(
  "join_channel",
  "Join a specific channel to communicate with Figma",
  {
    channel: z.string().describe("The name of the channel to join").default(""),
  },
  async ({ channel }: any) => {
    try {
      if (!channel) {
        // If no channel provided, ask the user for input
        return {
          content: [
            {
              type: "text",
              text: "Please provide a channel name to join:",
            },
          ],
          followUp: {
            tool: "join_channel",
            description: "Join the specified channel",
          },
        };
      }

      await joinChannel(channel);
      return {
        content: [
          {
            type: "text",
            text: `Successfully joined channel: ${channel}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error joining channel: ${error instanceof Error ? error.message : String(error)
              }`,
          },
        ],
      };
    }
  }
);

// Set Image Fill Tool
server.tool(
  "set_image_fill",
  "Fill a node with an image from Base64 data or URL",
  {
    nodeId: z.string().describe("The ID of the node to fill with image (must support fills)"),
    imageBase64: z.string().optional().describe("Base64 image data (supports data URL format or pure base64)"),
    imageUrl: z.string().optional().describe("URL to fetch image from (alternative to imageBase64)"),
    scaleMode: z.enum(['FILL', 'FIT']).optional().default('FILL').describe("Image scaling mode"),
    opacity: z.number().min(0).max(1).optional().default(1).describe("Image opacity (0-1)"),
  },
  async ({ nodeId, imageBase64, imageUrl, scaleMode, opacity }: any) => {
    // Validate that at least one image source is provided
    if (!imageBase64 && !imageUrl) {
      return {
        content: [
          {
            type: "text",
            text: "Error: Must provide either imageBase64 or imageUrl parameter"
          }
        ]
      };
    }
    
    // Fast path: if caller already provided base64, forward directly
    if (imageBase64 && !imageUrl) {
      try {
        const result = await sendCommandToFigma("set_image_fill", {
          nodeId,
          imageBase64,
          scaleMode: scaleMode || 'FILL',
          opacity: opacity ?? 1,
        });
        const typedResult = result as any;
        return {
          content: [{ type: "text", text: JSON.stringify(typedResult) }]
        };
      } catch (e) {
        return {
          content: [{ type: "text", text: `Error setting image fill (base64): ${e instanceof Error ? e.message : String(e)}` }]
        };
      }
    }

    // URL-first path with automatic Base64 fallback
    try {
      const result = await sendCommandToFigma("set_image_fill", {
        nodeId,
        imageUrl,
        scaleMode: scaleMode || 'FILL',
        opacity: opacity ?? 1,
      });
      const typedResult = result as any;
      return {
        content: [{ type: "text", text: JSON.stringify(typedResult) }]
      };
    } catch (error) {
      logger.warn(`URL image fetch failed, attempting Base64 fallback: ${error instanceof Error ? error.message : String(error)}`);

      // Try to resolve local file path from imageUrl
      if (!imageUrl) {
        return {
          content: [{ type: "text", text: `Error setting image fill: ${error instanceof Error ? error.message : String(error)}` }]
        };
      }

      const local = localPathFromAssetUrl(imageUrl);
      if (!local.ok || !local.path) {
        return {
          content: [{ type: "text", text: `Fallback unable to map URL to local path: ${local.reason || 'unknown reason'}` }]
        };
      }

      try {
        const stat = fs.statSync(local.path);
        const limitKB = Number((config?.asset_transfer?.base64_max_size ?? 10240));
        const sizeKB = Math.ceil(stat.size / 1024);
        if (sizeKB > limitKB) {
          return {
            content: [{ type: "text", text: `Fallback skipped: file too large (${sizeKB}KB > ${limitKB}KB)` }]
          };
        }

        const buf = fs.readFileSync(local.path);
        const b64 = buf.toString('base64');
        await throttleBase64Send();

        const result2 = await sendCommandToFigma("set_image_fill", {
          nodeId,
          imageBase64: b64,
          scaleMode: scaleMode || 'FILL',
          opacity: opacity ?? 1,
        });
        const typed2 = result2 as any;
        return {
          content: [{ type: "text", text: JSON.stringify(typed2) }]
        };
      } catch (e2) {
        return {
          content: [{ type: "text", text: `Fallback failed: ${e2 instanceof Error ? e2.message : String(e2)}` }]
        };
      }
    }
  }
);

// Set Text Auto Resize Tool
server.tool(
  "set_text_auto_resize",
  "Set text node auto-resize mode to prevent text truncation",
  {
    nodeId: z.string().describe("The ID of the text node to configure"),
    autoResize: z.enum(['NONE', 'HEIGHT', 'WIDTH_AND_HEIGHT']).describe("Text auto-resize mode"),
  },
  async ({ nodeId, autoResize }: any) => {
    try {
      const result = await sendCommandToFigma("set_text_auto_resize", {
        nodeId,
        autoResize,
      });
      const typedResult = result as { success: boolean; nodeName: string };
      return {
        content: [
          {
            type: "text",
            text: `Successfully set text auto-resize to "${autoResize}" for node "${typedResult.nodeName}"`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error setting text auto-resize: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Append Card to Container Tool
server.tool(
  "append_card_to_container",
  "Clone a template card and append it to an auto-layout container",
  {
    containerId: z.string().describe("The ID of the auto-layout container"),
    templateId: z.string().describe("The ID of the template card to clone"),
    newName: z.string().optional().describe("New name for the cloned card"),
    insertIndex: z.number().optional().describe("Insert position index (-1 for end)"),
  },
  async ({ containerId, templateId, newName, insertIndex }: any) => {
    try {
      const result = await sendCommandToFigma("append_card_to_container", {
        containerId,
        templateId,
        newName,
        insertIndex: insertIndex ?? -1,
      });
      const typedResult = result as {
        success: boolean;
        newNodeId: string;
        newNodeName: string;
        containerName: string;
        childrenCount: number;
      };
      return {
        content: [
          {
            type: "text",
            text: `Successfully appended card "${typedResult.newNodeName}" to container "${typedResult.containerName}". Container now has ${typedResult.childrenCount} children. New card ID: ${typedResult.newNodeId}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error appending card to container: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

// Start the server
async function main() {
  try {
    // Try to connect to Figma socket server
    connectToFigma();
  } catch (error) {
    logger.warn(`Could not connect to Figma initially: ${error instanceof Error ? error.message : String(error)}`);
    logger.warn('Will try to connect when the first command is sent');
  }

  // Start the MCP server with stdio transport
  const transport = new StdioServerTransport();
  await server.connect(transport);
  logger.info('FigmaMCP server running on stdio');
}

// Run the server
main().catch(error => {
  logger.error(`Error starting FigmaMCP server: ${error instanceof Error ? error.message : String(error)}`);
  process.exit(1);
});
</file>

<file path="src/cursor_mcp_plugin/code.js">
// This is the main code file for the Cursor MCP Figma plugin
// It handles Figma API commands

// Plugin state
const state = {
  serverPort: 3055, // Default port
  channel: null,
};


// Helper function for progress updates
function sendProgressUpdate(
  commandId,
  commandType,
  status,
  progress,
  totalItems,
  processedItems,
  message,
  payload = null
) {
  const update = {
    type: "command_progress",
    commandId,
    commandType,
    status,
    progress,
    totalItems,
    processedItems,
    message,
    timestamp: Date.now(),
  };

  // Add optional chunk information if present
  if (payload) {
    if (
      payload.currentChunk !== undefined &&
      payload.totalChunks !== undefined
    ) {
      update.currentChunk = payload.currentChunk;
      update.totalChunks = payload.totalChunks;
      update.chunkSize = payload.chunkSize;
    }
    update.payload = payload;
  }

  // Send to UI
  figma.ui.postMessage(update);
  console.log(`Progress update: ${status} - ${progress}% - ${message}`);

  return update;
}

// Show UI
figma.showUI(__html__, { width: 350, height: 450 });

// Plugin commands from UI
figma.ui.onmessage = async (msg) => {
  switch (msg.type) {
    case "update-settings":
      updateSettings(msg);
      break;
    case "notify":
      figma.notify(msg.message);
      break;
    case "close-plugin":
      figma.closePlugin();
      break;
    case "execute-command":
      // Execute commands received from UI (which gets them from WebSocket)
      try {
        const result = await handleCommand(msg.command, msg.params);
        // Send result back to UI
        figma.ui.postMessage({
          type: "command-result",
          id: msg.id,
          result,
        });
      } catch (error) {
        figma.ui.postMessage({
          type: "command-error",
          id: msg.id,
          error: error.message || "Error executing command",
        });
      }
      break;
  }
};

// Listen for plugin commands from menu
figma.on("run", ({ command }) => {
  figma.ui.postMessage({ type: "auto-connect" });
});

// Update plugin settings
function updateSettings(settings) {
  if (settings.serverPort) {
    state.serverPort = settings.serverPort;
  }
  if (settings.channel) {
    state.channel = settings.channel;
  }

  figma.clientStorage.setAsync("settings", {
    serverPort: state.serverPort,
    channel: state.channel,
  });
}

// Handle commands from UI
async function handleCommand(command, params) {
  switch (command) {
    case "get_document_info":
      return await getDocumentInfo();
    case "get_selection":
      return await getSelection();
    case "get_node_info":
      if (!params || !params.nodeId) {
        throw new Error("Missing nodeId parameter");
      }
      return await getNodeInfo(params.nodeId);
    case "get_nodes_info":
      if (!params || !params.nodeIds || !Array.isArray(params.nodeIds)) {
        throw new Error("Missing or invalid nodeIds parameter");
      }
      return await getNodesInfo(params.nodeIds);
    case "read_my_design":
      return await readMyDesign();
    case "create_rectangle":
      return await createRectangle(params);
    case "create_frame":
      return await createFrame(params);
    case "create_text":
      return await createText(params);
    case "set_fill_color":
      return await setFillColor(params);
    case "set_stroke_color":
      return await setStrokeColor(params);
    case "move_node":
      return await moveNode(params);
    case "resize_node":
      return await resizeNode(params);
    case "delete_node":
      return await deleteNode(params);
    case "delete_multiple_nodes":
      return await deleteMultipleNodes(params);
    case "get_styles":
      return await getStyles();
    case "get_local_components":
      return await getLocalComponents();
    // case "get_team_components":
    //   return await getTeamComponents();
    case "create_component_instance":
      return await createComponentInstance(params);
    case "export_node_as_image":
      return await exportNodeAsImage(params);
    case "set_corner_radius":
      return await setCornerRadius(params);
    case "set_text_content":
      return await setTextContent(params);
    case "clone_node":
      return await cloneNode(params);
    case "scan_text_nodes":
      return await scanTextNodes(params);
    case "set_multiple_text_contents":
      return await setMultipleTextContents(params);
    case "get_annotations":
      return await getAnnotations(params);
    case "set_annotation":
      return await setAnnotation(params);
    case "scan_nodes_by_types":
      return await scanNodesByTypes(params);
    case "set_multiple_annotations":
      return await setMultipleAnnotations(params);
    case "get_instance_overrides":
      // Check if instanceNode parameter is provided
      if (params && params.instanceNodeId) {
        // Get the instance node by ID
        const instanceNode = await figma.getNodeByIdAsync(params.instanceNodeId);
        if (!instanceNode) {
          throw new Error(`Instance node not found with ID: ${params.instanceNodeId}`);
        }
        return await getInstanceOverrides(instanceNode);
      }
      // Call without instance node if not provided
      return await getInstanceOverrides();

    case "get_component_property_references":
      return await getComponentPropertyReferences(params);
    
    case "set_instance_properties":
      return await setInstanceProperties(params);
    
    case "set_instance_properties_by_base":
      return await setInstancePropsByBase(params.nodeId, params.properties);
    
    case "set_instance_overrides":
      // Check if instanceNodeIds parameter is provided
      if (params && params.targetNodeIds) {
        // Validate that targetNodeIds is an array
        if (!Array.isArray(params.targetNodeIds)) {
          throw new Error("targetNodeIds must be an array");
        }

        // Get the instance nodes by IDs
        const targetNodes = await getValidTargetInstances(params.targetNodeIds);
        if (!targetNodes.success) {
          figma.notify(targetNodes.message);
          return { success: false, message: targetNodes.message };
        }

        if (params.sourceInstanceId) {

          // get source instance data
          let sourceInstanceData = null;
          sourceInstanceData = await getSourceInstanceData(params.sourceInstanceId);

          if (!sourceInstanceData.success) {
            figma.notify(sourceInstanceData.message);
            return { success: false, message: sourceInstanceData.message };
          }
          return await setInstanceOverrides(targetNodes.targetInstances, sourceInstanceData);
        } else {
          throw new Error("Missing sourceInstanceId parameter");
        }
      }
    case "set_layout_mode":
      return await setLayoutMode(params);
    case "set_padding":
      return await setPadding(params);
    case "set_axis_align":
      return await setAxisAlign(params);
    case "set_layout_sizing":
      return await setLayoutSizing(params);
    case "set_item_spacing":
      return await setItemSpacing(params);
    case "get_reactions":
      if (!params || !params.nodeIds || !Array.isArray(params.nodeIds)) {
        throw new Error("Missing or invalid nodeIds parameter");
      }
      return await getReactions(params.nodeIds);  
    case "set_default_connector":
      return await setDefaultConnector(params);
    case "create_connections":
      return await createConnections(params);
    case "set_image_fill":
      return await setImageFill(params);
    case "set_text_auto_resize":
      return await setTextAutoResize(params);
    case "append_card_to_container":
      return await appendCardToContainer(params);
    default:
      throw new Error(`Unknown command: ${command}`);
  }
}

// Command implementations

async function getDocumentInfo() {
  await figma.currentPage.loadAsync();
  const page = figma.currentPage;
  return {
    name: page.name,
    id: page.id,
    type: page.type,
    children: page.children.map((node) => ({
      id: node.id,
      name: node.name,
      type: node.type,
    })),
    currentPage: {
      id: page.id,
      name: page.name,
      childCount: page.children.length,
    },
    pages: [
      {
        id: page.id,
        name: page.name,
        childCount: page.children.length,
      },
    ],
  };
}

async function getSelection() {
  return {
    selectionCount: figma.currentPage.selection.length,
    selection: figma.currentPage.selection.map((node) => ({
      id: node.id,
      name: node.name,
      type: node.type,
      visible: node.visible,
    })),
  };
}

function rgbaToHex(color) {
  var r = Math.round(color.r * 255);
  var g = Math.round(color.g * 255);
  var b = Math.round(color.b * 255);
  var a = color.a !== undefined ? Math.round(color.a * 255) : 255;

  if (a === 255) {
    return (
      "#" +
      [r, g, b]
        .map((x) => {
          return x.toString(16).padStart(2, "0");
        })
        .join("")
    );
  }

  return (
    "#" +
    [r, g, b, a]
      .map((x) => {
        return x.toString(16).padStart(2, "0");
      })
      .join("")
  );
}

function filterFigmaNode(node) {
  if (node.type === "VECTOR") {
    return null;
  }

  var filtered = {
    id: node.id,
    name: node.name,
    type: node.type,
  };

  if (node.fills && node.fills.length > 0) {
    filtered.fills = node.fills.map((fill) => {
      var processedFill = Object.assign({}, fill);
      delete processedFill.boundVariables;
      delete processedFill.imageRef;

      if (processedFill.gradientStops) {
        processedFill.gradientStops = processedFill.gradientStops.map(
          (stop) => {
            var processedStop = Object.assign({}, stop);
            if (processedStop.color) {
              processedStop.color = rgbaToHex(processedStop.color);
            }
            delete processedStop.boundVariables;
            return processedStop;
          }
        );
      }

      if (processedFill.color) {
        processedFill.color = rgbaToHex(processedFill.color);
      }

      return processedFill;
    });
  }

  if (node.strokes && node.strokes.length > 0) {
    filtered.strokes = node.strokes.map((stroke) => {
      var processedStroke = Object.assign({}, stroke);
      delete processedStroke.boundVariables;
      if (processedStroke.color) {
        processedStroke.color = rgbaToHex(processedStroke.color);
      }
      return processedStroke;
    });
  }

  if (node.cornerRadius !== undefined) {
    filtered.cornerRadius = node.cornerRadius;
  }

  if (node.absoluteBoundingBox) {
    filtered.absoluteBoundingBox = node.absoluteBoundingBox;
  }

  if (node.characters) {
    filtered.characters = node.characters;
  }

  if (node.style) {
    filtered.style = {
      fontFamily: node.style.fontFamily,
      fontStyle: node.style.fontStyle,
      fontWeight: node.style.fontWeight,
      fontSize: node.style.fontSize,
      textAlignHorizontal: node.style.textAlignHorizontal,
      letterSpacing: node.style.letterSpacing,
      lineHeightPx: node.style.lineHeightPx,
    };
  }

  if (node.children) {
    filtered.children = node.children
      .map((child) => {
        return filterFigmaNode(child);
      })
      .filter((child) => {
        return child !== null;
      });
  }

  return filtered;
}

// Compute absolute bounding box from absoluteTransform + width/height
function getAbsoluteBoundingBox(node) {
  try {
    const t = node.absoluteTransform;
    const width = typeof node.width === 'number' ? node.width : 0;
    const height = typeof node.height === 'number' ? node.height : 0;
    if (t && Array.isArray(t) && t.length >= 2 && t[0].length >= 3) {
      const x = t[0][2];
      const y = t[1][2];
      return { x, y, width, height };
    }
  } catch (e) {}
  return undefined;
}

// Adapt filter to enrich with plugin-available fields when not present
const _origFilterFigmaNode = filterFigmaNode;
filterFigmaNode = function(node) {
  const filtered = _origFilterFigmaNode(node);
  if (!filtered) return filtered;

  // Add absoluteBoundingBox if missing and possible
  if (!filtered.absoluteBoundingBox && node && 'absoluteTransform' in node) {
    const bbox = getAbsoluteBoundingBox(node);
    if (bbox) filtered.absoluteBoundingBox = bbox;
  }

  // Add text style if TEXT node and style missing
  if (node && node.type === 'TEXT' && !filtered.style) {
    try {
      const fontName = node.fontName !== figma.mixed ? node.fontName : { family: 'Mixed', style: 'Mixed' };
      const lineHeightPx = node.lineHeight && node.lineHeight.unit === 'PIXELS' ? node.lineHeight.value : undefined;
      filtered.style = {
        fontFamily: fontName.family,
        fontStyle: fontName.style,
        fontWeight: node.fontWeight !== undefined ? node.fontWeight : undefined,
        fontSize: node.fontSize,
        textAlignHorizontal: node.textAlignHorizontal,
        letterSpacing: node.letterSpacing,
        lineHeightPx: lineHeightPx
      };
    } catch (e) {
      // best effort
    }
  }

  return filtered;
}

async function getNodeInfo(nodeId) {
  const node = await figma.getNodeByIdAsync(nodeId);

  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  // Traverse live node graph and build filtered JSON
  return filterFigmaNode(node);
}

async function getNodesInfo(nodeIds) {
  try {
    // Load all nodes in parallel
    const nodes = await Promise.all(
      nodeIds.map((id) => figma.getNodeByIdAsync(id))
    );

    // Filter out any null values (nodes that weren't found)
    const validNodes = nodes.filter((node) => node !== null);

    // Build filtered info for each
    const responses = validNodes.map((node) => ({
      nodeId: node.id,
      document: filterFigmaNode(node)
    }));

    return responses;
  } catch (error) {
    throw new Error(`Error getting nodes info: ${error.message}`);
  }
}

async function getReactions(nodeIds) {
  try {
    const commandId = generateCommandId();
    sendProgressUpdate(
      commandId,
      "get_reactions",
      "started",
      0,
      nodeIds.length,
      0,
      `Starting deep search for reactions in ${nodeIds.length} nodes and their children`
    );

    // Function to find nodes with reactions from the node and all its children
    async function findNodesWithReactions(node, processedNodes = new Set(), depth = 0, results = []) {
      // Skip already processed nodes (prevent circular references)
      if (processedNodes.has(node.id)) {
        return results;
      }
      
      processedNodes.add(node.id);
      
      // Check if the current node has reactions
      let filteredReactions = [];
      if (node.reactions && node.reactions.length > 0) {
        // Filter out reactions with navigation === 'CHANGE_TO'
        filteredReactions = node.reactions.filter(r => {
          // Some reactions may have action or actions array
          if (r.action && r.action.navigation === 'CHANGE_TO') return false;
          if (Array.isArray(r.actions)) {
            // If any action in actions array is CHANGE_TO, exclude
            return !r.actions.some(a => a.navigation === 'CHANGE_TO');
          }
          return true;
        });
      }
      const hasFilteredReactions = filteredReactions.length > 0;
      
      // If the node has filtered reactions, add it to results and apply highlight effect
      if (hasFilteredReactions) {
        results.push({
          id: node.id,
          name: node.name,
          type: node.type,
          depth: depth,
          hasReactions: true,
          reactions: filteredReactions,
          path: getNodePath(node)
        });
        // Apply highlight effect (orange border)
        await highlightNodeWithAnimation(node);
      }
      
      // If node has children, recursively search them
      if (node.children) {
        for (const child of node.children) {
          await findNodesWithReactions(child, processedNodes, depth + 1, results);
        }
      }
      
      return results;
    }
    
    // Function to apply animated highlight effect to a node
    async function highlightNodeWithAnimation(node) {
      // Save original stroke properties
      const originalStrokeWeight = node.strokeWeight;
      const originalStrokes = node.strokes ? [...node.strokes] : [];
      
      try {
        // Apply orange border stroke
        node.strokeWeight = 4;
        node.strokes = [{
          type: 'SOLID',
          color: { r: 1, g: 0.5, b: 0 }, // Orange color
          opacity: 0.8
        }];
        
        // Set timeout for animation effect (restore to original after 1.5 seconds)
        setTimeout(() => {
          try {
            // Restore original stroke properties
            node.strokeWeight = originalStrokeWeight;
            node.strokes = originalStrokes;
          } catch (restoreError) {
            console.error(`Error restoring node stroke: ${restoreError.message}`);
          }
        }, 1500);
      } catch (highlightError) {
        console.error(`Error highlighting node: ${highlightError.message}`);
        // Continue even if highlighting fails
      }
    }
    
    // Get node hierarchy path as a string
    function getNodePath(node) {
      const path = [];
      let current = node;
      
      while (current && current.parent) {
        path.unshift(current.name);
        current = current.parent;
      }
      
      return path.join(' > ');
    }

    // Array to store all results
    let allResults = [];
    let processedCount = 0;
    const totalCount = nodeIds.length;
    
    // Iterate through each node and its children to search for reactions
    for (let i = 0; i < nodeIds.length; i++) {
      try {
        const nodeId = nodeIds[i];
        const node = await figma.getNodeByIdAsync(nodeId);
        
        if (!node) {
          processedCount++;
          sendProgressUpdate(
            commandId,
            "get_reactions",
            "in_progress",
            processedCount / totalCount,
            totalCount,
            processedCount,
            `Node not found: ${nodeId}`
          );
          continue;
        }
        
        // Search for reactions in the node and its children
        const processedNodes = new Set();
        const nodeResults = await findNodesWithReactions(node, processedNodes);
        
        // Add results
        allResults = allResults.concat(nodeResults);
        
        // Update progress
        processedCount++;
        sendProgressUpdate(
          commandId,
          "get_reactions",
          "in_progress",
          processedCount / totalCount,
          totalCount,
          processedCount,
          `Processed node ${processedCount}/${totalCount}, found ${nodeResults.length} nodes with reactions`
        );
      } catch (error) {
        processedCount++;
        sendProgressUpdate(
          commandId,
          "get_reactions",
          "in_progress",
          processedCount / totalCount,
          totalCount,
          processedCount,
          `Error processing node: ${error.message}`
        );
      }
    }

    // Completion update
    sendProgressUpdate(
      commandId,
      "get_reactions",
      "completed",
      1,
      totalCount,
      totalCount,
      `Completed deep search: found ${allResults.length} nodes with reactions.`
    );

    return {
      nodesCount: nodeIds.length,
      nodesWithReactions: allResults.length,
      nodes: allResults
    };
  } catch (error) {
    throw new Error(`Failed to get reactions: ${error.message}`);
  }
}

async function readMyDesign() {
  try {
    const selection = figma.currentPage.selection || [];
    const responses = selection.map((node) => ({
      nodeId: node.id,
      document: filterFigmaNode(node)
    }));
    return responses;
  } catch (error) {
    throw new Error(`Error getting nodes info: ${error.message}`);
  }
}

async function createRectangle(params) {
  const {
    x = 0,
    y = 0,
    width = 100,
    height = 100,
    name = "Rectangle",
    parentId,
  } = params || {};

  const rect = figma.createRectangle();
  rect.x = x;
  rect.y = y;
  rect.resize(width, height);
  rect.name = name;

  // If parentId is provided, append to that node, otherwise append to current page
  if (parentId) {
    const parentNode = await figma.getNodeByIdAsync(parentId);
    if (!parentNode) {
      throw new Error(`Parent node not found with ID: ${parentId}`);
    }
    if (!("appendChild" in parentNode)) {
      throw new Error(`Parent node does not support children: ${parentId}`);
    }
    parentNode.appendChild(rect);
  } else {
    figma.currentPage.appendChild(rect);
  }

  return {
    id: rect.id,
    name: rect.name,
    x: rect.x,
    y: rect.y,
    width: rect.width,
    height: rect.height,
    parentId: rect.parent ? rect.parent.id : undefined,
  };
}

async function createFrame(params) {
  const {
    x = 0,
    y = 0,
    width = 100,
    height = 100,
    name = "Frame",
    parentId,
    fillColor,
    strokeColor,
    strokeWeight,
    layoutMode = "NONE",
    layoutWrap = "NO_WRAP",
    paddingTop = 10,
    paddingRight = 10,
    paddingBottom = 10,
    paddingLeft = 10,
    primaryAxisAlignItems = "MIN",
    counterAxisAlignItems = "MIN",
    layoutSizingHorizontal = "FIXED",
    layoutSizingVertical = "FIXED",
    itemSpacing = 0,
  } = params || {};

  const frame = figma.createFrame();
  frame.x = x;
  frame.y = y;
  frame.resize(width, height);
  frame.name = name;

  // Set layout mode if provided
  if (layoutMode !== "NONE") {
    frame.layoutMode = layoutMode;
    frame.layoutWrap = layoutWrap;

    // Set padding values only when layoutMode is not NONE
    frame.paddingTop = paddingTop;
    frame.paddingRight = paddingRight;
    frame.paddingBottom = paddingBottom;
    frame.paddingLeft = paddingLeft;

    // Set axis alignment only when layoutMode is not NONE
    frame.primaryAxisAlignItems = primaryAxisAlignItems;
    frame.counterAxisAlignItems = counterAxisAlignItems;

    // Set layout sizing only when layoutMode is not NONE
    frame.layoutSizingHorizontal = layoutSizingHorizontal;
    frame.layoutSizingVertical = layoutSizingVertical;

    // Set item spacing only when layoutMode is not NONE
    frame.itemSpacing = itemSpacing;
  }

  // Set fill color if provided
  if (fillColor) {
    const paintStyle = {
      type: "SOLID",
      color: {
        r: parseFloat(fillColor.r) || 0,
        g: parseFloat(fillColor.g) || 0,
        b: parseFloat(fillColor.b) || 0,
      },
      opacity: parseFloat(fillColor.a) || 1,
    };
    frame.fills = [paintStyle];
  }

  // Set stroke color and weight if provided
  if (strokeColor) {
    const strokeStyle = {
      type: "SOLID",
      color: {
        r: parseFloat(strokeColor.r) || 0,
        g: parseFloat(strokeColor.g) || 0,
        b: parseFloat(strokeColor.b) || 0,
      },
      opacity: parseFloat(strokeColor.a) || 1,
    };
    frame.strokes = [strokeStyle];
  }

  // Set stroke weight if provided
  if (strokeWeight !== undefined) {
    frame.strokeWeight = strokeWeight;
  }

  // If parentId is provided, append to that node, otherwise append to current page
  if (parentId) {
    const parentNode = await figma.getNodeByIdAsync(parentId);
    if (!parentNode) {
      throw new Error(`Parent node not found with ID: ${parentId}`);
    }
    if (!("appendChild" in parentNode)) {
      throw new Error(`Parent node does not support children: ${parentId}`);
    }
    parentNode.appendChild(frame);
  } else {
    figma.currentPage.appendChild(frame);
  }

  return {
    id: frame.id,
    name: frame.name,
    x: frame.x,
    y: frame.y,
    width: frame.width,
    height: frame.height,
    fills: frame.fills,
    strokes: frame.strokes,
    strokeWeight: frame.strokeWeight,
    layoutMode: frame.layoutMode,
    layoutWrap: frame.layoutWrap,
    parentId: frame.parent ? frame.parent.id : undefined,
  };
}

async function createText(params) {
  const {
    x = 0,
    y = 0,
    text = "Text",
    fontSize = 14,
    fontWeight = 400,
    fontColor = { r: 0, g: 0, b: 0, a: 1 }, // Default to black
    name = "",
    parentId,
  } = params || {};

  // Map common font weights to Figma font styles
  const getFontStyle = (weight) => {
    switch (weight) {
      case 100:
        return "Thin";
      case 200:
        return "Extra Light";
      case 300:
        return "Light";
      case 400:
        return "Regular";
      case 500:
        return "Medium";
      case 600:
        return "Semi Bold";
      case 700:
        return "Bold";
      case 800:
        return "Extra Bold";
      case 900:
        return "Black";
      default:
        return "Regular";
    }
  };

  const textNode = figma.createText();
  textNode.x = x;
  textNode.y = y;
  textNode.name = name || text;
  try {
    await figma.loadFontAsync({
      family: "Inter",
      style: getFontStyle(fontWeight),
    });
    textNode.fontName = { family: "Inter", style: getFontStyle(fontWeight) };
    textNode.fontSize = parseInt(fontSize);
  } catch (error) {
    console.error("Error setting font size", error);
  }
  setCharacters(textNode, text);

  // Set text color
  const paintStyle = {
    type: "SOLID",
    color: {
      r: parseFloat(fontColor.r) || 0,
      g: parseFloat(fontColor.g) || 0,
      b: parseFloat(fontColor.b) || 0,
    },
    opacity: parseFloat(fontColor.a) || 1,
  };
  textNode.fills = [paintStyle];

  // If parentId is provided, append to that node, otherwise append to current page
  if (parentId) {
    const parentNode = await figma.getNodeByIdAsync(parentId);
    if (!parentNode) {
      throw new Error(`Parent node not found with ID: ${parentId}`);
    }
    if (!("appendChild" in parentNode)) {
      throw new Error(`Parent node does not support children: ${parentId}`);
    }
    parentNode.appendChild(textNode);
  } else {
    figma.currentPage.appendChild(textNode);
  }

  return {
    id: textNode.id,
    name: textNode.name,
    x: textNode.x,
    y: textNode.y,
    width: textNode.width,
    height: textNode.height,
    characters: textNode.characters,
    fontSize: textNode.fontSize,
    fontWeight: fontWeight,
    fontColor: fontColor,
    fontName: textNode.fontName,
    fills: textNode.fills,
    parentId: textNode.parent ? textNode.parent.id : undefined,
  };
}

async function setFillColor(params) {
  console.log("setFillColor", params);
  const {
    nodeId,
    color: { r, g, b, a },
  } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (!("fills" in node)) {
    throw new Error(`Node does not support fills: ${nodeId}`);
  }

  // Create RGBA color
  const rgbColor = {
    r: parseFloat(r) || 0,
    g: parseFloat(g) || 0,
    b: parseFloat(b) || 0,
    a: parseFloat(a) || 1,
  };

  // Set fill
  const paintStyle = {
    type: "SOLID",
    color: {
      r: parseFloat(rgbColor.r),
      g: parseFloat(rgbColor.g),
      b: parseFloat(rgbColor.b),
    },
    opacity: parseFloat(rgbColor.a),
  };

  console.log("paintStyle", paintStyle);

  node.fills = [paintStyle];

  return {
    id: node.id,
    name: node.name,
    fills: [paintStyle],
  };
}

async function setStrokeColor(params) {
  const {
    nodeId,
    color: { r, g, b, a },
    weight = 1,
  } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (!("strokes" in node)) {
    throw new Error(`Node does not support strokes: ${nodeId}`);
  }

  // Create RGBA color
  const rgbColor = {
    r: r !== undefined ? r : 0,
    g: g !== undefined ? g : 0,
    b: b !== undefined ? b : 0,
    a: a !== undefined ? a : 1,
  };

  // Set stroke
  const paintStyle = {
    type: "SOLID",
    color: {
      r: rgbColor.r,
      g: rgbColor.g,
      b: rgbColor.b,
    },
    opacity: rgbColor.a,
  };

  node.strokes = [paintStyle];

  // Set stroke weight if available
  if ("strokeWeight" in node) {
    node.strokeWeight = weight;
  }

  return {
    id: node.id,
    name: node.name,
    strokes: node.strokes,
    strokeWeight: "strokeWeight" in node ? node.strokeWeight : undefined,
  };
}

async function moveNode(params) {
  const { nodeId, x, y } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  if (x === undefined || y === undefined) {
    throw new Error("Missing x or y parameters");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (!("x" in node) || !("y" in node)) {
    throw new Error(`Node does not support position: ${nodeId}`);
  }

  node.x = x;
  node.y = y;

  return {
    id: node.id,
    name: node.name,
    x: node.x,
    y: node.y,
  };
}

async function resizeNode(params) {
  const { nodeId, width, height } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  if (width === undefined || height === undefined) {
    throw new Error("Missing width or height parameters");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (!("resize" in node)) {
    throw new Error(`Node does not support resizing: ${nodeId}`);
  }

  node.resize(width, height);

  return {
    id: node.id,
    name: node.name,
    width: node.width,
    height: node.height,
  };
}

async function deleteNode(params) {
  const { nodeId } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  // Save node info before deleting
  const nodeInfo = {
    id: node.id,
    name: node.name,
    type: node.type,
  };

  node.remove();

  return nodeInfo;
}

async function getStyles() {
  const styles = {
    colors: await figma.getLocalPaintStylesAsync(),
    texts: await figma.getLocalTextStylesAsync(),
    effects: await figma.getLocalEffectStylesAsync(),
    grids: await figma.getLocalGridStylesAsync(),
  };

  return {
    colors: styles.colors.map((style) => ({
      id: style.id,
      name: style.name,
      key: style.key,
      paint: style.paints[0],
    })),
    texts: styles.texts.map((style) => ({
      id: style.id,
      name: style.name,
      key: style.key,
      fontSize: style.fontSize,
      fontName: style.fontName,
    })),
    effects: styles.effects.map((style) => ({
      id: style.id,
      name: style.name,
      key: style.key,
    })),
    grids: styles.grids.map((style) => ({
      id: style.id,
      name: style.name,
      key: style.key,
    })),
  };
}

async function getLocalComponents() {
  await figma.loadAllPagesAsync();

  const components = figma.root.findAllWithCriteria({
    types: ["COMPONENT"],
  });

  return {
    count: components.length,
    components: components.map((component) => ({
      id: component.id,
      name: component.name,
      key: "key" in component ? component.key : null,
    })),
  };
}

// async function getTeamComponents() {
//   try {
//     const teamComponents =
//       await figma.teamLibrary.getAvailableComponentsAsync();

//     return {
//       count: teamComponents.length,
//       components: teamComponents.map((component) => ({
//         key: component.key,
//         name: component.name,
//         description: component.description,
//         libraryName: component.libraryName,
//       })),
//     };
//   } catch (error) {
//     throw new Error(`Error getting team components: ${error.message}`);
//   }
// }


async function exportNodeAsImage(params) {
  const { nodeId, scale = 1 } = params || {};

  const format = "PNG";

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (!("exportAsync" in node)) {
    throw new Error(`Node does not support exporting: ${nodeId}`);
  }

  try {
    const settings = {
      format: format,
      constraint: { type: "SCALE", value: scale },
    };

    const bytes = await node.exportAsync(settings);

    let mimeType;
    switch (format) {
      case "PNG":
        mimeType = "image/png";
        break;
      case "JPG":
        mimeType = "image/jpeg";
        break;
      case "SVG":
        mimeType = "image/svg+xml";
        break;
      case "PDF":
        mimeType = "application/pdf";
        break;
      default:
        mimeType = "application/octet-stream";
    }

    // Proper way to convert Uint8Array to base64
    const base64 = customBase64Encode(bytes);
    // const imageData = `data:${mimeType};base64,${base64}`;

    return {
      nodeId,
      format,
      scale,
      mimeType,
      imageData: base64,
    };
  } catch (error) {
    throw new Error(`Error exporting node as image: ${error.message}`);
  }
}
function customBase64Encode(bytes) {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  let base64 = "";

  const byteLength = bytes.byteLength;
  const byteRemainder = byteLength % 3;
  const mainLength = byteLength - byteRemainder;

  let a, b, c, d;
  let chunk;

  // Main loop deals with bytes in chunks of 3
  for (let i = 0; i < mainLength; i = i + 3) {
    // Combine the three bytes into a single integer
    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

    // Use bitmasks to extract 6-bit segments from the triplet
    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
    b = (chunk & 258048) >> 12; // 258048 = (2^6 - 1) << 12
    c = (chunk & 4032) >> 6; // 4032 = (2^6 - 1) << 6
    d = chunk & 63; // 63 = 2^6 - 1

    // Convert the raw binary segments to the appropriate ASCII encoding
    base64 += chars[a] + chars[b] + chars[c] + chars[d];
  }

  // Deal with the remaining bytes and padding
  if (byteRemainder === 1) {
    chunk = bytes[mainLength];

    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

    // Set the 4 least significant bits to zero
    b = (chunk & 3) << 4; // 3 = 2^2 - 1

    base64 += chars[a] + chars[b] + "==";
  } else if (byteRemainder === 2) {
    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
    b = (chunk & 1008) >> 4; // 1008 = (2^6 - 1) << 4

    // Set the 2 least significant bits to zero
    c = (chunk & 15) << 2; // 15 = 2^4 - 1

    base64 += chars[a] + chars[b] + chars[c] + "=";
  }

  return base64;
}

function customBase64Decode(base64String) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  
  // Remove padding characters and whitespace
  let cleanBase64 = base64String.replace(/[=\s]/g, '');
  
  // Create lookup table
  const lookup = {};
  for (let i = 0; i < chars.length; i++) {
    lookup[chars[i]] = i;
  }
  
  const length = cleanBase64.length;
  
  // Calculate exact buffer size accounting for padding
  let bufferSize;
  const remainder = length % 4;
  if (remainder === 0) {
    bufferSize = (length * 3) / 4;
  } else if (remainder === 2) {
    bufferSize = ((length - 2) * 3) / 4 + 1;
  } else if (remainder === 3) {
    bufferSize = ((length - 3) * 3) / 4 + 2;
  } else {
    throw new Error('Invalid base64 length');
  }
  
  let bytes = new Uint8Array(Math.floor(bufferSize));
  let byteIndex = 0;
  
  // Process 4 characters at a time
  for (let i = 0; i < length; i += 4) {
    const c1 = lookup[cleanBase64[i]];
    const c2 = lookup[cleanBase64[i + 1]];
    const c3 = lookup[cleanBase64[i + 2]];
    const c4 = lookup[cleanBase64[i + 3]];
    
    // Validate characters
    if (c1 === undefined || c2 === undefined) {
      throw new Error('Invalid base64 characters');
    }
    
    const combined = (c1 << 18) | (c2 << 12) | ((c3 || 0) << 6) | (c4 || 0);
    
    // Always write first byte
    if (byteIndex < bytes.length) {
      bytes[byteIndex++] = (combined >>> 16) & 0xFF;
    }
    
    // Write second byte if we have at least 3rd character or enough remaining input
    if ((i + 2 < length || remainder >= 3) && byteIndex < bytes.length) {
      bytes[byteIndex++] = (combined >>> 8) & 0xFF;
    }
    
    // Write third byte if we have 4th character or enough remaining input  
    if ((i + 3 < length || remainder === 0) && byteIndex < bytes.length) {
      bytes[byteIndex++] = combined & 0xFF;
    }
  }
  
  return bytes.slice(0, byteIndex);
}

async function setCornerRadius(params) {
  const { nodeId, radius, corners } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  if (radius === undefined) {
    throw new Error("Missing radius parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  // Check if node supports corner radius
  if (!("cornerRadius" in node)) {
    throw new Error(`Node does not support corner radius: ${nodeId}`);
  }

  // If corners array is provided, set individual corner radii
  if (corners && Array.isArray(corners) && corners.length === 4) {
    if ("topLeftRadius" in node) {
      // Node supports individual corner radii
      if (corners[0]) node.topLeftRadius = radius;
      if (corners[1]) node.topRightRadius = radius;
      if (corners[2]) node.bottomRightRadius = radius;
      if (corners[3]) node.bottomLeftRadius = radius;
    } else {
      // Node only supports uniform corner radius
      node.cornerRadius = radius;
    }
  } else {
    // Set uniform corner radius
    node.cornerRadius = radius;
  }

  return {
    id: node.id,
    name: node.name,
    cornerRadius: "cornerRadius" in node ? node.cornerRadius : undefined,
    topLeftRadius: "topLeftRadius" in node ? node.topLeftRadius : undefined,
    topRightRadius: "topRightRadius" in node ? node.topRightRadius : undefined,
    bottomRightRadius:
      "bottomRightRadius" in node ? node.bottomRightRadius : undefined,
    bottomLeftRadius:
      "bottomLeftRadius" in node ? node.bottomLeftRadius : undefined,
  };
}

async function setTextContent(params) {
  const { nodeId, text } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  if (text === undefined) {
    throw new Error("Missing text parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (node.type !== "TEXT") {
    throw new Error(`Node is not a text node: ${nodeId}`);
  }

  try {
    await figma.loadFontAsync(node.fontName);

    await setCharacters(node, text);

    return {
      id: node.id,
      name: node.name,
      characters: node.characters,
      fontName: node.fontName,
    };
  } catch (error) {
    throw new Error(`Error setting text content: ${error.message}`);
  }
}

// Initialize settings on load
(async function initializePlugin() {
  try {
    const savedSettings = await figma.clientStorage.getAsync("settings");
    if (savedSettings) {
      if (savedSettings.serverPort) {
        state.serverPort = savedSettings.serverPort;
      }
      if (savedSettings.channel) {
        state.channel = savedSettings.channel;
      }
    }

    // Send initial settings to UI
    figma.ui.postMessage({
      type: "init-settings",
      settings: {
        serverPort: state.serverPort,
        channel: state.channel,
      },
    });
  } catch (error) {
    console.error("Error loading settings:", error);
  }
})();

function uniqBy(arr, predicate) {
  const cb = typeof predicate === "function" ? predicate : (o) => o[predicate];
  return [
    ...arr
      .reduce((map, item) => {
        const key = item === null || item === undefined ? item : cb(item);

        map.has(key) || map.set(key, item);

        return map;
      }, new Map())
      .values(),
  ];
}
const setCharacters = async (node, characters, options) => {
  const fallbackFont = (options && options.fallbackFont) || {
    family: "Inter",
    style: "Regular",
  };
  try {
    if (node.fontName === figma.mixed) {
      if (options && options.smartStrategy === "prevail") {
        const fontHashTree = {};
        for (let i = 1; i < node.characters.length; i++) {
          const charFont = node.getRangeFontName(i - 1, i);
          const key = `${charFont.family}::${charFont.style}`;
          fontHashTree[key] = fontHashTree[key] ? fontHashTree[key] + 1 : 1;
        }
        const prevailedTreeItem = Object.entries(fontHashTree).sort(
          (a, b) => b[1] - a[1]
        )[0];
        const [family, style] = prevailedTreeItem[0].split("::");
        const prevailedFont = {
          family,
          style,
        };
        await figma.loadFontAsync(prevailedFont);
        node.fontName = prevailedFont;
      } else if (options && options.smartStrategy === "strict") {
        return setCharactersWithStrictMatchFont(node, characters, fallbackFont);
      } else if (options && options.smartStrategy === "experimental") {
        return setCharactersWithSmartMatchFont(node, characters, fallbackFont);
      } else {
        const firstCharFont = node.getRangeFontName(0, 1);
        await figma.loadFontAsync(firstCharFont);
        node.fontName = firstCharFont;
      }
    } else {
      await figma.loadFontAsync({
        family: node.fontName.family,
        style: node.fontName.style,
      });
    }
  } catch (err) {
    console.warn(
      `Failed to load "${node.fontName["family"]} ${node.fontName["style"]}" font and replaced with fallback "${fallbackFont.family} ${fallbackFont.style}"`,
      err
    );
    await figma.loadFontAsync(fallbackFont);
    node.fontName = fallbackFont;
  }
  try {
    node.characters = characters;
    return true;
  } catch (err) {
    console.warn(`Failed to set characters. Skipped.`, err);
    return false;
  }
};

const setCharactersWithStrictMatchFont = async (
  node,
  characters,
  fallbackFont
) => {
  const fontHashTree = {};
  for (let i = 1; i < node.characters.length; i++) {
    const startIdx = i - 1;
    const startCharFont = node.getRangeFontName(startIdx, i);
    const startCharFontVal = `${startCharFont.family}::${startCharFont.style}`;
    while (i < node.characters.length) {
      i++;
      const charFont = node.getRangeFontName(i - 1, i);
      if (startCharFontVal !== `${charFont.family}::${charFont.style}`) {
        break;
      }
    }
    fontHashTree[`${startIdx}_${i}`] = startCharFontVal;
  }
  await figma.loadFontAsync(fallbackFont);
  node.fontName = fallbackFont;
  node.characters = characters;
  console.log(fontHashTree);
  await Promise.all(
    Object.keys(fontHashTree).map(async (range) => {
      console.log(range, fontHashTree[range]);
      const [start, end] = range.split("_");
      const [family, style] = fontHashTree[range].split("::");
      const matchedFont = {
        family,
        style,
      };
      await figma.loadFontAsync(matchedFont);
      return node.setRangeFontName(Number(start), Number(end), matchedFont);
    })
  );
  return true;
};

const getDelimiterPos = (str, delimiter, startIdx = 0, endIdx = str.length) => {
  const indices = [];
  let temp = startIdx;
  for (let i = startIdx; i < endIdx; i++) {
    if (
      str[i] === delimiter &&
      i + startIdx !== endIdx &&
      temp !== i + startIdx
    ) {
      indices.push([temp, i + startIdx]);
      temp = i + startIdx + 1;
    }
  }
  temp !== endIdx && indices.push([temp, endIdx]);
  return indices.filter(Boolean);
};

const buildLinearOrder = (node) => {
  const fontTree = [];
  const newLinesPos = getDelimiterPos(node.characters, "\n");
  newLinesPos.forEach(([newLinesRangeStart, newLinesRangeEnd], n) => {
    const newLinesRangeFont = node.getRangeFontName(
      newLinesRangeStart,
      newLinesRangeEnd
    );
    if (newLinesRangeFont === figma.mixed) {
      const spacesPos = getDelimiterPos(
        node.characters,
        " ",
        newLinesRangeStart,
        newLinesRangeEnd
      );
      spacesPos.forEach(([spacesRangeStart, spacesRangeEnd], s) => {
        const spacesRangeFont = node.getRangeFontName(
          spacesRangeStart,
          spacesRangeEnd
        );
        if (spacesRangeFont === figma.mixed) {
          const spacesRangeFont = node.getRangeFontName(
            spacesRangeStart,
            spacesRangeStart[0]
          );
          fontTree.push({
            start: spacesRangeStart,
            delimiter: " ",
            family: spacesRangeFont.family,
            style: spacesRangeFont.style,
          });
        } else {
          fontTree.push({
            start: spacesRangeStart,
            delimiter: " ",
            family: spacesRangeFont.family,
            style: spacesRangeFont.style,
          });
        }
      });
    } else {
      fontTree.push({
        start: newLinesRangeStart,
        delimiter: "\n",
        family: newLinesRangeFont.family,
        style: newLinesRangeFont.style,
      });
    }
  });
  return fontTree
    .sort((a, b) => +a.start - +b.start)
    .map(({ family, style, delimiter }) => ({ family, style, delimiter }));
};

const setCharactersWithSmartMatchFont = async (
  node,
  characters,
  fallbackFont
) => {
  const rangeTree = buildLinearOrder(node);
  const fontsToLoad = uniqBy(
    rangeTree,
    ({ family, style }) => `${family}::${style}`
  ).map(({ family, style }) => ({
    family,
    style,
  }));

  await Promise.all([...fontsToLoad, fallbackFont].map(figma.loadFontAsync));

  node.fontName = fallbackFont;
  node.characters = characters;

  let prevPos = 0;
  rangeTree.forEach(({ family, style, delimiter }) => {
    if (prevPos < node.characters.length) {
      const delimeterPos = node.characters.indexOf(delimiter, prevPos);
      const endPos =
        delimeterPos > prevPos ? delimeterPos : node.characters.length;
      const matchedFont = {
        family,
        style,
      };
      node.setRangeFontName(prevPos, endPos, matchedFont);
      prevPos = endPos + 1;
    }
  });
  return true;
};

// Add the cloneNode function implementation
async function cloneNode(params) {
  const { nodeId, x, y } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  // Clone the node
  const clone = node.clone();

  // If x and y are provided, move the clone to that position
  if (x !== undefined && y !== undefined) {
    if (!("x" in clone) || !("y" in clone)) {
      throw new Error(`Cloned node does not support position: ${nodeId}`);
    }
    clone.x = x;
    clone.y = y;
  }

  // Add the clone to the same parent as the original node
  if (node.parent) {
    node.parent.appendChild(clone);
  } else {
    figma.currentPage.appendChild(clone);
  }

  return {
    id: clone.id,
    name: clone.name,
    x: "x" in clone ? clone.x : undefined,
    y: "y" in clone ? clone.y : undefined,
    width: "width" in clone ? clone.width : undefined,
    height: "height" in clone ? clone.height : undefined,
  };
}

async function scanTextNodes(params) {
  console.log(`Starting to scan text nodes from node ID: ${params.nodeId}`);
  const {
    nodeId,
    useChunking = true,
    chunkSize = 10,
    commandId = generateCommandId(),
  } = params || {};

  const node = await figma.getNodeByIdAsync(nodeId);

  if (!node) {
    console.error(`Node with ID ${nodeId} not found`);
    // Send error progress update
    sendProgressUpdate(
      commandId,
      "scan_text_nodes",
      "error",
      0,
      0,
      0,
      `Node with ID ${nodeId} not found`,
      { error: `Node not found: ${nodeId}` }
    );
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // If chunking is not enabled, use the original implementation
  if (!useChunking) {
    const textNodes = [];
    try {
      // Send started progress update
      sendProgressUpdate(
        commandId,
        "scan_text_nodes",
        "started",
        0,
        1, // Not known yet how many nodes there are
        0,
        `Starting scan of node "${node.name || nodeId}" without chunking`,
        null
      );

      await findTextNodes(node, [], 0, textNodes);

      // Send completed progress update
      sendProgressUpdate(
        commandId,
        "scan_text_nodes",
        "completed",
        100,
        textNodes.length,
        textNodes.length,
        `Scan complete. Found ${textNodes.length} text nodes.`,
        { textNodes }
      );

      return {
        success: true,
        message: `Scanned ${textNodes.length} text nodes.`,
        count: textNodes.length,
        textNodes: textNodes,
        commandId,
      };
    } catch (error) {
      console.error("Error scanning text nodes:", error);

      // Send error progress update
      sendProgressUpdate(
        commandId,
        "scan_text_nodes",
        "error",
        0,
        0,
        0,
        `Error scanning text nodes: ${error.message}`,
        { error: error.message }
      );

      throw new Error(`Error scanning text nodes: ${error.message}`);
    }
  }

  // Chunked implementation
  console.log(`Using chunked scanning with chunk size: ${chunkSize}`);

  // First, collect all nodes to process (without processing them yet)
  const nodesToProcess = [];

  // Send started progress update
  sendProgressUpdate(
    commandId,
    "scan_text_nodes",
    "started",
    0,
    0, // Not known yet how many nodes there are
    0,
    `Starting chunked scan of node "${node.name || nodeId}"`,
    { chunkSize }
  );

  await collectNodesToProcess(node, [], 0, nodesToProcess);

  const totalNodes = nodesToProcess.length;
  console.log(`Found ${totalNodes} total nodes to process`);

  // Calculate number of chunks needed
  const totalChunks = Math.ceil(totalNodes / chunkSize);
  console.log(`Will process in ${totalChunks} chunks`);

  // Send update after node collection
  sendProgressUpdate(
    commandId,
    "scan_text_nodes",
    "in_progress",
    5, // 5% progress for collection phase
    totalNodes,
    0,
    `Found ${totalNodes} nodes to scan. Will process in ${totalChunks} chunks.`,
    {
      totalNodes,
      totalChunks,
      chunkSize,
    }
  );

  // Process nodes in chunks
  const allTextNodes = [];
  let processedNodes = 0;
  let chunksProcessed = 0;

  for (let i = 0; i < totalNodes; i += chunkSize) {
    const chunkEnd = Math.min(i + chunkSize, totalNodes);
    console.log(
      `Processing chunk ${chunksProcessed + 1}/${totalChunks} (nodes ${i} to ${chunkEnd - 1
      })`
    );

    // Send update before processing chunk
    sendProgressUpdate(
      commandId,
      "scan_text_nodes",
      "in_progress",
      Math.round(5 + (chunksProcessed / totalChunks) * 90), // 5-95% for processing
      totalNodes,
      processedNodes,
      `Processing chunk ${chunksProcessed + 1}/${totalChunks}`,
      {
        currentChunk: chunksProcessed + 1,
        totalChunks,
        textNodesFound: allTextNodes.length,
      }
    );

    const chunkNodes = nodesToProcess.slice(i, chunkEnd);
    const chunkTextNodes = [];

    // Process each node in this chunk
    for (const nodeInfo of chunkNodes) {
      if (nodeInfo.node.type === "TEXT") {
        try {
          const textNodeInfo = await processTextNode(
            nodeInfo.node,
            nodeInfo.parentPath,
            nodeInfo.depth
          );
          if (textNodeInfo) {
            chunkTextNodes.push(textNodeInfo);
          }
        } catch (error) {
          console.error(`Error processing text node: ${error.message}`);
          // Continue with other nodes
        }
      }

      // Brief delay to allow UI updates and prevent freezing
      await delay(5);
    }

    // Add results from this chunk
    allTextNodes.push(...chunkTextNodes);
    processedNodes += chunkNodes.length;
    chunksProcessed++;

    // Send update after processing chunk
    sendProgressUpdate(
      commandId,
      "scan_text_nodes",
      "in_progress",
      Math.round(5 + (chunksProcessed / totalChunks) * 90), // 5-95% for processing
      totalNodes,
      processedNodes,
      `Processed chunk ${chunksProcessed}/${totalChunks}. Found ${allTextNodes.length} text nodes so far.`,
      {
        currentChunk: chunksProcessed,
        totalChunks,
        processedNodes,
        textNodesFound: allTextNodes.length,
        chunkResult: chunkTextNodes,
      }
    );

    // Small delay between chunks to prevent UI freezing
    if (i + chunkSize < totalNodes) {
      await delay(50);
    }
  }

  // Send completed progress update
  sendProgressUpdate(
    commandId,
    "scan_text_nodes",
    "completed",
    100,
    totalNodes,
    processedNodes,
    `Scan complete. Found ${allTextNodes.length} text nodes.`,
    {
      textNodes: allTextNodes,
      processedNodes,
      chunks: chunksProcessed,
    }
  );

  return {
    success: true,
    message: `Chunked scan complete. Found ${allTextNodes.length} text nodes.`,
    totalNodes: allTextNodes.length,
    processedNodes: processedNodes,
    chunks: chunksProcessed,
    textNodes: allTextNodes,
    commandId,
  };
}

// Helper function to collect all nodes that need to be processed
async function collectNodesToProcess(
  node,
  parentPath = [],
  depth = 0,
  nodesToProcess = []
) {
  // Skip invisible nodes
  if (node.visible === false) return;

  // Get the path to this node
  const nodePath = [...parentPath, node.name || `Unnamed ${node.type}`];

  // Add this node to the processing list
  nodesToProcess.push({
    node: node,
    parentPath: nodePath,
    depth: depth,
  });

  // Recursively add children
  if ("children" in node) {
    for (const child of node.children) {
      await collectNodesToProcess(child, nodePath, depth + 1, nodesToProcess);
    }
  }
}

// Process a single text node
async function processTextNode(node, parentPath, depth) {
  if (node.type !== "TEXT") return null;

  try {
    // Safely extract font information
    let fontFamily = "";
    let fontStyle = "";

    if (node.fontName) {
      if (typeof node.fontName === "object") {
        if ("family" in node.fontName) fontFamily = node.fontName.family;
        if ("style" in node.fontName) fontStyle = node.fontName.style;
      }
    }

    // Create a safe representation of the text node
    const safeTextNode = {
      id: node.id,
      name: node.name || "Text",
      type: node.type,
      characters: node.characters,
      fontSize: typeof node.fontSize === "number" ? node.fontSize : 0,
      fontFamily: fontFamily,
      fontStyle: fontStyle,
      x: typeof node.x === "number" ? node.x : 0,
      y: typeof node.y === "number" ? node.y : 0,
      width: typeof node.width === "number" ? node.width : 0,
      height: typeof node.height === "number" ? node.height : 0,
      path: parentPath.join(" > "),
      depth: depth,
    };

    // Highlight the node briefly (optional visual feedback)
    try {
      const originalFills = JSON.parse(JSON.stringify(node.fills));
      node.fills = [
        {
          type: "SOLID",
          color: { r: 1, g: 0.5, b: 0 },
          opacity: 0.3,
        },
      ];

      // Brief delay for the highlight to be visible
      await delay(100);

      try {
        node.fills = originalFills;
      } catch (err) {
        console.error("Error resetting fills:", err);
      }
    } catch (highlightErr) {
      console.error("Error highlighting text node:", highlightErr);
      // Continue anyway, highlighting is just visual feedback
    }

    return safeTextNode;
  } catch (nodeErr) {
    console.error("Error processing text node:", nodeErr);
    return null;
  }
}

// A delay function that returns a promise
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Keep the original findTextNodes for backward compatibility
async function findTextNodes(node, parentPath = [], depth = 0, textNodes = []) {
  // Skip invisible nodes
  if (node.visible === false) return;

  // Get the path to this node including its name
  const nodePath = [...parentPath, node.name || `Unnamed ${node.type}`];

  if (node.type === "TEXT") {
    try {
      // Safely extract font information to avoid Symbol serialization issues
      let fontFamily = "";
      let fontStyle = "";

      if (node.fontName) {
        if (typeof node.fontName === "object") {
          if ("family" in node.fontName) fontFamily = node.fontName.family;
          if ("style" in node.fontName) fontStyle = node.fontName.style;
        }
      }

      // Create a safe representation of the text node with only serializable properties
      const safeTextNode = {
        id: node.id,
        name: node.name || "Text",
        type: node.type,
        characters: node.characters,
        fontSize: typeof node.fontSize === "number" ? node.fontSize : 0,
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        x: typeof node.x === "number" ? node.x : 0,
        y: typeof node.y === "number" ? node.y : 0,
        width: typeof node.width === "number" ? node.width : 0,
        height: typeof node.height === "number" ? node.height : 0,
        path: nodePath.join(" > "),
        depth: depth,
      };

      // Only highlight the node if it's not being done via API
      try {
        // Safe way to create a temporary highlight without causing serialization issues
        const originalFills = JSON.parse(JSON.stringify(node.fills));
        node.fills = [
          {
            type: "SOLID",
            color: { r: 1, g: 0.5, b: 0 },
            opacity: 0.3,
          },
        ];

        // Promise-based delay instead of setTimeout
        await delay(500);

        try {
          node.fills = originalFills;
        } catch (err) {
          console.error("Error resetting fills:", err);
        }
      } catch (highlightErr) {
        console.error("Error highlighting text node:", highlightErr);
        // Continue anyway, highlighting is just visual feedback
      }

      textNodes.push(safeTextNode);
    } catch (nodeErr) {
      console.error("Error processing text node:", nodeErr);
      // Skip this node but continue with others
    }
  }

  // Recursively process children of container nodes
  if ("children" in node) {
    for (const child of node.children) {
      await findTextNodes(child, nodePath, depth + 1, textNodes);
    }
  }
}

// Replace text in a specific node
async function setMultipleTextContents(params) {
  const { nodeId, text } = params || {};
  const commandId = params.commandId || generateCommandId();

  if (!nodeId || !text || !Array.isArray(text)) {
    const errorMsg = "Missing required parameters: nodeId and text array";

    // Send error progress update
    sendProgressUpdate(
      commandId,
      "set_multiple_text_contents",
      "error",
      0,
      0,
      0,
      errorMsg,
      { error: errorMsg }
    );

    throw new Error(errorMsg);
  }

  console.log(
    `Starting text replacement for node: ${nodeId} with ${text.length} text replacements`
  );

  // Send started progress update
  sendProgressUpdate(
    commandId,
    "set_multiple_text_contents",
    "started",
    0,
    text.length,
    0,
    `Starting text replacement for ${text.length} nodes`,
    { totalReplacements: text.length }
  );

  // Define the results array and counters
  const results = [];
  let successCount = 0;
  let failureCount = 0;

  // Split text replacements into chunks of 5
  const CHUNK_SIZE = 5;
  const chunks = [];

  for (let i = 0; i < text.length; i += CHUNK_SIZE) {
    chunks.push(text.slice(i, i + CHUNK_SIZE));
  }

  console.log(`Split ${text.length} replacements into ${chunks.length} chunks`);

  // Send chunking info update
  sendProgressUpdate(
    commandId,
    "set_multiple_text_contents",
    "in_progress",
    5, // 5% progress for planning phase
    text.length,
    0,
    `Preparing to replace text in ${text.length} nodes using ${chunks.length} chunks`,
    {
      totalReplacements: text.length,
      chunks: chunks.length,
      chunkSize: CHUNK_SIZE,
    }
  );

  // Process each chunk sequentially
  for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
    const chunk = chunks[chunkIndex];
    console.log(
      `Processing chunk ${chunkIndex + 1}/${chunks.length} with ${chunk.length
      } replacements`
    );

    // Send chunk processing start update
    sendProgressUpdate(
      commandId,
      "set_multiple_text_contents",
      "in_progress",
      Math.round(5 + (chunkIndex / chunks.length) * 90), // 5-95% for processing
      text.length,
      successCount + failureCount,
      `Processing text replacements chunk ${chunkIndex + 1}/${chunks.length}`,
      {
        currentChunk: chunkIndex + 1,
        totalChunks: chunks.length,
        successCount,
        failureCount,
      }
    );

    // Process replacements within a chunk in parallel
    const chunkPromises = chunk.map(async (replacement) => {
      if (!replacement.nodeId || replacement.text === undefined) {
        console.error(`Missing nodeId or text for replacement`);
        return {
          success: false,
          nodeId: replacement.nodeId || "unknown",
          error: "Missing nodeId or text in replacement entry",
        };
      }

      try {
        console.log(
          `Attempting to replace text in node: ${replacement.nodeId}`
        );

        // Get the text node to update (just to check it exists and get original text)
        const textNode = await figma.getNodeByIdAsync(replacement.nodeId);

        if (!textNode) {
          console.error(`Text node not found: ${replacement.nodeId}`);
          return {
            success: false,
            nodeId: replacement.nodeId,
            error: `Node not found: ${replacement.nodeId}`,
          };
        }

        if (textNode.type !== "TEXT") {
          console.error(
            `Node is not a text node: ${replacement.nodeId} (type: ${textNode.type})`
          );
          return {
            success: false,
            nodeId: replacement.nodeId,
            error: `Node is not a text node: ${replacement.nodeId} (type: ${textNode.type})`,
          };
        }

        // Save original text for the result
        const originalText = textNode.characters;
        console.log(`Original text: "${originalText}"`);
        console.log(`Will translate to: "${replacement.text}"`);

        // Highlight the node before changing text
        let originalFills;
        try {
          // Save original fills for restoration later
          originalFills = JSON.parse(JSON.stringify(textNode.fills));
          // Apply highlight color (orange with 30% opacity)
          textNode.fills = [
            {
              type: "SOLID",
              color: { r: 1, g: 0.5, b: 0 },
              opacity: 0.3,
            },
          ];
        } catch (highlightErr) {
          console.error(
            `Error highlighting text node: ${highlightErr.message}`
          );
          // Continue anyway, highlighting is just visual feedback
        }

        // Use the existing setTextContent function to handle font loading and text setting
        await setTextContent({
          nodeId: replacement.nodeId,
          text: replacement.text,
        });

        // Keep highlight for a moment after text change, then restore original fills
        if (originalFills) {
          try {
            // Use delay function for consistent timing
            await delay(500);
            textNode.fills = originalFills;
          } catch (restoreErr) {
            console.error(`Error restoring fills: ${restoreErr.message}`);
          }
        }

        console.log(
          `Successfully replaced text in node: ${replacement.nodeId}`
        );
        return {
          success: true,
          nodeId: replacement.nodeId,
          originalText: originalText,
          translatedText: replacement.text,
        };
      } catch (error) {
        console.error(
          `Error replacing text in node ${replacement.nodeId}: ${error.message}`
        );
        return {
          success: false,
          nodeId: replacement.nodeId,
          error: `Error applying replacement: ${error.message}`,
        };
      }
    });

    // Wait for all replacements in this chunk to complete
    const chunkResults = await Promise.all(chunkPromises);

    // Process results for this chunk
    chunkResults.forEach((result) => {
      if (result.success) {
        successCount++;
      } else {
        failureCount++;
      }
      results.push(result);
    });

    // Send chunk processing complete update with partial results
    sendProgressUpdate(
      commandId,
      "set_multiple_text_contents",
      "in_progress",
      Math.round(5 + ((chunkIndex + 1) / chunks.length) * 90), // 5-95% for processing
      text.length,
      successCount + failureCount,
      `Completed chunk ${chunkIndex + 1}/${chunks.length
      }. ${successCount} successful, ${failureCount} failed so far.`,
      {
        currentChunk: chunkIndex + 1,
        totalChunks: chunks.length,
        successCount,
        failureCount,
        chunkResults: chunkResults,
      }
    );

    // Add a small delay between chunks to avoid overloading Figma
    if (chunkIndex < chunks.length - 1) {
      console.log("Pausing between chunks to avoid overloading Figma...");
      await delay(1000); // 1 second delay between chunks
    }
  }

  console.log(
    `Replacement complete: ${successCount} successful, ${failureCount} failed`
  );

  // Send completed progress update
  sendProgressUpdate(
    commandId,
    "set_multiple_text_contents",
    "completed",
    100,
    text.length,
    successCount + failureCount,
    `Text replacement complete: ${successCount} successful, ${failureCount} failed`,
    {
      totalReplacements: text.length,
      replacementsApplied: successCount,
      replacementsFailed: failureCount,
      completedInChunks: chunks.length,
      results: results,
    }
  );

  return {
    success: successCount > 0,
    nodeId: nodeId,
    replacementsApplied: successCount,
    replacementsFailed: failureCount,
    totalReplacements: text.length,
    results: results,
    completedInChunks: chunks.length,
    commandId,
  };
}

// Function to generate simple UUIDs for command IDs
function generateCommandId() {
  return (
    "cmd_" +
    Math.random().toString(36).substring(2, 15) +
    Math.random().toString(36).substring(2, 15)
  );
}

async function getAnnotations(params) {
  try {
    const { nodeId, includeCategories = true } = params;

    // Get categories first if needed
    let categoriesMap = {};
    if (includeCategories) {
      const categories = await figma.annotations.getAnnotationCategoriesAsync();
      categoriesMap = categories.reduce((map, category) => {
        map[category.id] = {
          id: category.id,
          label: category.label,
          color: category.color,
          isPreset: category.isPreset,
        };
        return map;
      }, {});
    }

    if (nodeId) {
      // Get annotations for a specific node
      const node = await figma.getNodeByIdAsync(nodeId);
      if (!node) {
        throw new Error(`Node not found: ${nodeId}`);
      }

      if (!("annotations" in node)) {
        throw new Error(`Node type ${node.type} does not support annotations`);
      }

      // Collect annotations from this node and all its descendants
      const mergedAnnotations = [];
      const collect = async (n) => {
        if ("annotations" in n && n.annotations && n.annotations.length > 0) {
          for (const a of n.annotations) {
            mergedAnnotations.push({ nodeId: n.id, annotation: a });
          }
        }
        if ("children" in n) {
          for (const child of n.children) {
            await collect(child);
          }
        }
      };
      await collect(node);

      const result = {
        nodeId: node.id,
        name: node.name,
        annotations: mergedAnnotations,
      };

      if (includeCategories) {
        result.categories = Object.values(categoriesMap);
      }

      return result;
    } else {
      // Get all annotations in the current page
      const annotations = [];
      const processNode = async (node) => {
        if (
          "annotations" in node &&
          node.annotations &&
          node.annotations.length > 0
        ) {
          annotations.push({
            nodeId: node.id,
            name: node.name,
            annotations: node.annotations,
          });
        }
        if ("children" in node) {
          for (const child of node.children) {
            await processNode(child);
          }
        }
      };

      // Start from current page
      await processNode(figma.currentPage);

      const result = {
        annotatedNodes: annotations,
      };

      if (includeCategories) {
        result.categories = Object.values(categoriesMap);
      }

      return result;
    }
  } catch (error) {
    console.error("Error in getAnnotations:", error);
    throw error;
  }
}

async function setAnnotation(params) {
  try {
    console.log("=== setAnnotation Debug Start ===");
    console.log("Input params:", JSON.stringify(params, null, 2));

    const { nodeId, annotationId, labelMarkdown, categoryId, properties } =
      params;

    // Validate required parameters
    if (!nodeId) {
      console.error("Validation failed: Missing nodeId");
      return { success: false, error: "Missing nodeId" };
    }

    if (!labelMarkdown) {
      console.error("Validation failed: Missing labelMarkdown");
      return { success: false, error: "Missing labelMarkdown" };
    }

    console.log("Attempting to get node:", nodeId);
    // Get and validate node
    const node = await figma.getNodeByIdAsync(nodeId);
    console.log("Node lookup result:", {
      id: nodeId,
      found: !!node,
      type: node ? node.type : undefined,
      name: node ? node.name : undefined,
      hasAnnotations: node ? "annotations" in node : false,
    });

    if (!node) {
      console.error("Node lookup failed:", nodeId);
      return { success: false, error: `Node not found: ${nodeId}` };
    }

    // Validate node supports annotations
    if (!("annotations" in node)) {
      console.error("Node annotation support check failed:", {
        nodeType: node.type,
        nodeId: node.id,
      });
      return {
        success: false,
        error: `Node type ${node.type} does not support annotations`,
      };
    }

    // Create the annotation object
    const newAnnotation = {
      labelMarkdown,
    };

    // Validate and add categoryId if provided
    if (categoryId) {
      console.log("Adding categoryId to annotation:", categoryId);
      newAnnotation.categoryId = categoryId;
    }

    // Validate and add properties if provided
    if (properties && Array.isArray(properties) && properties.length > 0) {
      console.log(
        "Adding properties to annotation:",
        JSON.stringify(properties, null, 2)
      );
      newAnnotation.properties = properties;
    }

    // Log current annotations before update
    console.log("Current node annotations:", node.annotations);

    // Overwrite annotations
    console.log(
      "Setting new annotation:",
      JSON.stringify(newAnnotation, null, 2)
    );
    node.annotations = [newAnnotation];

    // Verify the update
    console.log("Updated node annotations:", node.annotations);
    console.log("=== setAnnotation Debug End ===");

    return {
      success: true,
      nodeId: node.id,
      name: node.name,
      annotations: node.annotations,
    };
  } catch (error) {
    console.error("=== setAnnotation Error ===");
    console.error("Error details:", {
      message: error.message,
      stack: error.stack,
      params: JSON.stringify(params, null, 2),
    });
    return { success: false, error: error.message };
  }
}

/**
 * Scan for nodes with specific types within a node
 * @param {Object} params - Parameters object
 * @param {string} params.nodeId - ID of the node to scan within
 * @param {Array<string>} params.types - Array of node types to find (e.g. ['COMPONENT', 'FRAME'])
 * @returns {Object} - Object containing found nodes
 */
async function scanNodesByTypes(params) {
  console.log(`Starting to scan nodes by types from node ID: ${params.nodeId}`);
  const { nodeId, types = [] } = params || {};

  if (!types || types.length === 0) {
    throw new Error("No types specified to search for");
  }

  const node = await figma.getNodeByIdAsync(nodeId);

  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Simple implementation without chunking
  const matchingNodes = [];

  // Send a single progress update to notify start
  const commandId = generateCommandId();
  sendProgressUpdate(
    commandId,
    "scan_nodes_by_types",
    "started",
    0,
    1,
    0,
    `Starting scan of node "${node.name || nodeId}" for types: ${types.join(
      ", "
    )}`,
    null
  );

  // Recursively find nodes with specified types
  await findNodesByTypes(node, types, matchingNodes);

  // Send completion update
  sendProgressUpdate(
    commandId,
    "scan_nodes_by_types",
    "completed",
    100,
    matchingNodes.length,
    matchingNodes.length,
    `Scan complete. Found ${matchingNodes.length} matching nodes.`,
    { matchingNodes }
  );

  return {
    success: true,
    message: `Found ${matchingNodes.length} matching nodes.`,
    count: matchingNodes.length,
    matchingNodes: matchingNodes,
    searchedTypes: types,
  };
}

/**
 * Helper function to recursively find nodes with specific types
 * @param {SceneNode} node - The root node to start searching from
 * @param {Array<string>} types - Array of node types to find
 * @param {Array} matchingNodes - Array to store found nodes
 */
async function findNodesByTypes(node, types, matchingNodes = []) {
  // Skip invisible nodes
  if (node.visible === false) return;

  // Check if this node is one of the specified types
  if (types.includes(node.type)) {
    // Create a minimal representation with just ID, type and bbox
    matchingNodes.push({
      id: node.id,
      name: node.name || `Unnamed ${node.type}`,
      type: node.type,
      // Basic bounding box info
      bbox: {
        x: typeof node.x === "number" ? node.x : 0,
        y: typeof node.y === "number" ? node.y : 0,
        width: typeof node.width === "number" ? node.width : 0,
        height: typeof node.height === "number" ? node.height : 0,
      },
    });
  }

  // Recursively process children of container nodes
  if ("children" in node) {
    for (const child of node.children) {
      await findNodesByTypes(child, types, matchingNodes);
    }
  }
}

// Set multiple annotations with async progress updates
async function setMultipleAnnotations(params) {
  console.log("=== setMultipleAnnotations Debug Start ===");
  console.log("Input params:", JSON.stringify(params, null, 2));

  const { nodeId, annotations } = params;

  if (!annotations || annotations.length === 0) {
    console.error("Validation failed: No annotations provided");
    return { success: false, error: "No annotations provided" };
  }

  console.log(
    `Processing ${annotations.length} annotations for node ${nodeId}`
  );

  const results = [];
  let successCount = 0;
  let failureCount = 0;

  // Process annotations sequentially
  for (let i = 0; i < annotations.length; i++) {
    const annotation = annotations[i];
    console.log(
      `\nProcessing annotation ${i + 1}/${annotations.length}:`,
      JSON.stringify(annotation, null, 2)
    );

    try {
      console.log("Calling setAnnotation with params:", {
        nodeId: annotation.nodeId,
        labelMarkdown: annotation.labelMarkdown,
        categoryId: annotation.categoryId,
        properties: annotation.properties,
      });

      const result = await setAnnotation({
        nodeId: annotation.nodeId,
        labelMarkdown: annotation.labelMarkdown,
        categoryId: annotation.categoryId,
        properties: annotation.properties,
      });

      console.log("setAnnotation result:", JSON.stringify(result, null, 2));

      if (result.success) {
        successCount++;
        results.push({ success: true, nodeId: annotation.nodeId });
        console.log(`✓ Annotation ${i + 1} applied successfully`);
      } else {
        failureCount++;
        results.push({
          success: false,
          nodeId: annotation.nodeId,
          error: result.error,
        });
        console.error(`✗ Annotation ${i + 1} failed:`, result.error);
      }
    } catch (error) {
      failureCount++;
      const errorResult = {
        success: false,
        nodeId: annotation.nodeId,
        error: error.message,
      };
      results.push(errorResult);
      console.error(`✗ Annotation ${i + 1} failed with error:`, error);
      console.error("Error details:", {
        message: error.message,
        stack: error.stack,
      });
    }
  }

  const summary = {
    success: successCount > 0,
    annotationsApplied: successCount,
    annotationsFailed: failureCount,
    totalAnnotations: annotations.length,
    results: results,
  };

  console.log("\n=== setMultipleAnnotations Summary ===");
  console.log(JSON.stringify(summary, null, 2));
  console.log("=== setMultipleAnnotations Debug End ===");

  return summary;
}

async function deleteMultipleNodes(params) {
  const { nodeIds } = params || {};
  const commandId = generateCommandId();

  if (!nodeIds || !Array.isArray(nodeIds) || nodeIds.length === 0) {
    const errorMsg = "Missing or invalid nodeIds parameter";
    sendProgressUpdate(
      commandId,
      "delete_multiple_nodes",
      "error",
      0,
      0,
      0,
      errorMsg,
      { error: errorMsg }
    );
    throw new Error(errorMsg);
  }

  console.log(`Starting deletion of ${nodeIds.length} nodes`);

  // Send started progress update
  sendProgressUpdate(
    commandId,
    "delete_multiple_nodes",
    "started",
    0,
    nodeIds.length,
    0,
    `Starting deletion of ${nodeIds.length} nodes`,
    { totalNodes: nodeIds.length }
  );

  const results = [];
  let successCount = 0;
  let failureCount = 0;

  // Process nodes in chunks of 5 to avoid overwhelming Figma
  const CHUNK_SIZE = 5;
  const chunks = [];

  for (let i = 0; i < nodeIds.length; i += CHUNK_SIZE) {
    chunks.push(nodeIds.slice(i, i + CHUNK_SIZE));
  }

  console.log(`Split ${nodeIds.length} deletions into ${chunks.length} chunks`);

  // Send chunking info update
  sendProgressUpdate(
    commandId,
    "delete_multiple_nodes",
    "in_progress",
    5,
    nodeIds.length,
    0,
    `Preparing to delete ${nodeIds.length} nodes using ${chunks.length} chunks`,
    {
      totalNodes: nodeIds.length,
      chunks: chunks.length,
      chunkSize: CHUNK_SIZE,
    }
  );

  // Process each chunk sequentially
  for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
    const chunk = chunks[chunkIndex];
    console.log(
      `Processing chunk ${chunkIndex + 1}/${chunks.length} with ${chunk.length
      } nodes`
    );

    // Send chunk processing start update
    sendProgressUpdate(
      commandId,
      "delete_multiple_nodes",
      "in_progress",
      Math.round(5 + (chunkIndex / chunks.length) * 90),
      nodeIds.length,
      successCount + failureCount,
      `Processing deletion chunk ${chunkIndex + 1}/${chunks.length}`,
      {
        currentChunk: chunkIndex + 1,
        totalChunks: chunks.length,
        successCount,
        failureCount,
      }
    );

    // Process deletions within a chunk in parallel
    const chunkPromises = chunk.map(async (nodeId) => {
      try {
        const node = await figma.getNodeByIdAsync(nodeId);

        if (!node) {
          console.error(`Node not found: ${nodeId}`);
          return {
            success: false,
            nodeId: nodeId,
            error: `Node not found: ${nodeId}`,
          };
        }

        // Save node info before deleting
        const nodeInfo = {
          id: node.id,
          name: node.name,
          type: node.type,
        };

        // Delete the node
        node.remove();

        console.log(`Successfully deleted node: ${nodeId}`);
        return {
          success: true,
          nodeId: nodeId,
          nodeInfo: nodeInfo,
        };
      } catch (error) {
        console.error(`Error deleting node ${nodeId}: ${error.message}`);
        return {
          success: false,
          nodeId: nodeId,
          error: error.message,
        };
      }
    });

    // Wait for all deletions in this chunk to complete
    const chunkResults = await Promise.all(chunkPromises);

    // Process results for this chunk
    chunkResults.forEach((result) => {
      if (result.success) {
        successCount++;
      } else {
        failureCount++;
      }
      results.push(result);
    });

    // Send chunk processing complete update
    sendProgressUpdate(
      commandId,
      "delete_multiple_nodes",
      "in_progress",
      Math.round(5 + ((chunkIndex + 1) / chunks.length) * 90),
      nodeIds.length,
      successCount + failureCount,
      `Completed chunk ${chunkIndex + 1}/${chunks.length
      }. ${successCount} successful, ${failureCount} failed so far.`,
      {
        currentChunk: chunkIndex + 1,
        totalChunks: chunks.length,
        successCount,
        failureCount,
        chunkResults: chunkResults,
      }
    );

    // Add a small delay between chunks
    if (chunkIndex < chunks.length - 1) {
      console.log("Pausing between chunks...");
      await delay(1000);
    }
  }

  console.log(
    `Deletion complete: ${successCount} successful, ${failureCount} failed`
  );

  // Send completed progress update
  sendProgressUpdate(
    commandId,
    "delete_multiple_nodes",
    "completed",
    100,
    nodeIds.length,
    successCount + failureCount,
    `Node deletion complete: ${successCount} successful, ${failureCount} failed`,
    {
      totalNodes: nodeIds.length,
      nodesDeleted: successCount,
      nodesFailed: failureCount,
      completedInChunks: chunks.length,
      results: results,
    }
  );

  return {
    success: successCount > 0,
    nodesDeleted: successCount,
    nodesFailed: failureCount,
    totalNodes: nodeIds.length,
    results: results,
    completedInChunks: chunks.length,
    commandId,
  };
}

// PropertyName#ID adaptation layer - converts base names to full PropertyName#ID
function buildPropertyKeyMap(instance) {
  console.log("=== Building PropertyName#ID map ===");
  const map = {};
  
  if (!instance.componentProperties) {
    console.log("No componentProperties available");
    return map;
  }
  
  // Map base names to PropertyName#ID format
  for (const fullKey of Object.keys(instance.componentProperties)) {
    const baseName = fullKey.split('#')[0];  // 'showTitle#I194:57:showTitle' → 'showTitle'
    map[baseName] = fullKey;
    console.log(`Mapped: ${baseName} → ${fullKey}`);
  }
  
  return map;
}

// Enhanced setProperties using base names (showTitle, showImg2, etc.)
async function setInstancePropsByBase(instanceId, propsByBase) {
  console.log("=== setInstancePropsByBase called ===");
  console.log("Base properties:", JSON.stringify(propsByBase, null, 2));
  
  try {
    const node = await figma.getNodeByIdAsync(instanceId);
    if (!node) {
      return { success: false, message: `Node not found: ${instanceId}` };
    }
    
    if (node.type !== "INSTANCE") {
      return { success: false, message: `Node is not an instance: ${node.type}` };
    }
    
    // Build property key map
    const keyMap = buildPropertyKeyMap(node);
    const fullProperties = {};
    
    // Convert base names to PropertyName#ID format
    for (const [baseName, value] of Object.entries(propsByBase)) {
      const fullKey = keyMap[baseName];
      if (fullKey) {
        fullProperties[fullKey] = value;
        console.log(`✅ Mapped ${baseName} = ${value} → ${fullKey}`);
      } else {
        console.log(`⚠️ Base property not found: ${baseName}`);
      }
    }
    
    if (Object.keys(fullProperties).length === 0) {
      return { 
        success: false, 
        message: "No valid properties to apply",
        availableProperties: Object.keys(keyMap)
      };
    }
    
    // Apply using official setProperties API
    console.log("🎯 Applying properties:", JSON.stringify(fullProperties, null, 2));
    node.setProperties(fullProperties);
    
    const result = {
      success: true,
      message: `Applied ${Object.keys(fullProperties).length} properties using official setProperties API`,
      nodeId: instanceId,
      appliedProperties: fullProperties,
      appliedCount: Object.keys(fullProperties).length
    };
    
    figma.notify(`Applied ${Object.keys(fullProperties).length} properties successfully`);
    return result;
    
  } catch (error) {
    console.error("Error in setInstancePropsByBase:", error);
    const errorMsg = `Error: ${error.message}`;
    figma.notify(errorMsg);
    return {
      success: false,
      message: errorMsg
    };
  }
}

// Implementation for getComponentPropertyReferences function
async function getComponentPropertyReferences(params) {
  console.log("=== getComponentPropertyReferences called ===");
  
  if (!params || !params.nodeId) {
    const error = "nodeId parameter is required";
    console.error(error);
    figma.notify(error);
    return { success: false, message: error };
  }

  try {
    const node = await figma.getNodeByIdAsync(params.nodeId);
    if (!node) {
      const error = `Node not found with ID: ${params.nodeId}`;
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    if (node.type !== "INSTANCE") {
      const error = `Node is not an instance: ${node.type}`;
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    const instance = node;
    console.log(`Getting component property references for instance: ${instance.name}`);

    // Get component properties directly - this is the official source of PropertyName#ID keys
    const properties = instance.componentProperties || {};
    
    console.log("Component properties available:", Object.keys(properties));
    console.log("Component property values:", properties);

    // Return the properties directly - keys are already in PropertyName#ID format
    const result = {
      success: true,
      message: `Got ${Object.keys(properties).length} component properties from "${instance.name}"`,
      nodeId: params.nodeId,
      properties: properties,
      propertyKeys: Object.keys(properties)
    };

    figma.notify(`Got ${Object.keys(properties).length} component properties`);
    return result;

  } catch (error) {
    console.error("Error in getComponentPropertyReferences:", error);
    const errorMsg = `Error: ${error.message}`;
    figma.notify(errorMsg);
    return {
      success: false,
      message: errorMsg
    };
  }
}

// Implementation for setInstanceProperties function with PropertyName#ID adaptation
async function setInstanceProperties(params) {
  console.log("=== setInstanceProperties called ===");
  
  if (!params || !params.nodeId) {
    const error = "nodeId parameter is required";
    console.error(error);
    figma.notify(error);
    return { success: false, message: error };
  }

  if (!params.properties || typeof params.properties !== 'object') {
    const error = "properties parameter is required and must be an object";
    console.error(error);
    figma.notify(error);
    return { success: false, message: error };
  }

  // Check if properties use PropertyName#ID format or base names
  const propertyKeys = Object.keys(params.properties);
  const hasFullKeys = propertyKeys.some(key => key.includes('#'));
  const hasBaseKeys = propertyKeys.some(key => !key.includes('#'));
  
  if (hasFullKeys && hasBaseKeys) {
    console.log("⚠️ Mixed property key formats detected - using direct setProperties");
    // Mixed formats - use direct setProperties for PropertyName#ID keys
  } else if (hasBaseKeys) {
    console.log("🔄 Base property names detected - using adaptation layer");
    // All base names - use adaptation layer
    return await setInstancePropsByBase(params.nodeId, params.properties);
  }
  
  // Direct PropertyName#ID format or mixed - use original logic
  try {
    const node = await figma.getNodeByIdAsync(params.nodeId);
    if (!node) {
      const error = `Node not found with ID: ${params.nodeId}`;
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    if (node.type !== "INSTANCE") {
      const error = `Node is not an instance: ${node.type}`;
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    const instance = node;
    console.log(`🎯 Setting properties for instance: ${instance.name}`);
    console.log("Properties to set (PropertyName#ID format):", params.properties);

    // Apply properties using Figma's official setProperties API
    instance.setProperties(params.properties);

    // Get the updated properties to confirm application
    const updatedProperties = instance.componentProperties || {};
    
    // Build applied properties result
    const applied = {};
    Object.keys(params.properties).forEach(propName => {
      applied[propName] = updatedProperties[propName];
    });

    console.log("Properties applied successfully:", applied);
    
    const result = {
      success: true,
      message: `Applied ${Object.keys(params.properties).length} properties to "${instance.name}"`,
      nodeId: params.nodeId,
      applied: applied
    };

    figma.notify(`Applied ${Object.keys(params.properties).length} properties successfully`);
    return result;

  } catch (error) {
    console.error("Error in setInstanceProperties:", error);
    const errorMsg = `Error: ${error.message}`;
    figma.notify(errorMsg);
    return {
      success: false,
      message: errorMsg
    };
  }
}

// Implementation for createComponentInstance function (enhanced)
async function createComponentInstance(params) {
  console.log("=== createComponentInstance called ===");
  
  if (!params) {
    const error = "params parameter is required";
    console.error(error);
    figma.notify(error);
    return { success: false, message: error };
  }

  const { componentId, componentKey, parentId, x = 0, y = 0 } = params;

  console.log(`=== Seedless Component Creation ===`);
  console.log(`componentId: "${componentId}"`);
  console.log(`componentKey: "${componentKey}"`);
  
  // For local components, ONLY use componentId - importComponentByKeyAsync is for published libraries
  const hasLocalComponentId = componentId && componentId.trim() !== '';
  const hasLibraryComponentKey = componentKey && componentKey.trim() !== '' && componentKey !== 'null';
  
  if (!hasLocalComponentId && !hasLibraryComponentKey) {
    const error = "Either componentId (local) or componentKey (library) must be provided";
    console.error(error);
    figma.notify(error);
    return { success: false, message: error };
  }
  
  console.log(`Method: ${hasLocalComponentId ? 'LOCAL_COMPONENT_ID' : 'LIBRARY_COMPONENT_KEY'}`)

  try {
    let parentNode = null;
    if (parentId) {
      // Get parent node and validate it can contain children
      parentNode = await figma.getNodeByIdAsync(parentId);
      if (!parentNode) {
        const error = `Parent node not found with ID: ${parentId}`;
        console.error(error);
        figma.notify(error);
        return { success: false, message: error };
      }
    }

    if (parentNode && !("children" in parentNode)) {
      const error = `Parent node cannot contain children: ${parentNode.type}`;
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    let component = null;

    // Priority 1: Local component using componentId
    if (hasLocalComponentId) {
      console.log(`🏭 Getting LOCAL component by ID: ${componentId}`);
      const node = await figma.getNodeByIdAsync(componentId);
      if (!node) {
        const error = `Local component not found with ID: ${componentId}`;
        console.error(error);
        figma.notify(error);
        return { success: false, message: error };
      }
      
      if (node.type !== "COMPONENT") {
        const error = `Node is not a component: ${node.type}`;
        console.error(error);
        figma.notify(error);
        return { success: false, message: error };
      }
      
      component = node;
      console.log(`✅ Found LOCAL component: ${component.name}`);
      
    } else if (hasLibraryComponentKey) {
      console.log(`📚 Importing LIBRARY component by key: ${componentKey}`);
      try {
        component = await figma.importComponentByKeyAsync(componentKey);
        console.log(`✅ Imported LIBRARY component: ${component.name}`);
      } catch (importError) {
        const error = `Failed to import library component by key "${componentKey}": ${importError.message}`;
        console.error(error);
        figma.notify(error);
        return { success: false, message: error };
      }
    }

    if (!component) {
      const error = "Failed to get component";
      console.error(error);
      figma.notify(error);
      return { success: false, message: error };
    }

    console.log(`🚀 SEEDLESS: Creating instance of ${component.name}...`);
    
    // Create the instance directly (no seed cloning)
    const instance = component.createInstance();
    instance.x = x;
    instance.y = y;

    // Append to parent if specified, otherwise add to current page
    if (parentNode) {
      parentNode.appendChild(instance);
      console.log(`📍 Instance placed in: ${parentNode.name}`);
    } else {
      figma.currentPage.appendChild(instance);
      console.log(`📍 Instance placed in: Current Page`);
    }

    console.log(`✅ SEEDLESS SUCCESS: ${instance.name} (${instance.id})`);
    
    const result = {
      success: true,
      message: `Seedless creation succeeded: "${instance.name}" from "${component.name}"`,
      id: instance.id,
      name: instance.name,
      parentId: parentId,
      componentId: component.id,
      componentName: component.name,
      method: hasLocalComponentId ? 'direct-local' : 'direct-library'  // Track creation method
    };

    figma.notify(`Created instance "${instance.name}" successfully`);
    return result;

  } catch (error) {
    console.error("Error in createComponentInstance:", error);
    const errorMsg = `Error: ${error.message}`;
    figma.notify(errorMsg);
    return {
      success: false,
      message: errorMsg
    };
  }
}

// Implementation for getInstanceOverrides function
async function getInstanceOverrides(instanceNode = null) {
  console.log("=== getInstanceOverrides called ===");

  let sourceInstance = null;

  // Check if an instance node was passed directly
  if (instanceNode) {
    console.log("Using provided instance node");

    // Validate that the provided node is an instance
    if (instanceNode.type !== "INSTANCE") {
      console.error("Provided node is not an instance");
      figma.notify("Provided node is not a component instance");
      return { success: false, message: "Provided node is not a component instance" };
    }

    sourceInstance = instanceNode;
  } else {
    // No node provided, use selection
    console.log("No node provided, using current selection");

    // Get the current selection
    const selection = figma.currentPage.selection;

    // Check if there's anything selected
    if (selection.length === 0) {
      console.log("No nodes selected");
      figma.notify("Please select at least one instance");
      return { success: false, message: "No nodes selected" };
    }

    // Filter for instances in the selection
    const instances = selection.filter(node => node.type === "INSTANCE");

    if (instances.length === 0) {
      console.log("No instances found in selection");
      figma.notify("Please select at least one component instance");
      return { success: false, message: "No instances found in selection" };
    }

    // Take the first instance from the selection
    sourceInstance = instances[0];
  }

  try {
    console.log(`Getting instance information:`);
    console.log(sourceInstance);

    // Get component overrides and main component
    const overrides = sourceInstance.overrides || [];
    console.log(`  Raw Overrides:`, overrides);

    // Get main component
    const mainComponent = await sourceInstance.getMainComponentAsync();
    if (!mainComponent) {
      console.error("Failed to get main component");
      figma.notify("Failed to get main component");
      return { success: false, message: "Failed to get main component" };
    }

    // return data to MCP server
    const returnData = {
      success: true,
      message: `Got component information from "${sourceInstance.name}" for overrides.length: ${overrides.length}`,
      sourceInstanceId: sourceInstance.id,
      mainComponentId: mainComponent.id,
      overridesCount: overrides.length
    };

    console.log("Data to return to MCP server:", returnData);
    figma.notify(`Got component information from "${sourceInstance.name}"`);

    return returnData;
  } catch (error) {
    console.error("Error in getInstanceOverrides:", error);
    figma.notify(`Error: ${error.message}`);
    return {
      success: false,
      message: `Error: ${error.message}`
    };
  }
}

/**
 * Helper function to validate and get target instances
 * @param {string[]} targetNodeIds - Array of instance node IDs
 * @returns {instanceNode[]} targetInstances - Array of target instances
 */
async function getValidTargetInstances(targetNodeIds) {
  let targetInstances = [];

  // Handle array of instances or single instance
  if (Array.isArray(targetNodeIds)) {
    if (targetNodeIds.length === 0) {
      return { success: false, message: "No instances provided" };
    }
    for (const targetNodeId of targetNodeIds) {
      const targetNode = await figma.getNodeByIdAsync(targetNodeId);
      if (targetNode && targetNode.type === "INSTANCE") {
        targetInstances.push(targetNode);
      }
    }
    if (targetInstances.length === 0) {
      return { success: false, message: "No valid instances provided" };
    }
  } else {
    return { success: false, message: "Invalid target node IDs provided" };
  }


  return { success: true, message: "Valid target instances provided", targetInstances };
}

/**
 * Helper function to validate and get saved override data
 * @param {string} sourceInstanceId - Source instance ID
 * @returns {Promise<Object>} - Validation result with source instance data or error
 */
async function getSourceInstanceData(sourceInstanceId) {
  if (!sourceInstanceId) {
    return { success: false, message: "Missing source instance ID" };
  }

  // Get source instance by ID
  const sourceInstance = await figma.getNodeByIdAsync(sourceInstanceId);
  if (!sourceInstance) {
    return {
      success: false,
      message: "Source instance not found. The original instance may have been deleted."
    };
  }

  // Verify it's an instance
  if (sourceInstance.type !== "INSTANCE") {
    return {
      success: false,
      message: "Source node is not a component instance."
    };
  }

  // Get main component
  const mainComponent = await sourceInstance.getMainComponentAsync();
  if (!mainComponent) {
    return {
      success: false,
      message: "Failed to get main component from source instance."
    };
  }

  return {
    success: true,
    sourceInstance,
    mainComponent,
    overrides: sourceInstance.overrides || []
  };
}

/**
 * Sets saved overrides to the selected component instance(s)
 * @param {InstanceNode[] | null} targetInstances - Array of instance nodes to set overrides to
 * @param {Object} sourceResult - Source instance data from getSourceInstanceData
 * @returns {Promise<Object>} - Result of the set operation
 */
async function setInstanceOverrides(targetInstances, sourceResult) {
  try {


    const { sourceInstance, mainComponent, overrides } = sourceResult;

    console.log(`Processing ${targetInstances.length} instances with ${overrides.length} overrides`);
    console.log(`Source instance: ${sourceInstance.id}, Main component: ${mainComponent.id}`);
    console.log(`Overrides:`, overrides);

    // Process all instances
    const results = [];
    let totalAppliedCount = 0;

    for (const targetInstance of targetInstances) {
      try {
        // // Skip if trying to apply to the source instance itself
        // if (targetInstance.id === sourceInstance.id) {
        //   console.log(`Skipping source instance itself: ${targetInstance.id}`);
        //   results.push({
        //     success: false,
        //     instanceId: targetInstance.id,
        //     instanceName: targetInstance.name,
        //     message: "This is the source instance itself, skipping"
        //   });
        //   continue;
        // }

        // Swap component
        try {
          targetInstance.swapComponent(mainComponent);
          console.log(`Swapped component for instance "${targetInstance.name}"`);
        } catch (error) {
          console.error(`Error swapping component for instance "${targetInstance.name}":`, error);
          results.push({
            success: false,
            instanceId: targetInstance.id,
            instanceName: targetInstance.name,
            message: `Error: ${error.message}`
          });
        }

        // Prepare overrides by replacing node IDs
        let appliedCount = 0;

        // Apply each override
        for (const override of overrides) {
          // Skip if no ID or overriddenFields
          if (!override.id || !override.overriddenFields || override.overriddenFields.length === 0) {
            continue;
          }

          // Replace source instance ID with target instance ID in the node path
          const overrideNodeId = override.id.replace(sourceInstance.id, targetInstance.id);
          const overrideNode = await figma.getNodeByIdAsync(overrideNodeId);

          if (!overrideNode) {
            console.log(`Override node not found: ${overrideNodeId}`);
            continue;
          }

          // Get source node to copy properties from
          const sourceNode = await figma.getNodeByIdAsync(override.id);
          if (!sourceNode) {
            console.log(`Source node not found: ${override.id}`);
            continue;
          }

          // Apply each overridden field
          let fieldApplied = false;
          for (const field of override.overriddenFields) {
            try {
              if (field === "componentProperties") {
                // Apply component properties
                if (sourceNode.componentProperties && overrideNode.componentProperties) {
                  const properties = {};
                  for (const key in sourceNode.componentProperties) {
                    // if INSTANCE_SWAP use id, otherwise use value
                    if (sourceNode.componentProperties[key].type === 'INSTANCE_SWAP') {
                      properties[key] = sourceNode.componentProperties[key].value;
                    
                    } else {
                      properties[key] = sourceNode.componentProperties[key].value;
                    }
                  }
                  overrideNode.setProperties(properties);
                  fieldApplied = true;
                }
              } else if (field === "characters" && overrideNode.type === "TEXT") {
                // For text nodes, need to load fonts first
                await figma.loadFontAsync(overrideNode.fontName);
                overrideNode.characters = sourceNode.characters;
                fieldApplied = true;
              } else if (field in overrideNode) {
                // Direct property assignment
                overrideNode[field] = sourceNode[field];
                fieldApplied = true;
              }
            } catch (fieldError) {
              console.error(`Error applying field ${field}:`, fieldError);
            }
          }

          if (fieldApplied) {
            appliedCount++;
          }
        }

        if (appliedCount > 0) {
          totalAppliedCount += appliedCount;
          results.push({
            success: true,
            instanceId: targetInstance.id,
            instanceName: targetInstance.name,
            appliedCount
          });
          console.log(`Applied ${appliedCount} overrides to "${targetInstance.name}"`);
        } else {
          results.push({
            success: false,
            instanceId: targetInstance.id,
            instanceName: targetInstance.name,
            message: "No overrides were applied"
          });
        }
      } catch (instanceError) {
        console.error(`Error processing instance "${targetInstance.name}":`, instanceError);
        results.push({
          success: false,
          instanceId: targetInstance.id,
          instanceName: targetInstance.name,
          message: `Error: ${instanceError.message}`
        });
      }
    }

    // Return results
    if (totalAppliedCount > 0) {
      const instanceCount = results.filter(r => r.success).length;
      const message = `Applied ${totalAppliedCount} overrides to ${instanceCount} instances`;
      figma.notify(message);
      return {
        success: true,
        message,
        totalCount: totalAppliedCount,
        results
      };
    } else {
      const message = "No overrides applied to any instance";
      figma.notify(message);
      return { success: false, message, results };
    }

  } catch (error) {
    console.error("Error in setInstanceOverrides:", error);
    const message = `Error: ${error.message}`;
    figma.notify(message);
    return { success: false, message };
  }
}

async function setLayoutMode(params) {
  const { nodeId, layoutMode = "NONE", layoutWrap = "NO_WRAP" } = params || {};

  // Get the target node
  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Check if node is a frame or component that supports layoutMode
  if (
    node.type !== "FRAME" &&
    node.type !== "COMPONENT" &&
    node.type !== "COMPONENT_SET" &&
    node.type !== "INSTANCE"
  ) {
    throw new Error(`Node type ${node.type} does not support layoutMode`);
  }

  // Set layout mode
  node.layoutMode = layoutMode;

  // Set layoutWrap if applicable
  if (layoutMode !== "NONE") {
    node.layoutWrap = layoutWrap;
  }

  return {
    id: node.id,
    name: node.name,
    layoutMode: node.layoutMode,
    layoutWrap: node.layoutWrap,
  };
}

async function setPadding(params) {
  const { nodeId, paddingTop, paddingRight, paddingBottom, paddingLeft } =
    params || {};

  // Get the target node
  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Check if node is a frame or component that supports padding
  if (
    node.type !== "FRAME" &&
    node.type !== "COMPONENT" &&
    node.type !== "COMPONENT_SET" &&
    node.type !== "INSTANCE"
  ) {
    throw new Error(`Node type ${node.type} does not support padding`);
  }

  // Check if the node has auto-layout enabled
  if (node.layoutMode === "NONE") {
    throw new Error(
      "Padding can only be set on auto-layout frames (layoutMode must not be NONE)"
    );
  }

  // Set padding values if provided
  if (paddingTop !== undefined) node.paddingTop = paddingTop;
  if (paddingRight !== undefined) node.paddingRight = paddingRight;
  if (paddingBottom !== undefined) node.paddingBottom = paddingBottom;
  if (paddingLeft !== undefined) node.paddingLeft = paddingLeft;

  return {
    id: node.id,
    name: node.name,
    paddingTop: node.paddingTop,
    paddingRight: node.paddingRight,
    paddingBottom: node.paddingBottom,
    paddingLeft: node.paddingLeft,
  };
}

async function setAxisAlign(params) {
  const { nodeId, primaryAxisAlignItems, counterAxisAlignItems } = params || {};

  // Get the target node
  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Check if node is a frame or component that supports axis alignment
  if (
    node.type !== "FRAME" &&
    node.type !== "COMPONENT" &&
    node.type !== "COMPONENT_SET" &&
    node.type !== "INSTANCE"
  ) {
    throw new Error(`Node type ${node.type} does not support axis alignment`);
  }

  // Check if the node has auto-layout enabled
  if (node.layoutMode === "NONE") {
    throw new Error(
      "Axis alignment can only be set on auto-layout frames (layoutMode must not be NONE)"
    );
  }

  // Validate and set primaryAxisAlignItems if provided
  if (primaryAxisAlignItems !== undefined) {
    if (
      !["MIN", "MAX", "CENTER", "SPACE_BETWEEN"].includes(primaryAxisAlignItems)
    ) {
      throw new Error(
        "Invalid primaryAxisAlignItems value. Must be one of: MIN, MAX, CENTER, SPACE_BETWEEN"
      );
    }
    node.primaryAxisAlignItems = primaryAxisAlignItems;
  }

  // Validate and set counterAxisAlignItems if provided
  if (counterAxisAlignItems !== undefined) {
    if (!["MIN", "MAX", "CENTER", "BASELINE"].includes(counterAxisAlignItems)) {
      throw new Error(
        "Invalid counterAxisAlignItems value. Must be one of: MIN, MAX, CENTER, BASELINE"
      );
    }
    // BASELINE is only valid for horizontal layout
    if (
      counterAxisAlignItems === "BASELINE" &&
      node.layoutMode !== "HORIZONTAL"
    ) {
      throw new Error(
        "BASELINE alignment is only valid for horizontal auto-layout frames"
      );
    }
    node.counterAxisAlignItems = counterAxisAlignItems;
  }

  return {
    id: node.id,
    name: node.name,
    primaryAxisAlignItems: node.primaryAxisAlignItems,
    counterAxisAlignItems: node.counterAxisAlignItems,
    layoutMode: node.layoutMode,
  };
}

async function setLayoutSizing(params) {
  const { nodeId, layoutSizingHorizontal, layoutSizingVertical } = params || {};

  // Get the target node
  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Check if node is a frame or component that supports layout sizing
  if (
    node.type !== "FRAME" &&
    node.type !== "COMPONENT" &&
    node.type !== "COMPONENT_SET" &&
    node.type !== "INSTANCE"
  ) {
    throw new Error(`Node type ${node.type} does not support layout sizing`);
  }

  // Check if the node has auto-layout enabled
  if (node.layoutMode === "NONE") {
    throw new Error(
      "Layout sizing can only be set on auto-layout frames (layoutMode must not be NONE)"
    );
  }

  // Validate and set layoutSizingHorizontal if provided
  if (layoutSizingHorizontal !== undefined) {
    if (!["FIXED", "HUG", "FILL"].includes(layoutSizingHorizontal)) {
      throw new Error(
        "Invalid layoutSizingHorizontal value. Must be one of: FIXED, HUG, FILL"
      );
    }
    // HUG is only valid on auto-layout frames and text nodes
    if (
      layoutSizingHorizontal === "HUG" &&
      !["FRAME", "TEXT"].includes(node.type)
    ) {
      throw new Error(
        "HUG sizing is only valid on auto-layout frames and text nodes"
      );
    }
    // FILL is only valid on auto-layout children
    if (
      layoutSizingHorizontal === "FILL" &&
      (!node.parent || node.parent.layoutMode === "NONE")
    ) {
      throw new Error("FILL sizing is only valid on auto-layout children");
    }
    node.layoutSizingHorizontal = layoutSizingHorizontal;
  }

  // Validate and set layoutSizingVertical if provided
  if (layoutSizingVertical !== undefined) {
    if (!["FIXED", "HUG", "FILL"].includes(layoutSizingVertical)) {
      throw new Error(
        "Invalid layoutSizingVertical value. Must be one of: FIXED, HUG, FILL"
      );
    }
    // HUG is only valid on auto-layout frames and text nodes
    if (
      layoutSizingVertical === "HUG" &&
      !["FRAME", "TEXT"].includes(node.type)
    ) {
      throw new Error(
        "HUG sizing is only valid on auto-layout frames and text nodes"
      );
    }
    // FILL is only valid on auto-layout children
    if (
      layoutSizingVertical === "FILL" &&
      (!node.parent || node.parent.layoutMode === "NONE")
    ) {
      throw new Error("FILL sizing is only valid on auto-layout children");
    }
    node.layoutSizingVertical = layoutSizingVertical;
  }

  return {
    id: node.id,
    name: node.name,
    layoutSizingHorizontal: node.layoutSizingHorizontal,
    layoutSizingVertical: node.layoutSizingVertical,
    layoutMode: node.layoutMode,
  };
}

async function setItemSpacing(params) {
  const { nodeId, itemSpacing, counterAxisSpacing } = params || {};

  // Validate that at least one spacing parameter is provided
  if (itemSpacing === undefined && counterAxisSpacing === undefined) {
    throw new Error("At least one of itemSpacing or counterAxisSpacing must be provided");
  }

  // Get the target node
  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node with ID ${nodeId} not found`);
  }

  // Check if node is a frame or component that supports item spacing
  if (
    node.type !== "FRAME" &&
    node.type !== "COMPONENT" &&
    node.type !== "COMPONENT_SET" &&
    node.type !== "INSTANCE"
  ) {
    throw new Error(`Node type ${node.type} does not support item spacing`);
  }

  // Check if the node has auto-layout enabled
  if (node.layoutMode === "NONE") {
    throw new Error(
      "Item spacing can only be set on auto-layout frames (layoutMode must not be NONE)"
    );
  }

  // Set item spacing if provided
  if (itemSpacing !== undefined) {
    if (typeof itemSpacing !== "number") {
      throw new Error("Item spacing must be a number");
    }
    node.itemSpacing = itemSpacing;
  }

  // Set counter axis spacing if provided
  if (counterAxisSpacing !== undefined) {
    if (typeof counterAxisSpacing !== "number") {
      throw new Error("Counter axis spacing must be a number");
    }
    // counterAxisSpacing only applies when layoutWrap is WRAP
    if (node.layoutWrap !== "WRAP") {
      throw new Error(
        "Counter axis spacing can only be set on frames with layoutWrap set to WRAP"
      );
    }
    node.counterAxisSpacing = counterAxisSpacing;
  }

  return {
    id: node.id,
    name: node.name,
    itemSpacing: node.itemSpacing || undefined,
    counterAxisSpacing: node.counterAxisSpacing || undefined,
    layoutMode: node.layoutMode,
    layoutWrap: node.layoutWrap,
  };
}

async function setDefaultConnector(params) {
  const { connectorId } = params || {};
  
  // If connectorId is provided, search and set by that ID (do not check existing storage)
  if (connectorId) {
    // Get node by specified ID
    const node = await figma.getNodeByIdAsync(connectorId);
    if (!node) {
      throw new Error(`Connector node not found with ID: ${connectorId}`);
    }
    
    // Check node type
    if (node.type !== 'CONNECTOR') {
      throw new Error(`Node is not a connector: ${connectorId}`);
    }
    
    // Set the found connector as the default connector
    await figma.clientStorage.setAsync('defaultConnectorId', connectorId);
    
    return {
      success: true,
      message: `Default connector set to: ${connectorId}`,
      connectorId: connectorId
    };
  } 
  // If connectorId is not provided, check existing storage
  else {
    // Check if there is an existing default connector in client storage
    try {
      const existingConnectorId = await figma.clientStorage.getAsync('defaultConnectorId');
      
      // If there is an existing connector ID, check if the node is still valid
      if (existingConnectorId) {
        try {
          const existingConnector = await figma.getNodeByIdAsync(existingConnectorId);
          
          // If the stored connector still exists and is of type CONNECTOR
          if (existingConnector && existingConnector.type === 'CONNECTOR') {
            return {
              success: true,
              message: `Default connector is already set to: ${existingConnectorId}`,
              connectorId: existingConnectorId,
              exists: true
            };
          }
          // The stored connector is no longer valid - find a new connector
          else {
            console.log(`Stored connector ID ${existingConnectorId} is no longer valid, finding a new connector...`);
          }
        } catch (error) {
          console.log(`Error finding stored connector: ${error.message}. Will try to set a new one.`);
        }
      }
    } catch (error) {
      console.log(`Error checking for existing connector: ${error.message}`);
    }
    
    // If there is no stored default connector or it is invalid, find one in the current page
    try {
      // Find CONNECTOR type nodes in the current page
      const currentPageConnectors = figma.currentPage.findAllWithCriteria({ types: ['CONNECTOR'] });
      
      if (currentPageConnectors && currentPageConnectors.length > 0) {
        // Use the first connector found
        const foundConnector = currentPageConnectors[0];
        const autoFoundId = foundConnector.id;
        
        // Set the found connector as the default connector
        await figma.clientStorage.setAsync('defaultConnectorId', autoFoundId);
        
        return {
          success: true,
          message: `Automatically found and set default connector to: ${autoFoundId}`,
          connectorId: autoFoundId,
          autoSelected: true
        };
      } else {
        // If no connector is found in the current page, show a guide message
        throw new Error('No connector found in the current page. Please create a connector in Figma first or specify a connector ID.');
      }
    } catch (error) {
      // Error occurred while running findAllWithCriteria
      throw new Error(`Failed to find a connector: ${error.message}`);
    }
  }
}

async function createCursorNode(targetNodeId) {
  const svgString = `<svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M16 8V35.2419L22 28.4315L27 39.7823C27 39.7823 28.3526 40.2722 29 39.7823C29.6474 39.2924 30.2913 38.3057 30 37.5121C28.6247 33.7654 25 26.1613 25 26.1613H32L16 8Z" fill="#202125" />
  </svg>`;
  try {
    const targetNode = await figma.getNodeByIdAsync(targetNodeId);
    if (!targetNode) throw new Error("Target node not found");

    // The targetNodeId has semicolons since it is a nested node.
    // So we need to get the parent node ID from the target node ID and check if we can appendChild to it or not.
    let parentNodeId = targetNodeId.includes(';') 
      ? targetNodeId.split(';')[0] 
      : targetNodeId;
    if (!parentNodeId) throw new Error("Could not determine parent node ID");

    // Find the parent node to append cursor node as child
    let parentNode = await figma.getNodeByIdAsync(parentNodeId);
    if (!parentNode) throw new Error("Parent node not found");

    // If the parent node is not eligible to appendChild, set the parentNode to the parent of the parentNode
    if (parentNode.type === 'INSTANCE' || parentNode.type === 'COMPONENT' || parentNode.type === 'COMPONENT_SET') {
      parentNode = parentNode.parent;
      if (!parentNode) throw new Error("Parent node not found");
    }

    // Create the cursor node
    const importedNode = await figma.createNodeFromSvg(svgString);
    if (!importedNode || !importedNode.id) {
      throw new Error("Failed to create imported cursor node");
    }
    importedNode.name = "TTF_Connector / Mouse Cursor";
    importedNode.resize(48, 48);

    const cursorNode = importedNode.findOne(node => node.type === 'VECTOR');
    if (cursorNode) {
      cursorNode.fills = [{
        type: 'SOLID',
        color: { r: 0, g: 0, b: 0 },
        opacity: 1
      }];
      cursorNode.strokes = [{
        type: 'SOLID',
        color: { r: 1, g: 1, b: 1 },
        opacity: 1
      }];
      cursorNode.strokeWeight = 2;
      cursorNode.strokeAlign = 'OUTSIDE';
      cursorNode.effects = [{
        type: "DROP_SHADOW",
        color: { r: 0, g: 0, b: 0, a: 0.3 },
        offset: { x: 1, y: 1 },
        radius: 2,
        spread: 0,
        visible: true,
        blendMode: "NORMAL"
      }];
    }

    // Append the cursor node to the parent node
    parentNode.appendChild(importedNode);

    // if the parentNode has auto-layout enabled, set the layoutPositioning to ABSOLUTE
    if ('layoutMode' in parentNode && parentNode.layoutMode !== 'NONE') {
      importedNode.layoutPositioning = 'ABSOLUTE';
    }

    // Adjust the importedNode's position to the targetNode's position
    if (
      targetNode.absoluteBoundingBox &&
      parentNode.absoluteBoundingBox
    ) {
      // if the targetNode has absoluteBoundingBox, set the importedNode's absoluteBoundingBox to the targetNode's absoluteBoundingBox
      console.log('targetNode.absoluteBoundingBox', targetNode.absoluteBoundingBox);
      console.log('parentNode.absoluteBoundingBox', parentNode.absoluteBoundingBox);
      importedNode.x = targetNode.absoluteBoundingBox.x - parentNode.absoluteBoundingBox.x  + targetNode.absoluteBoundingBox.width / 2 - 48 / 2
      importedNode.y = targetNode.absoluteBoundingBox.y - parentNode.absoluteBoundingBox.y + targetNode.absoluteBoundingBox.height / 2 - 48 / 2;
    } else if (
      'x' in targetNode && 'y' in targetNode && 'width' in targetNode && 'height' in targetNode) {
        // if the targetNode has x, y, width, height, calculate center based on relative position
        console.log('targetNode.x/y/width/height', targetNode.x, targetNode.y, targetNode.width, targetNode.height);
        importedNode.x = targetNode.x + targetNode.width / 2 - 48 / 2;
        importedNode.y = targetNode.y + targetNode.height / 2 - 48 / 2;
    } else {
      // Fallback: Place at top-left of target if possible, otherwise at (0,0) relative to parent
      if ('x' in targetNode && 'y' in targetNode) {
        console.log('Fallback to targetNode x/y');
        importedNode.x = targetNode.x;
        importedNode.y = targetNode.y;
      } else {
        console.log('Fallback to (0,0)');
        importedNode.x = 0;
        importedNode.y = 0;
      }
    }

    // get the importedNode ID and the importedNode
    console.log('importedNode', importedNode);


    return { id: importedNode.id, node: importedNode };
    
  } catch (error) {
    console.error("Error creating cursor from SVG:", error);
    return { id: null, node: null, error: error.message };
  }
}

async function createConnections(params) {
  if (!params || !params.connections || !Array.isArray(params.connections)) {
    throw new Error('Missing or invalid connections parameter');
  }
  
  const { connections } = params;
  
  // Command ID for progress tracking
  const commandId = generateCommandId();
  sendProgressUpdate(
    commandId,
    "create_connections",
    "started",
    0,
    connections.length,
    0,
    `Starting to create ${connections.length} connections`
  );
  
  // Get default connector ID from client storage
  const defaultConnectorId = await figma.clientStorage.getAsync('defaultConnectorId');
  if (!defaultConnectorId) {
    throw new Error('No default connector set. Please try one of the following options to create connections:\n1. Create a connector in FigJam and copy/paste it to your current page, then run the "set_default_connector" command.\n2. Select an existing connector on the current page, then run the "set_default_connector" command.');
  }
  
  // Get the default connector
  const defaultConnector = await figma.getNodeByIdAsync(defaultConnectorId);
  if (!defaultConnector) {
    throw new Error(`Default connector not found with ID: ${defaultConnectorId}`);
  }
  if (defaultConnector.type !== 'CONNECTOR') {
    throw new Error(`Node is not a connector: ${defaultConnectorId}`);
  }
  
  // Results array for connection creation
  const results = [];
  let processedCount = 0;
  const totalCount = connections.length;
  
  // Preload fonts (used for text if provided)
  let fontLoaded = false;
  
  for (let i = 0; i < connections.length; i++) {
    try {
      const { startNodeId: originalStartId, endNodeId: originalEndId, text } = connections[i];
      let startId = originalStartId;
      let endId = originalEndId;

      // Check and potentially replace start node ID
      if (startId.includes(';')) {
        console.log(`Nested start node detected: ${startId}. Creating cursor node.`);
        const cursorResult = await createCursorNode(startId);
        if (!cursorResult || !cursorResult.id) {
          throw new Error(`Failed to create cursor node for nested start node: ${startId}`);
        }
        startId = cursorResult.id; 
      }  
      
      const startNode = await figma.getNodeByIdAsync(startId);
      if (!startNode) throw new Error(`Start node not found with ID: ${startId}`);

      // Check and potentially replace end node ID
      if (endId.includes(';')) {
        console.log(`Nested end node detected: ${endId}. Creating cursor node.`);
        const cursorResult = await createCursorNode(endId);
        if (!cursorResult || !cursorResult.id) {
          throw new Error(`Failed to create cursor node for nested end node: ${endId}`);
        }
        endId = cursorResult.id;
      }
      const endNode = await figma.getNodeByIdAsync(endId);
      if (!endNode) throw new Error(`End node not found with ID: ${endId}`);

      
      // Clone the default connector
      const clonedConnector = defaultConnector.clone();
      
      // Update connector name using potentially replaced node names
      clonedConnector.name = `TTF_Connector/${startNode.id}/${endNode.id}`;
      
      // Set start and end points using potentially replaced IDs
      clonedConnector.connectorStart = {
        endpointNodeId: startId,
        magnet: 'AUTO'
      };
      
      clonedConnector.connectorEnd = {
        endpointNodeId: endId,
        magnet: 'AUTO'
      };
      
      // Add text (if provided)
      if (text) {
        try {
          // Try to load the necessary fonts
          try {
            // First check if default connector has font and use the same
            if (defaultConnector.text && defaultConnector.text.fontName) {
              const fontName = defaultConnector.text.fontName;
              await figma.loadFontAsync(fontName);
              clonedConnector.text.fontName = fontName;
            } else {
              // Try default Inter font
              await figma.loadFontAsync({ family: "Inter", style: "Regular" });
            }
          } catch (fontError) {
            // If first font load fails, try another font style
            try {
              await figma.loadFontAsync({ family: "Inter", style: "Medium" });
            } catch (mediumFontError) {
              // If second font fails, try system font
              try {
                await figma.loadFontAsync({ family: "System", style: "Regular" });
              } catch (systemFontError) {
                // If all font loading attempts fail, throw error
                throw new Error(`Failed to load any font: ${fontError.message}`);
              }
            }
          }
          
          // Set the text
          clonedConnector.text.characters = text;
        } catch (textError) {
          console.error("Error setting text:", textError);
          // Continue with connection even if text setting fails
          results.push({
            id: clonedConnector.id,
            startNodeId: startNodeId,
            endNodeId: endNodeId,
            text: "",
            textError: textError.message
          });
          
          // Continue to next connection
          continue;
        }
      }
      
      // Add to results (using the *original* IDs for reference if needed)
      results.push({
        id: clonedConnector.id,
        originalStartNodeId: originalStartId,
        originalEndNodeId: originalEndId,
        usedStartNodeId: startId, // ID actually used for connection
        usedEndNodeId: endId,     // ID actually used for connection
        text: text || ""
      });
      
      // Update progress
      processedCount++;
      sendProgressUpdate(
        commandId,
        "create_connections",
        "in_progress",
        processedCount / totalCount,
        totalCount,
        processedCount,
        `Created connection ${processedCount}/${totalCount}`
      );
      
    } catch (error) {
      console.error("Error creating connection", error);
      // Continue processing remaining connections even if an error occurs
      processedCount++;
      sendProgressUpdate(
        commandId,
        "create_connections",
        "in_progress",
        processedCount / totalCount,
        totalCount,
        processedCount,
        `Error creating connection: ${error.message}`
      );
      
      results.push({
        error: error.message,
        connectionInfo: connections[i]
      });
    }
  }
  
  // Completion update
  sendProgressUpdate(
    commandId,
    "create_connections",
    "completed",
    1,
    totalCount,
    totalCount,
    `Completed creating ${results.length} connections`
  );
  
  return {
    success: true,
    count: results.length,
    connections: results
  };
}

// Set Image Fill - Fill a node with Base64 image data or URL
async function setImageFill(params) {
  const { nodeId, imageBase64, imageUrl, scaleMode, opacity } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }
  if (!imageBase64 && !imageUrl) {
    throw new Error("Must provide either imageBase64 or imageUrl parameter");
  }
  if (imageBase64 && imageUrl) {
    throw new Error("Cannot specify both imageBase64 and imageUrl parameters");
  }
  
  // Auto-detect URL in imageBase64 parameter (workaround for schema caching)
  let actualImageUrl = imageUrl;
  let actualImageBase64 = imageBase64;
  
  if (imageBase64 && (imageBase64.startsWith('http://') || imageBase64.startsWith('https://'))) {
    actualImageUrl = imageBase64;
    actualImageBase64 = null;
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  // Auto-drill down to find fillable node
  let targetNode = node;
  if (!("fills" in node)) {
    // For GROUP/INSTANCE nodes, find first child that supports fills
    if (node.type === "GROUP" || node.type === "INSTANCE") {
      const findFillableChild = (parent) => {
        if ("fills" in parent && parent.visible !== false) {
          return parent;
        }
        if ("children" in parent) {
          for (const child of parent.children) {
            const result = findFillableChild(child);
            if (result) return result;
          }
        }
        return null;
      };
      
      targetNode = findFillableChild(node);
      if (!targetNode) {
        throw new Error(`No fillable child found in ${node.type} node: ${nodeId}`);
      }
    } else {
      throw new Error(`Node does not support fills: ${nodeId} (type: ${node.type})`);
    }
  }

  try {
    let bytes;

    if (actualImageUrl) {
      // URL mode: fetch image from URL
      const response = await fetch(actualImageUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
      }
      const arrayBuffer = await response.arrayBuffer();
      bytes = new Uint8Array(arrayBuffer);
    } else {
      // Base64 mode: decode base64 data
      let base64Data = actualImageBase64;
      if (actualImageBase64.startsWith('data:')) {
        const commaIndex = actualImageBase64.indexOf(',');
        if (commaIndex !== -1) {
          base64Data = actualImageBase64.substring(commaIndex + 1);
        }
      }
      // Convert Base64 to Uint8Array using custom decoder
      bytes = customBase64Decode(base64Data);
    }

    // Create image in Figma
    const image = figma.createImage(bytes);
    const imageHash = image.hash;

    // Create image fill
    const imageFill = {
      type: "IMAGE",
      imageHash: imageHash,
      scaleMode: scaleMode || "FILL",
      opacity: opacity !== undefined ? opacity : 1
    };

    // Apply the fill
    targetNode.fills = [imageFill];

    return {
      success: true,
      nodeId: node.id,
      targetNodeId: targetNode.id,
      nodeName: node.name,
      targetNodeName: targetNode.name,
      scaleMode: scaleMode || "FILL",
      opacity: opacity !== undefined ? opacity : 1
    };
  } catch (error) {
    throw new Error(`Failed to set image fill: ${error.message}`);
  }
}

// Set Text Auto Resize - Configure text node auto-resize mode
async function setTextAutoResize(params) {
  const { nodeId, autoResize } = params || {};

  if (!nodeId) {
    throw new Error("Missing nodeId parameter");
  }
  if (!autoResize) {
    throw new Error("Missing autoResize parameter");
  }

  // Validate autoResize value
  const validModes = ['NONE', 'HEIGHT', 'WIDTH_AND_HEIGHT'];
  if (!validModes.includes(autoResize)) {
    throw new Error(`Invalid autoResize mode: ${autoResize}. Must be one of: ${validModes.join(', ')}`);
  }

  const node = await figma.getNodeByIdAsync(nodeId);
  if (!node) {
    throw new Error(`Node not found with ID: ${nodeId}`);
  }

  if (node.type !== "TEXT") {
    throw new Error(`Node is not a text node: ${nodeId}`);
  }

  try {
    // Load font before making changes (important for text operations)
    await figma.loadFontAsync(node.fontName);

    // Set the auto-resize mode
    node.textAutoResize = autoResize;

    return {
      success: true,
      nodeId: node.id,
      nodeName: node.name,
      autoResize: autoResize
    };
  } catch (error) {
    throw new Error(`Failed to set text auto-resize: ${error.message}`);
  }
}

// Append Card to Container - Clone a template and append to auto-layout container
async function appendCardToContainer(params) {
  const { containerId, templateId, newName, insertIndex } = params || {};

  if (!containerId) {
    throw new Error("Missing containerId parameter");
  }
  if (!templateId) {
    throw new Error("Missing templateId parameter");
  }

  const container = await figma.getNodeByIdAsync(containerId);
  if (!container) {
    throw new Error(`Container not found with ID: ${containerId}`);
  }

  const template = await figma.getNodeByIdAsync(templateId);
  if (!template) {
    throw new Error(`Template not found with ID: ${templateId}`);
  }

  // Strict validation: container must be Auto Layout
  if (!("layoutMode" in container) || container.layoutMode === 'NONE') {
    throw new Error(`Container is not an Auto Layout frame: ${containerId}`);
  }

  try {
    // Clone the template
    const newNode = template.clone();

    // Set new name if provided
    if (newName) {
      newNode.name = newName;
    } else {
      // Generate unique name
      newNode.name = `${template.name}_copy_${Date.now()}`;
    }

    // Insert into container
    const targetIndex = insertIndex !== undefined ? insertIndex : -1;
    if (targetIndex === -1 || targetIndex >= container.children.length) {
      // Append to end
      container.appendChild(newNode);
    } else {
      // Insert at specific position
      container.insertChild(Math.max(0, targetIndex), newNode);
    }

    return {
      success: true,
      newNodeId: newNode.id,
      newNodeName: newNode.name,
      containerName: container.name,
      childrenCount: container.children.length
    };
  } catch (error) {
    throw new Error(`Failed to append card to container: ${error.message}`);
  }
}
</file>

</files>
