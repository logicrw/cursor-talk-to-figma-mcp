# Figma Poster Automation — Image Fill Reliability

## Requirements
- 目标：每周将不同的 `docx` 研报自动解析为内容数据（文本/图片），在 Figma 中基于既有模板自动排版生成海报。
- 现状：文本流基本可控，图片“填充”失败概率高，节点最终显示为默认灰色块（未出现期望的图片填充效果）。
- 期望：
  - 支持两种图片输入路径：`imageUrl`（优先）与 `imageBase64`（回退）。
  - 适配两种位置：
    1) 新建的矩形/容器节点（独立图像卡片）。
    2) 组件实例中的“图片槽位”（命名如 `imgSlot1` 等）。
  - 在失败时给出明确可追踪的错误与上下文（URL、字节长度、节点类型等），便于快速定位。
- 约束：
  - 插件运行环境为 Figma 桌面/网页版，网络访问需符合 `manifest.json` 的 `networkAccess.allowedDomains` 白名单；
  - 本地静态资源服务器（默认 `http://127.0.0.1:3056/assets`）按数据集目录暴露图片；
  - 通过 MCP WebSocket 与插件通信，消息大小与频率需考虑（Base64 传输存在体积上限与速率限制）。

## Notes
- The plugin implements `setImageFill(nodeId, imageBase64 | imageUrl)` and uses `figma.createImage(Uint8Array)` then sets an `ImagePaint` on `fills`.
- URL-first flow: plugin fetches bytes via `fetch(imageUrl)`, then `new Uint8Array(await res.arrayBuffer())` → `createImage(bytes)`.
- Base64 fallback: server tries to map public URL back to local file; if size ≤ limit, it reads file and sends `Buffer.toString('base64')` to plugin.
- Current Base64 decoder is custom; it strips `=` padding and whitespace but doesn’t normalize base64url (`-`/`_`) variants.
- The auto-drill logic chooses the first descendant with a `fills` prop; TEXT also has `fills`, but `ImagePaint` may be invalid for TEXT.
- Instances: writing `fills` on a child inside an instance is allowed only if that node/property is overridable; otherwise Figma throws.
- Static server sets correct `Content-Type` and CORS; manifest whitelists `http://127.0.0.1:3056` and the WebSocket host.
- Gray rectangles likely indicate that image fill was never applied (request failed, decode failed, or wrong target node type), leaving default SOLID fill.
- Useful references (recently verified):
  - Figma Plugin Docs — Working with Images / `createImage`.
  - Community thread: converting Base64 for `rect.fills.imageHash` nuances (padding, url-safe, decoding correctness).

## Open Questions
- Do failures occur in URL mode, Base64 mode, or both? Any error surfaced in server/plugin logs during `set_image_fill`?
- When targeting instance slots, are we always resolving the rectangle node (not TEXT/FRAME) by name? Any cases where the ID points to a non-image-capable node?
- Are any images unusually large or using formats not supported (e.g., CMYK JPEG, progressive JPEG edge cases, or malformed files)?
- Is the plugin run inside Desktop or Web? Any environment-specific network policies affecting `http://127.0.0.1` fetch?
- For Base64 payloads, do we ever receive base64url (`-`/`_`) or data-URL prefixes? Any trimming/line-break issues from upstream senders?
- In component instances, are the target fills locked by the main component, preventing overrides without detaching or using component properties?
- Is there any asynchronous race (node removed/renamed) between rectangle creation and image fill application in the generator path?

