# Figma Poster Automation — Image Fill Reliability

## Requirements
- 目标：每周将不同的 `docx` 研报自动解析为内容数据（文本/图片），在 Figma 中基于既有模板自动排版生成海报。
- 现状：文本流基本可控，图片“填充”失败概率高，节点最终显示为默认灰色块（未出现期望的图片填充效果）。
- 期望：
  - 支持两种图片输入路径：`imageUrl`（优先）与 `imageBase64`（回退）。
  - 适配两种位置：
    1) 新建的矩形/容器节点（独立图像卡片）。
    2) 组件实例中的“图片槽位”（命名如 `imgSlot1` 等）。
  - 在失败时给出明确可追踪的错误与上下文（URL、字节长度、节点类型等），便于快速定位。
- 约束：
  - 插件运行环境为 Figma 桌面/网页版，网络访问需符合 `manifest.json` 的 `networkAccess.allowedDomains` 白名单；
  - 本地静态资源服务器（默认 `http://127.0.0.1:3056/assets`）按数据集目录暴露图片；
  - 通过 MCP WebSocket 与插件通信，消息大小与频率需考虑（Base64 传输存在体积上限与速率限制）。
- 2024 Poster reliability hotfix scope：
  - MCP 工具 `prepare_card_root` 需直接透传插件 JSON（含 `rootId`、`detachedTimes`），避免外层 `{content:[]}` 包裹导致脚本解析困难。
  - 插件 `prepareCardRoot` 必须沿索引路径 detach 至无实例状态，并记录日志；`setImageFill` 负责尺寸与填充（含 `flushAsync` 时序、浮点高度、清理描边/效果、锁比例），不再自动 detach，且全文件禁止使用 `?.`、`??`、`catch {}` 等 Figma 旧运行时不支持语法。
  - 生产脚本 `run_weekly_poster.js` 在填充 FigureCard / BodyCard 前调用 `prepare_card_root`，后续查询与填图均使用返回的 `rootId`，多图写入需串行 `await`，忽略隐藏槽位并在填图时启用可见。
  - 内容生成器 `content-generator.js` 调用 `set_image_fill` 时统一显式传入 `scaleMode: 'FILL'` 并移除 `autoDetach`；Manifest `devAllowedDomains` 只允许 `localhost`，杜绝 `127.0.0.1` 以避免 CSP。

## Notes
- The plugin implements `setImageFill(nodeId, imageBase64 | imageUrl)` and uses `figma.createImage(Uint8Array)` then sets an `ImagePaint` on `fills`.
- URL-first flow: plugin fetches bytes via `fetch(imageUrl)`, then `new Uint8Array(await res.arrayBuffer())` → `createImage(bytes)`.
- Base64 fallback: server tries to map public URL back to local file; if size ≤ limit, it reads file and sends `Buffer.toString('base64')` to plugin.
- Current Base64 decoder is custom; it strips `=` padding and whitespace but doesn’t normalize base64url (`-`/`_`) variants.
- The auto-drill logic chooses the first descendant with a `fills` prop; TEXT also has `fills`, but `ImagePaint` may be invalid for TEXT.
- Instances: writing `fills` on a child inside an instance is allowed only if that node/property is overridable; otherwise Figma throws.
- Static server sets correct `Content-Type` and CORS; manifest whitelists `http://127.0.0.1:3056` and the WebSocket host.
- Gray rectangles likely indicate that image fill was never applied (request failed, decode failed, or wrong target node type), leaving default SOLID fill.
- Useful references (recently verified):
  - Figma Plugin Docs — Working with Images / `createImage`.
  - Community thread: converting Base64 for `rect.fills.imageHash` nuances (padding, url-safe, decoding correctness).
- `prepare_card_root` 目前由服务器包裹在 `{content:[{text:...}]}` 中返回，脚本端需额外解析 JSON 才能拿到 `rootId`；新流程要求直接透传原始结构以便复用。
- 插件 `setImageFill` 仍在 `autoDetach` 时依赖 `detachAllInstanceAncestors`，并对宽高应用 `Math.round`；多次填充共用旧 `nodeId` 会在第二张图开始失败。
- `discoverImageTargets` 会返回隐藏槽位，且多图填充采用 `Promise.all` 风格并发（隐式），导致布局尚未刷新前即读取宽度，诱发 0 宽或空洞。
- Manifest dev hosts 仍允许 `127.0.0.1`，在 Desktop CSP 下会被视作不同源，需要统一为 `localhost`。

## Open Questions
- How should we handle cases where `prepare_card_root` detaches zero instances (already detached)? Do we still trust the returned `rootId` as the working root?
- Are there cards with multiple nested instances beyond the default 10-iteration guard that require increasing the loop cap?
- Should `setImageFill` restore original layout sizing after resizing, or is locking aspect ratio sufficient for future resizes?
- When sequentially filling multiple slots, do we need additional throttling/delay between `set_image_fill` calls to let layout settle on slower documents?
- Does any downstream consumer still rely on the previous `{content:[{text:"..."}]}` response shape from the server's `prepare_card_root` tool?

## Solution
- 服务器工具 `prepare_card_root` 直接透传插件返回值 `{ success, rootId, detachedTimes, ... }`，并在调用端保留一次 JSON.parse 回退逻辑以兼容旧版包裹格式。
- 插件内：
  - `prepareCardRoot` 使用索引路径迭代 `detachInstance()`（循环上限 25），打印 `[prepare_card_root] detachedTimes: X` 日志；若超过上限输出警告但继续使用当前 frame；始终返回最新 `rootId` 与计数。
  - `setImageFill` 仅负责填充与尺寸：在进入前缓存可涂层节点与槽位、保护可见性，执行 `layoutSizing=FILL/FIXED → flush → width`，必要时取父容器有效宽度；依据原图宽高算出浮点高度，先 `resize(slotNode)` 再 `flush`，最后让 paint node FILL 并清除描边/效果、尝试锁定比例，恢复原可见性，整个实现不再自动 detach 且全文件移除不兼容语法。
  - 额外执行 `detachInstanceDescendants`，确保 `imgSlotX` 等嵌套实例被完全转成普通 Frame，避免 resize 被悄然忽略。
- 槽位驱动：`set_image_fill` 现以槽位 Frame 为输入，必要时在槽位内部创建/复用填充矩形，统一使用 `scaleMode: 'FILL'` + 整数尺寸，彻底消除 1px 缝。
- 生产脚本 `run_weekly_poster.js`：FigureCard、BodyCard 初始均调用 `prepare_card_root` 并使用返回的 `rootId` 进行所有子节点查找；图片槽位发现流程过滤 `visible !== true` 的节点并在填图时强制设为可见；多图填充严格串行 `await` 并在回调内调用 `figma.flushAsync()`。
- 内容生成器 `content-generator.js`：`set_image_fill` 调用始终传入 `scaleMode: 'FILL'` 且不再提供 `autoDetach`。
- Manifest 中 `allowedDomains` 调整为 `"none"`，`devAllowedDomains` 限定为 `localhost` 端点；所有使用到主机名的代码统一为 `localhost`。

## Tests
- 手动运行 `scripts/run_weekly_poster.js`，观察控制台日志，确认 `prepare_card_root` 输出 `detachedTimes >= 0` 且填充流程无异常。
- 在 Figma 插件内手动针对单一卡片执行多张图片填充，验证第二张及后续图片均正确显示且无 1px 视觉缝。
- 通过隐藏部分图片槽位后再次填充，确认 `slot:IMAGE_GRID` Hug + Packed 行为无空洞。
- 导入插件打包 zip，确认不再出现 `Unexpected token` 等语法报错。
- 随机抽查 `imgSlotX`，确认 `width` 与 `height` 皆为整数，且 `paintNode` 使用 `scaleMode:FILL` 覆盖整个槽位。

## Risks & Mitigations
- 宏量 detach 仍可能超过 25 层导致遗留实例：增加警告日志并保留索引路径，可在后续收集样本再调大上限。
- 顺序填图可能减慢整体速度：保留 `THROTTLE_MS` 配置以便后续调优。
- Manifest 域名收窄可能影响生产环境：上线前确认仅在开发环境使用 `devAllowedDomains`，保持 `allowedDomains` 为 `"none"`。

## Rollout & Rollback
- Rollout：本地验证 → 提交补丁 → 运行 weekly poster 脚本进行集成测试 → 记录日志截图并提醒同步 Manifest 变更给团队。
- Rollback：若发布后仍出现填图缺失或布局变形，可恢复至上一个已知稳定版本并复原 Manifest，待排查后重新尝试。
